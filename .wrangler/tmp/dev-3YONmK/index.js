var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// .wrangler/tmp/bundle-gfKrxp/checked-fetch.js
var urls = /* @__PURE__ */ new Set();
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
__name(checkURL, "checkURL");
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    const [request, init] = argArray;
    checkURL(request, init);
    return Reflect.apply(target, thisArg, argArray);
  }
});

// node_modules/hono/dist/compose.js
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/hono/dist/utils/url.js
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j2 = paths.length - 1; j2 >= 0; j2--) {
      if (paths[j2].includes(mark)) {
        paths[j2] = paths[j2].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a2) => a2.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k2, v] of this.#res.headers.entries()) {
        if (k2 === "content-type") {
          continue;
        }
        if (k2 === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k2, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  header = /* @__PURE__ */ __name((name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  set = /* @__PURE__ */ __name((key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  }, "set");
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k2, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k2, v);
        } else {
          responseHeaders.delete(k2);
          for (const v2 of v) {
            responseHeaders.append(k2, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
  text = /* @__PURE__ */ __name((text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m2 of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m2.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app2) {
    const subApp = this.basePath(path);
    app2.routes.map((r) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a2, b) {
  if (a2.length === 1) {
    return b.length === 1 ? a2 < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a2 === ONLY_WILDCARD_REG_EXP_STR || a2 === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a2 === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a2.length === b.length ? a2 < b ? -1 : 1 : b.length - a2.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k2) => k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k2) => k2.length > 1 && k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k2) => {
      const c = this.#children[k2];
      return (typeof c.#varIndex === "number" ? `(${k2})@${c.#varIndex}` : regExpMetaChars.has(k2) ? `\\${k2}` : k2) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m2) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m2];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j2 = tokens.length - 1; j2 >= 0; j2--) {
        if (tokens[j2].indexOf(mark) !== -1) {
          tokens[j2] = tokens[j2].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j2 = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h2]) => [h2, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j2++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j2, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j2] = handlers.map(([h2, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h2, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j2 = 0, len2 = handlerData[i].length; j2 < len2; j2++) {
      const map = handlerData[i][j2]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k2 = 0, len3 = keys.length; k2 < len3; k2++) {
        map[keys[k2]] = paramReplacementMap[map[keys[k2]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k2 of Object.keys(middleware).sort((a2, b) => b.length - a2.length)) {
    if (buildWildcardRegExp(k2).test(path)) {
      return [...middleware[k2]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m2) => {
          middleware[m2][path] ||= findMiddleware(middleware[m2], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(middleware[m2]).forEach((p) => {
            re.test(p) && middleware[m2][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(routes[m2]).forEach(
            (p) => re.test(p) && routes[m2][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          routes[m2][path2] ||= [
            ...findMiddleware(middleware[m2], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m2][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m2 = /* @__PURE__ */ Object.create(null);
      m2[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m2];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a2) => a2.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m2 = node.#methods[i];
      const handlerSet = m2[method] || m2[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j2 = 0, len2 = curNodes.length; j2 < len2; j2++) {
        const node = curNodes[j2];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k2 = 0, len3 = node.#patterns.length; k2 < len3; k2++) {
          const pattern = node.#patterns[k2];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m2 = matcher.exec(restPathString);
            if (m2) {
              params[name] = m2[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m2[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a2, b) => {
        return a2.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el2 = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x2) => x2.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x2) => x2.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x2) => x2.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x2) => typeof Promise !== "undefined" && x2 instanceof Promise, "isAsync");

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip2, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip2, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip2)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip2)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch2) => ch2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch2) => ch2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      } else if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new _ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
__name(cleanParams, "cleanParams");
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
var NEVER = INVALID;

// node_modules/@cloudflare/realtimekit/dist/index.es.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
__name(validate, "validate");
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
__name(stringify, "stringify");
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
__name(v4, "v4");
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
var Utils = class _Utils {
  static {
    __name(this, "Utils");
  }
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  static getMacOSVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] !== 10)
      return void 0;
    switch (v[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  static getAndroidVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] === 1 && v[1] < 5)
      return void 0;
    if (v[0] === 1 && v[1] < 6)
      return "Cupcake";
    if (v[0] === 1 && v[1] >= 6)
      return "Donut";
    if (v[0] === 2 && v[1] < 2)
      return "Eclair";
    if (v[0] === 2 && v[1] === 2)
      return "Froyo";
    if (v[0] === 2 && v[1] > 2)
      return "Gingerbread";
    if (v[0] === 3)
      return "Honeycomb";
    if (v[0] === 4 && v[1] < 1)
      return "Ice Cream Sandwich";
    if (v[0] === 4 && v[1] < 4)
      return "Jelly Bean";
    if (v[0] === 4 && v[1] >= 4)
      return "KitKat";
    if (v[0] === 5)
      return "Lollipop";
    if (v[0] === 6)
      return "Marshmallow";
    if (v[0] === 7)
      return "Nougat";
    if (v[0] === 8)
      return "Oreo";
    if (v[0] === 9)
      return "Pie";
    return void 0;
  }
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = _Utils.getVersionPrecision(versionA);
    const versionBPrecision = _Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = _Utils.map([versionA, versionB], (version) => {
      const delta = precision - _Utils.getVersionPrecision(version);
      const _version = version + new Array(delta + 1).join(".0");
      return _Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  static map(arr, iterator) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator(arr[i]));
    }
    return result;
  }
  static find(arr, predicate) {
    let i;
    let l;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l = arr.length; i < l; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l = assigners.length; i < l; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test(parser2) {
      const notLikeAndroid = !parser2.test(/like android/i);
      const butAndroid = parser2.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var osParsersList = [
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version) {
        result.version = version;
      }
      return result;
    }
  },
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version);
      const os2 = {
        name: OS_MAP.MacOS,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  {
    test(parser2) {
      const notLikeAndroid = !parser2.test(/like android/i);
      const butAndroid = parser2.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version);
      const os2 = {
        name: OS_MAP.Android,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os2 = {
        name: OS_MAP.WebOS
      };
      if (version && version.length) {
        os2.version = version;
      }
      return os2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
];
var platformParsersList = [
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser2) {
      const iDevice = parser2.test(/ipod|iphone/i);
      const likeIDevice = parser2.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  {
    test(parser2) {
      const osMajorVersion = Number(String(parser2.getOSVersion()).split(".")[0]);
      return parser2.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
var enginesParsersList = [
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  {
    test(parser2) {
      return parser2.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  {
    test(parser2) {
      const isGecko = parser2.test(/gecko/i);
      const likeGecko = parser2.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  }
];
var Parser = class {
  static {
    __name(this, "Parser");
  }
  constructor(UA2, skipParsing = false) {
    if (UA2 === void 0 || UA2 === null || UA2 === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA2;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  getUA() {
    return this._ua;
  }
  test(regex) {
    return regex.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const os2 = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os2) {
      this.parsedResult.os = os2.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0];
    let comparableVersion = version;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version[0] === ">" || version[0] === "<") {
      comparableVersion = version.substr(1);
      if (version[1] === "=") {
        isLoose = true;
        comparableVersion = version.substr(2);
      } else {
        expectedResults = [];
      }
      if (version[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version[0] === "=") {
      comparableVersion = version.substr(1);
    } else if (version[0] === "~") {
      isLoose = true;
      comparableVersion = version.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var Bowser = class {
  static {
    __name(this, "Bowser");
  }
  static getParser(UA2, skipParsing = false) {
    if (typeof UA2 !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser(UA2, skipParsing);
  }
  static parse(UA2) {
    return new Parser(UA2).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
function typeofJsonValue(value) {
  let t = typeof value;
  if (t == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t;
}
__name(typeofJsonValue, "typeofJsonValue");
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
__name(isJsonObject, "isJsonObject");
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es2 = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es2 -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es2 -= 1;
  let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b = decTable[base64Str.charCodeAt(i)];
    if (b === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
__name(base64decode, "base64decode");
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b = bytes[i];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}
__name(base64encode, "base64encode");
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is2(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer2) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer2.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is2(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf2) => uf2.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is2 = /* @__PURE__ */ __name((message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]), "is2");
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
__name(varint64read, "varint64read");
function varint64write(lo, hi2, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi2 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi2 & 7) << 4;
  const hasMoreBits = !(hi2 >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi2 >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi2 >>> 31 & 1);
}
__name(varint64write, "varint64write");
var TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL$1) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL$1 | 0);
      lowBits = lowBits % TWO_PWR_32_DBL$1;
    }
  }
  __name(add1e6digit, "add1e6digit");
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
__name(int64fromString, "int64fromString");
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  __name(decimalFrom1e7, "decimalFrom1e7");
  return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
}
__name(int64toString, "int64toString");
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
__name(varint32write, "varint32write");
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
__name(varint32read, "varint32read");
var BI$1;
function detectBi() {
  const dv2 = new DataView(new ArrayBuffer(8));
  const ok2 = globalThis.BigInt !== void 0 && typeof dv2.getBigInt64 === "function" && typeof dv2.getBigUint64 === "function" && typeof dv2.setBigInt64 === "function" && typeof dv2.setBigUint64 === "function";
  BI$1 = ok2 ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv2
  } : void 0;
}
__name(detectBi, "detectBi");
detectBi();
function assertBi(bi2) {
  if (!bi2)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
__name(assertBi, "assertBi");
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  static {
    __name(this, "SharedPbLong");
  }
  constructor(lo, hi2) {
    this.lo = lo | 0;
    this.hi = hi2 | 0;
  }
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  static {
    __name(this, "PbULong");
  }
  static from(value) {
    if (BI$1)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI$1.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI$1.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI$1.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI$1.UMAX)
            throw new Error("ulong too large");
          BI$1.V.setBigUint64(0, value, true);
          return new _PbULong(BI$1.V.getInt32(0, true), BI$1.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi2] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi2);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL);
      }
    throw new Error("unknown value " + typeof value);
  }
  toString() {
    return BI$1 ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  toBigInt() {
    assertBi(BI$1);
    BI$1.V.setInt32(0, this.lo, true);
    BI$1.V.setInt32(4, this.hi, true);
    return BI$1.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  static {
    __name(this, "PbLong");
  }
  static from(value) {
    if (BI$1)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI$1.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI$1.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI$1.MIN)
            throw new Error("signed long too small");
          if (value > BI$1.MAX)
            throw new Error("signed long too large");
          BI$1.V.setBigInt64(0, value, true);
          return new _PbLong(BI$1.V.getInt32(0, true), BI$1.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi2] = int64fromString(value);
          if (minus) {
            if (hi2 > HALF_2_PWR_32 || hi2 == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi2 >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi2);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL) : new _PbLong(-value, -value / TWO_PWR_32_DBL).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  negate() {
    let hi2 = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi2 += 1;
    return new _PbLong(lo, hi2);
  }
  toString() {
    if (BI$1)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  toBigInt() {
    assertBi(BI$1);
    BI$1.V.setInt32(0, this.lo, true);
    BI$1.V.setInt32(4, this.hi, true);
    return BI$1.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);
var defaultsRead$1 = {
  readUnknownField: true,
  readerFactory: /* @__PURE__ */ __name((bytes) => new BinaryReader(bytes), "readerFactory")
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
}
__name(binaryReadOptions, "binaryReadOptions");
var BinaryReader = class {
  static {
    __name(this, "BinaryReader");
  }
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  int32() {
    return this.uint32() | 0;
  }
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  int64() {
    return new PbLong(...this.varint64());
  }
  uint64() {
    return new PbULong(...this.varint64());
  }
  sint64() {
    let [lo, hi2] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi2 & 1) << 31) ^ s;
    hi2 = hi2 >>> 1 ^ s;
    return new PbLong(lo, hi2);
  }
  bool() {
    let [lo, hi2] = this.varint64();
    return lo !== 0 || hi2 !== 0;
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
__name(assert, "assert");
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
__name(assertInt32, "assertInt32");
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
__name(assertUInt32, "assertUInt32");
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}
__name(assertFloat32, "assertFloat32");
var defaultsWrite$1 = {
  writeUnknownFields: true,
  writerFactory: /* @__PURE__ */ __name(() => new BinaryWriter(), "writerFactory")
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
}
__name(binaryWriteOptions, "binaryWriteOptions");
var BinaryWriter = class {
  static {
    __name(this, "BinaryWriter");
  }
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  sfixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  fixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi2 = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi2, this.buf);
    return this;
  }
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};
var defaultsWrite = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
__name(jsonReadOptions, "jsonReadOptions");
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
__name(jsonWriteOptions, "jsonWriteOptions");
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb2 = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let next = snakeCase.charAt(i);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb2.push(next);
      capNext = true;
    } else if (capNext) {
      sb2.push(next.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb2.push(next.toLowerCase());
    } else {
      sb2.push(next);
    }
  }
  return sb2.join("");
}
__name(lowerCamelCase, "lowerCamelCase");
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a2, _b2, _c2, _d2;
  field.localName = (_a2 = field.localName) !== null && _a2 !== void 0 ? _a2 : lowerCamelCase(field.name);
  field.jsonName = (_b2 = field.jsonName) !== null && _b2 !== void 0 ? _b2 : lowerCamelCase(field.name);
  field.repeat = (_c2 = field.repeat) !== null && _c2 !== void 0 ? _c2 : RepeatType.NO;
  field.opt = (_d2 = field.opt) !== null && _d2 !== void 0 ? _d2 : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}
__name(normalizeFieldInfo, "normalizeFieldInfo");
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}
__name(isOneofGroup, "isOneofGroup");
var ReflectionTypeCheck = class {
  static {
    __name(this, "ReflectionTypeCheck");
  }
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k2) => !data.known.includes(k2)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name of data.oneofs) {
      const group = message[name];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f) => f.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map, type, depth) {
    let keys = Object.keys(map);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k2) => parseInt(k2)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}
__name(reflectionLongConvert, "reflectionLongConvert");
var ReflectionJsonReader = class {
  static {
    __name(this, "ReflectionJsonReader");
  }
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            if (jsonValue === null)
              continue;
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue === null)
              continue;
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e;
    try {
      switch (type) {
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e2) {
            e2 = "invalid UTF8";
            break;
          }
          return json;
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error) {
      e = error.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json);
  }
};
var ReflectionJsonWriter = class {
  static {
    __name(this, "ReflectionJsonWriter");
  }
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            const val = this.scalar(field.T, value[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value.length; i++) {
            assert(value[i] === void 0 || typeof value[i] == "number");
            const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value.length; i++) {
            const val = this.message(messageType, value[i], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed2 = emitDefaultValues || optional;
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assertUInt32(value);
        return value;
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        if (value === "")
          return ed2 ? "" : void 0;
        assert(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        if (value === false)
          return ed2 ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed2)
          return void 0;
        return ulong.toString();
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed2)
          return void 0;
        return long.toString();
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed2 ? "" : void 0;
        return base64encode(value);
    }
  }
};
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
__name(reflectionScalarDefault, "reflectionScalarDefault");
var ReflectionBinaryReader = class {
  static {
    __name(this, "ReflectionBinaryReader");
  }
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u2 = options.readUnknownField;
        if (u2 == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L2 = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T, L2));
            } else
              arr.push(this.scalar(reader, T, L2));
          } else
            target[localName] = this.scalar(reader, T, L2);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};
var ReflectionBinaryWriter = class {
  static {
    __name(this, "ReflectionBinaryWriter");
  }
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a2, b) => a2.no - b.no);
    }
  }
  write(message, writer2, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer2, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer2, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer2, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer2, options, field.T(), field.no, item);
          } else {
            this.message(writer2, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer2, options, field, key, val);
          break;
      }
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer2);
  }
  mapEntry(writer2, options, field, key, value) {
    writer2.tag(field.no, WireType.LengthDelimited);
    writer2.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer2, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer2, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer2, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer2, options, field.V.T(), 2, value);
        break;
    }
    writer2.join();
  }
  message(writer2, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer2.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer2.join();
  }
  scalar(writer2, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer2.tag(fieldNo, wireType);
      writer2[method](value);
    }
  }
  packed(writer2, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer2.tag(fieldNo, WireType.LengthDelimited);
    writer2.fork();
    let [, method] = this.scalarInfo(type);
    for (let i = 0; i < value.length; i++)
      writer2[method](value[i]);
    writer2.join();
  }
  scalarInfo(type, value) {
    let t = WireType.Varint;
    let m2;
    let i = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m2 = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value.length;
        t = WireType.LengthDelimited;
        m2 = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m2 = "bool";
        break;
      case ScalarType.UINT32:
        m2 = "uint32";
        break;
      case ScalarType.DOUBLE:
        t = WireType.Bit64;
        m2 = "double";
        break;
      case ScalarType.FLOAT:
        t = WireType.Bit32;
        m2 = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value).isZero();
        m2 = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value).isZero();
        m2 = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value).isZero();
        t = WireType.Bit64;
        m2 = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value.byteLength;
        t = WireType.LengthDelimited;
        m2 = "bytes";
        break;
      case ScalarType.FIXED32:
        t = WireType.Bit32;
        m2 = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t = WireType.Bit32;
        m2 = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value).isZero();
        t = WireType.Bit64;
        m2 = "sfixed64";
        break;
      case ScalarType.SINT32:
        m2 = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value).isZero();
        m2 = "sint64";
        break;
    }
    return [t, m2, i || d];
  }
};
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}
__name(reflectionCreate, "reflectionCreate");
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = fieldValue[i];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = T.create(fieldValue[i]);
        else if (output[name] === void 0)
          output[name] = T.create(fieldValue);
        else
          T.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k2 of Object.keys(fieldValue))
              output[name][k2] = T2.create(fieldValue[k2]);
            break;
        }
        break;
    }
  }
}
__name(reflectionMergePartial, "reflectionMergePartial");
function reflectionEquals(info, a2, b) {
  if (a2 === b)
    return true;
  if (!a2 || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
__name(reflectionEquals, "reflectionEquals");
var objectValues = Object.values;
function primitiveEq(type, a2, b) {
  if (a2 === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba2 = a2;
  let bb2 = b;
  if (ba2.length !== bb2.length)
    return false;
  for (let i = 0; i < ba2.length; i++)
    if (ba2[i] != bb2[i])
      return false;
  return true;
}
__name(primitiveEq, "primitiveEq");
function repeatedPrimitiveEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!primitiveEq(type, a2[i], b[i]))
      return false;
  return true;
}
__name(repeatedPrimitiveEq, "repeatedPrimitiveEq");
function repeatedMsgEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!type.equals(a2[i], b[i]))
      return false;
  return true;
}
__name(repeatedMsgEq, "repeatedMsgEq");
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var MessageType = class {
  static {
    __name(this, "MessageType");
  }
  constructor(name, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  clone(message) {
    let copy = this.create();
    reflectionMergePartial(this, copy, message);
    return copy;
  }
  equals(a2, b) {
    return reflectionEquals(this, a2, b);
  }
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  toJsonString(message, options) {
    var _a2;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  internalBinaryWrite(message, writer2, options) {
    this.refBinWriter.write(message, writer2, options);
    return writer2;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};
var createCache = /* @__PURE__ */ __name((lastNumberWeakMap) => {
  return (collection, nextNumber) => {
    lastNumberWeakMap.set(collection, nextNumber);
    return nextNumber;
  };
}, "createCache");
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
var createGenerateUniqueNumber = /* @__PURE__ */ __name((cache2, lastNumberWeakMap) => {
  return (collection) => {
    const lastNumber = lastNumberWeakMap.get(collection);
    let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
    if (!collection.has(nextNumber)) {
      return cache2(collection, nextNumber);
    }
    if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
      while (collection.has(nextNumber)) {
        nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
      }
      return cache2(collection, nextNumber);
    }
    if (collection.size > MAX_SAFE_INTEGER) {
      throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
    }
    while (collection.has(nextNumber)) {
      nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
    }
    return cache2(collection, nextNumber);
  };
}, "createGenerateUniqueNumber");
var LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
var cache = createCache(LAST_NUMBER_WEAK_MAP);
var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
var isCallNotification = /* @__PURE__ */ __name((message) => {
  return message.method !== void 0 && message.method === "call";
}, "isCallNotification");
var isClearResponse = /* @__PURE__ */ __name((message) => {
  return message.error === null && typeof message.id === "number";
}, "isClearResponse");
var load = /* @__PURE__ */ __name((url) => {
  const scheduledIntervalFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const unrespondedRequests = /* @__PURE__ */ new Map();
  const worker2 = new Worker(url);
  worker2.addEventListener("message", ({ data }) => {
    if (isCallNotification(data)) {
      const { params: { timerId, timerType } } = data;
      if (timerType === "interval") {
        const idOrFunc = scheduledIntervalFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      } else if (timerType === "timeout") {
        const idOrFunc = scheduledTimeoutFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
          scheduledTimeoutFunctions.delete(timerId);
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      }
    } else if (isClearResponse(data)) {
      const { id: id2 } = data;
      const timerIdAndTimerType = unrespondedRequests.get(id2);
      if (timerIdAndTimerType === void 0) {
        throw new Error("The timer is in an undefined state.");
      }
      const { timerId, timerType } = timerIdAndTimerType;
      unrespondedRequests.delete(id2);
      if (timerType === "interval") {
        scheduledIntervalFunctions.delete(timerId);
      } else {
        scheduledTimeoutFunctions.delete(timerId);
      }
    } else {
      const { error: { message } } = data;
      throw new Error(message);
    }
  });
  const clearInterval2 = /* @__PURE__ */ __name((timerId) => {
    const id2 = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id2, { timerId, timerType: "interval" });
    scheduledIntervalFunctions.set(timerId, id2);
    worker2.postMessage({
      id: id2,
      method: "clear",
      params: { timerId, timerType: "interval" }
    });
  }, "clearInterval2");
  const clearTimeout2 = /* @__PURE__ */ __name((timerId) => {
    const id2 = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id2, { timerId, timerType: "timeout" });
    scheduledTimeoutFunctions.set(timerId, id2);
    worker2.postMessage({
      id: id2,
      method: "clear",
      params: { timerId, timerType: "timeout" }
    });
  }, "clearTimeout2");
  const setInterval2 = /* @__PURE__ */ __name((func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledIntervalFunctions);
    scheduledIntervalFunctions.set(timerId, () => {
      func();
      if (typeof scheduledIntervalFunctions.get(timerId) === "function") {
        worker2.postMessage({
          id: null,
          method: "set",
          params: {
            delay,
            now: performance.now(),
            timerId,
            timerType: "interval"
          }
        });
      }
    });
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "interval"
      }
    });
    return timerId;
  }, "setInterval2");
  const setTimeout2 = /* @__PURE__ */ __name((func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledTimeoutFunctions);
    scheduledTimeoutFunctions.set(timerId, func);
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "timeout"
      }
    });
    return timerId;
  }, "setTimeout2");
  return {
    clearInterval: clearInterval2,
    clearTimeout: clearTimeout2,
    setInterval: setInterval2,
    setTimeout: setTimeout2
  };
}, "load");
var createLoadOrReturnBroker = /* @__PURE__ */ __name((loadBroker, worker2) => {
  let broker = null;
  return () => {
    if (broker !== null) {
      return broker;
    }
    const blob = new Blob([worker2], { type: "application/javascript; charset=utf-8" });
    const url = URL.createObjectURL(blob);
    broker = loadBroker(url);
    setTimeout(() => URL.revokeObjectURL(url));
    return broker;
  };
}, "createLoadOrReturnBroker");
var worker = `(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`;
var loadOrReturnBroker = createLoadOrReturnBroker(load, worker);
var clearInterval$1 = /* @__PURE__ */ __name((timerId) => loadOrReturnBroker().clearInterval(timerId), "clearInterval$1");
var clearTimeout$1 = /* @__PURE__ */ __name((timerId) => loadOrReturnBroker().clearTimeout(timerId), "clearTimeout$1");
var setInterval$1 = /* @__PURE__ */ __name((func, delay) => loadOrReturnBroker().setInterval(func, delay), "setInterval$1");
var setTimeout$1 = /* @__PURE__ */ __name((func, delay) => loadOrReturnBroker().setTimeout(func, delay), "setTimeout$1");
var ud = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clearInterval: clearInterval$1,
  clearTimeout: clearTimeout$1,
  setInterval: setInterval$1,
  setTimeout: setTimeout$1
}, Symbol.toStringTag, { value: "Module" }));
var parser$1 = {};
var grammar$2 = { exports: {} };
var grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  s: [{ name: "name" }],
  i: [{ name: "description" }],
  u: [{ name: "uri" }],
  e: [{ name: "email" }],
  p: [{ name: "phone" }],
  z: [{ name: "timezones" }],
  r: [{ name: "repeats" }],
  t: [{
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }, "format")
    },
    {
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }, "format")
    },
    {
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }, "format")
    },
    {
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: /* @__PURE__ */ __name(function(o) {
        return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
      }, "format")
    },
    {
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }, "format")
    },
    {
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: /* @__PURE__ */ __name(function(o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
        str += o.tcptype != null ? " tcptype %s" : "%v";
        if (o.generation != null) {
          str += " generation %d";
        }
        str += o["network-id"] != null ? " network-id %d" : "%v";
        str += o["network-cost"] != null ? " network-cost %d" : "%v";
        return str;
      }, "format")
    },
    {
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: /* @__PURE__ */ __name(function(o) {
        var str = "ssrc:%d";
        if (o.attribute != null) {
          str += " %s";
          if (o.value != null) {
            str += ":%s";
          }
        }
        return str;
      }, "format")
    },
    {
      push: "ssrcGroups",
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
    },
    {
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }, "format")
    },
    {
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: /* @__PURE__ */ __name(function(o) {
        return o.params ? "rid:%s %s %s" : "rid:%s %s";
      }, "format")
    },
    {
      push: "imageattrs",
      reg: new RegExp(
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: /* @__PURE__ */ __name(function(o) {
        return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
      }, "format")
    },
    {
      name: "simulcast",
      reg: new RegExp(
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: /* @__PURE__ */ __name(function(o) {
        return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
      }, "format")
    },
    {
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: /* @__PURE__ */ __name(function(o) {
        return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
      }, "format")
    },
    {
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: /* @__PURE__ */ __name(function(o) {
        var str = "mediaclk:";
        str += o.id != null ? "id=%s %s" : "%v%s";
        str += o.mediaClockValue != null ? "=%s" : "";
        str += o.rateNumerator != null ? " rate=%s" : "";
        str += o.rateDenominator != null ? "/%s" : "";
        return str;
      }, "format")
    },
    {
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    {
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(key) {
  var objs = grammar$1[key];
  objs.forEach(function(obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
});
(function(exports2) {
  var toIntIfInt = /* @__PURE__ */ __name(function(v) {
    return String(Number(v)) === v ? Number(v) : v;
  }, "toIntIfInt");
  var attachProperties = /* @__PURE__ */ __name(function(match, location, names, rawName) {
    if (rawName && !names) {
      location[rawName] = toIntIfInt(match[1]);
    } else {
      for (var i = 0; i < names.length; i += 1) {
        if (match[i + 1] != null) {
          location[names[i]] = toIntIfInt(match[i + 1]);
        }
      }
    }
  }, "attachProperties");
  var parseReg = /* @__PURE__ */ __name(function(obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if (obj.push && !location[obj.push]) {
      location[obj.push] = [];
    } else if (needsBlank && !location[obj.name]) {
      location[obj.name] = {};
    }
    var keyLocation = obj.push ? {} : needsBlank ? location[obj.name] : location;
    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
    if (obj.push) {
      location[obj.push].push(keyLocation);
    }
  }, "parseReg");
  var grammar2 = grammar$2.exports;
  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  exports2.parse = function(sdp) {
    var session = {}, media = [], location = session;
    sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
      var type = l[0];
      var content = l.slice(2);
      if (type === "m") {
        media.push({ rtp: [], fmtp: [] });
        location = media[media.length - 1];
      }
      for (var j2 = 0; j2 < (grammar2[type] || []).length; j2 += 1) {
        var obj = grammar2[type][j2];
        if (obj.reg.test(content)) {
          return parseReg(obj, location, content);
        }
      }
    });
    session.media = media;
    return session;
  };
  var paramReducer = /* @__PURE__ */ __name(function(acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if (s.length === 2) {
      acc[s[0]] = toIntIfInt(s[1]);
    } else if (s.length === 1 && expr.length > 1) {
      acc[s[0]] = void 0;
    }
    return acc;
  }, "paramReducer");
  exports2.parseParams = function(str) {
    return str.split(/;\s?/).reduce(paramReducer, {});
  };
  exports2.parseFmtpConfig = exports2.parseParams;
  exports2.parsePayloads = function(str) {
    return str.toString().split(" ").map(Number);
  };
  exports2.parseRemoteCandidates = function(str) {
    var candidates = [];
    var parts = str.split(" ").map(toIntIfInt);
    for (var i = 0; i < parts.length; i += 3) {
      candidates.push({
        component: parts[i],
        ip: parts[i + 1],
        port: parts[i + 2]
      });
    }
    return candidates;
  };
  exports2.parseImageAttributes = function(str) {
    return str.split(" ").map(function(item) {
      return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
    });
  };
  exports2.parseSimulcastStreamList = function(str) {
    return str.split(";").map(function(stream) {
      return stream.split(",").map(function(format2) {
        var scid, paused = false;
        if (format2[0] !== "~") {
          scid = toIntIfInt(format2);
        } else {
          scid = toIntIfInt(format2.substring(1, format2.length));
          paused = true;
        }
        return {
          scid,
          paused
        };
      });
    });
  };
})(parser$1);
var grammar = grammar$2.exports;
var formatRegExp = /%[sdv%]/g;
var format = /* @__PURE__ */ __name(function(formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function(x2) {
    if (i >= len) {
      return x2;
    }
    var arg = args[i];
    i += 1;
    switch (x2) {
      case "%%":
        return "%";
      case "%s":
        return String(arg);
      case "%d":
        return Number(arg);
      case "%v":
        return "";
    }
  });
}, "format");
var makeLine = /* @__PURE__ */ __name(function(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + "=" + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      } else {
        args.push(location[obj.names[i]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
}, "makeLine");
var defaultOuterOrder = [
  "v",
  "o",
  "s",
  "i",
  "u",
  "e",
  "p",
  "c",
  "b",
  "t",
  "r",
  "z",
  "a"
];
var defaultInnerOrder = ["i", "c", "b", "a"];
var writer$1 = /* @__PURE__ */ __name(function(session, opts) {
  opts = opts || {};
  if (session.version == null) {
    session.version = 0;
  }
  if (session.name == null) {
    session.name = " ";
  }
  session.media.forEach(function(mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];
  outerOrder.forEach(function(type) {
    grammar[type].forEach(function(obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function(el2) {
          sdp.push(makeLine(type, obj, el2));
        });
      }
    });
  });
  session.media.forEach(function(mLine) {
    sdp.push(makeLine("m", grammar.m[0], mLine));
    innerOrder.forEach(function(type) {
      grammar[type].forEach(function(obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function(el2) {
            sdp.push(makeLine(type, obj, el2));
          });
        }
      });
    });
  });
  return sdp.join("\r\n") + "\r\n";
}, "writer$1");
var parser = parser$1;
var writer = writer$1;
var write = writer;
var parse = parser.parse;
parser.parseParams;
parser.parseFmtpConfig;
parser.parsePayloads;
parser.parseRemoteCandidates;
parser.parseImageAttributes;
parser.parseSimulcastStreamList;
var QS = Object.defineProperty;
var XS = Object.defineProperties;
var ZS = Object.getOwnPropertyDescriptors;
var ed = Object.getOwnPropertySymbols;
var ev = Object.getPrototypeOf;
var Xh = Object.prototype.hasOwnProperty;
var Zh = Object.prototype.propertyIsEnumerable;
var tv = Reflect.get;
var ep = Math.pow;
var iu = /* @__PURE__ */ __name((s, t, e) => t in s ? QS(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e, "iu");
var D = /* @__PURE__ */ __name((s, t) => {
  for (var e in t || (t = {}))
    Xh.call(t, e) && iu(s, e, t[e]);
  if (ed)
    for (var e of ed(t))
      Zh.call(t, e) && iu(s, e, t[e]);
  return s;
}, "D");
var B = /* @__PURE__ */ __name((s, t) => XS(s, ZS(t)), "B");
var ho = /* @__PURE__ */ __name((s, t) => {
  var e = {};
  for (var r in s)
    Xh.call(s, r) && t.indexOf(r) < 0 && (e[r] = s[r]);
  if (s != null && ed)
    for (var r of ed(s))
      t.indexOf(r) < 0 && Zh.call(s, r) && (e[r] = s[r]);
  return e;
}, "ho");
var h = /* @__PURE__ */ __name((s, t, e) => (iu(s, typeof t != "symbol" ? t + "" : t, e), e), "h");
var au = /* @__PURE__ */ __name((s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
}, "au");
var a = /* @__PURE__ */ __name((s, t, e) => (au(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "a");
var g = /* @__PURE__ */ __name((s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, "g");
var m = /* @__PURE__ */ __name((s, t, e, r) => (au(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e), "m");
var L = /* @__PURE__ */ __name((s, t, e) => (au(s, t, "access private method"), e), "L");
var tp = /* @__PURE__ */ __name((s, t, e) => tv(ev(s), e, t), "tp");
var u = /* @__PURE__ */ __name((s, t, e) => new Promise((r, i) => {
  var n = /* @__PURE__ */ __name((d) => {
    try {
      c(e.next(d));
    } catch (l) {
      i(l);
    }
  }, "n"), o = /* @__PURE__ */ __name((d) => {
    try {
      c(e.throw(d));
    } catch (l) {
      i(l);
    }
  }, "o"), c = /* @__PURE__ */ __name((d) => d.done ? r(d.value) : Promise.resolve(d.value).then(n, o), "c");
  c((e = e.apply(s, t)).next());
}), "u");
function rv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
__name(rv, "rv");
Array.prototype.at || Object.assign(Array.prototype, { at: rv });
function iv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
__name(iv, "iv");
String.prototype.at || Object.assign(String.prototype, { at: iv });
var av = /* @__PURE__ */ __name((s) => {
  !navigator.isReactNative && typeof window != "undefined" && (window.addEventListener("error", (t) => {
    var e;
    !((e = t.filename) != null && e.includes("localhost")) && t.lineno !== 0 && s.error(
      "window::error",
      {
        error: t.error
      },
      true
    );
  }), window.addEventListener(
    "unhandledrejection",
    (t) => {
      var e, r, i, n, o, c, d, l;
      s.error(
        "window::unhandledrejection",
        {
          error: t == null ? void 0 : t.reason,
          networkCall: {
            url: (r = (e = t == null ? void 0 : t.reason) == null ? void 0 : e.config) == null ? void 0 : r.url,
            baseURL: (n = (i = t == null ? void 0 : t.reason) == null ? void 0 : i.config) == null ? void 0 : n.baseURL,
            method: (c = (o = t == null ? void 0 : t.reason) == null ? void 0 : o.config) == null ? void 0 : c.method,
            status: (d = t == null ? void 0 : t.reason) == null ? void 0 : d.status,
            statusText: (l = t == null ? void 0 : t.reason) == null ? void 0 : l.statusText
          }
        },
        true
      );
    }
  ), window.addEventListener("offline", () => {
    s.info("window::offline");
  }), window.addEventListener("online", () => {
    s.info("window::online");
  }));
}, "av");
var Vo = "chrome";
var zg = "opera";
var Yg = "firefox";
var Qg = "iexplorer";
var Xg = "safari";
var Zg = "nwjs";
var em = "electron";
var tm = "react-native";
var Sh = "unknown";
var wd = {
  Chrome: Vo,
  Chromium: Vo,
  Opera: zg,
  Firefox: Yg,
  "Internet Explorer": Qg,
  Safari: Xg
};
function nv() {
  const { userAgent: s } = navigator, t = {
    name: Sh,
    version: void 0
  };
  if (s.match(/Chrome/) && !s.match(/Edge/))
    if (s.match(/Edg(A?)/)) {
      const e = s.match(/Chrome\/([\d.]+)/)[1];
      Number.parseInt(e, 10) > 72 && (t.name = Vo, t.version = e);
    } else
      t.name = Vo, t.version = s.match(/Chrome\/([\d.]+)/)[1];
  return t;
}
__name(nv, "nv");
function ov() {
  const { userAgent: s } = navigator;
  if (s.match(/Electron/)) {
    const t = s.match(/Electron\/([\d.]+)/)[1];
    return {
      name: em,
      version: t
    };
  }
  return null;
}
__name(ov, "ov");
function cv() {
  const { userAgent: s } = navigator;
  if (s.match(/JitsiMeetNW/)) {
    const t = s.match(/JitsiMeetNW\/([\d.]+)/)[1];
    return {
      name: Zg,
      version: t
    };
  }
}
__name(cv, "cv");
function dv() {
  const s = "Cloudflare-Workers".match(
    /\b(react[ \t_-]*native)(?:\/(\S+))?/i
  );
  let t;
  if (s || navigator.product === "ReactNative")
    return s && s.length > 2 && (s[1], t = s[2]), t || (t = "unknown"), {
      name: tm,
      version: t
    };
}
__name(dv, "dv");
function lv(s) {
  let t;
  const e = [dv, ov, cv];
  for (let i = 0; i < e.length; i += 1)
    if (t = e[i](), t)
      return t;
  const r = s.getBrowserName();
  return r in wd ? {
    name: wd[r],
    version: s.getBrowserVersion()
  } : (t = nv(), t || {
    name: Sh,
    version: void 0
  });
}
__name(lv, "lv");
var uv = class {
  static {
    __name(this, "uv");
  }
  constructor() {
    h(this, "_bowser");
    h(this, "_name");
    h(this, "_version");
    h(this, "getDeviceInfo", () => ({
      isMobile: this.isMobile(),
      browserName: this._bowser.getBrowserName(),
      osName: this._bowser.getOSName(),
      browserVersion: this._bowser.getBrowserVersion(),
      osVersionName: this._bowser.getOSVersion(),
      engineName: this._bowser.getEngineName()
    }));
  }
  init(t) {
    let e, r;
    if (this._bowser = Bowser.getParser("Cloudflare-Workers"), typeof t == "undefined") {
      const i = lv(this._bowser);
      e = i.name, r = i.version;
    } else
      t.name in wd ? (e = wd[t.name], r = t.version) : (e = Sh, r = void 0);
    this._name = e, this._version = r;
  }
  getName() {
    return this._name;
  }
  isChrome() {
    return this._name === Vo;
  }
  isOpera() {
    return this._name === zg;
  }
  isFirefox() {
    return this._name === Yg;
  }
  isIExplorer() {
    return this._name === Qg;
  }
  isSafari() {
    return this._name === Xg;
  }
  isNWJS() {
    return this._name === Zg;
  }
  isElectron() {
    return this._name === em;
  }
  isReactNative() {
    return this._name === tm || navigator.isReactNative === true;
  }
  getVersion() {
    return this._version;
  }
  isMobile() {
    return this._bowser.getPlatformType() === "mobile";
  }
  _checkCondition(t) {
    if (this._version)
      return this._bowser.satisfies(t);
  }
  isVersionGreaterThan(t) {
    return this._checkCondition({ [this._name]: `>${t}` });
  }
  isVersionLessThan(t) {
    return this._checkCondition({ [this._name]: `<${t}` });
  }
  isVersionEqualTo(t) {
    return this._checkCondition({ [this._name]: `~${t}` });
  }
};
var hv = class extends uv {
  static {
    __name(this, "hv");
  }
  doesVideoMuteByStreamRemove() {
    return this.isChromiumBased() || this.isWebKitBased();
  }
  supportsP2P() {
    return !this.usesUnifiedPlan();
  }
  isChromiumBased() {
    return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera();
  }
  isWebKitBased() {
    return this._bowser.isEngine("webkit") && typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getUserMedia != "undefined" && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1;
  }
  isSupported() {
    return typeof RTCPeerConnection != "undefined";
  }
  isUserInteractionRequiredForUnmute() {
    return this.isFirefox() && this.isVersionLessThan("68");
  }
  supportsVideoMuteOnConnInterrupted() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  supportsBandwidthStatistics() {
    return !this.isFirefox() && !this.isWebKitBased();
  }
  supportsCodecPreferences() {
    return this.usesUnifiedPlan() && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(window.RTCRtpTransceiver.prototype).indexOf(
      "setCodecPreferences"
    ) > -1 && Object.keys(RTCRtpSender.prototype).indexOf("getCapabilities") > -1 && !this.isWebKitBased();
  }
  supportsDeviceChangeEvent() {
    return navigator.mediaDevices && typeof navigator.mediaDevices.ondevicechange != "undefined" && typeof navigator.mediaDevices.addEventListener != "undefined";
  }
  supportsLocalCandidateRttStatistics() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  supportsPerformanceObserver() {
    return typeof window.PerformanceObserver != "undefined" && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1;
  }
  supportsReceiverStats() {
    return typeof window.RTCRtpReceiver != "undefined" && Object.keys(RTCRtpReceiver.prototype).indexOf(
      "getSynchronizationSources"
    ) > -1;
  }
  supportsRTTStatistics() {
    return !this.isFirefox();
  }
  usesPlanB() {
    return !this.usesUnifiedPlan();
  }
  usesSdpMungingForSimulcast() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  usesUnifiedPlan() {
    return !!(this.isFirefox() || this.isWebKitBased());
  }
  usesNewGumFlow() {
    return !!(this.isChromiumBased() || this.isFirefox() || this.isWebKitBased());
  }
  usesAdapter() {
    return this.usesNewGumFlow();
  }
  usesRidsForSimulcast() {
    return false;
  }
  supportsGetDisplayMedia() {
    return typeof navigator.getDisplayMedia != "undefined" || typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getDisplayMedia != "undefined";
  }
  supportsInsertableStreams() {
    if (!(typeof window.RTCRtpSender != "undefined" && (window.RTCRtpSender.prototype.createEncodedStreams || window.RTCRtpSender.prototype.createEncodedVideoStreams)))
      return false;
    const t = new ReadableStream();
    try {
      return window.postMessage(t, "*", [t]), true;
    } catch (e) {
      return false;
    }
  }
  supportsAudioRed() {
    return Boolean(
      window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      ) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      )
    );
  }
  supportsSdpSemantics() {
    return this.isChromiumBased();
  }
  _getChromiumBasedVersion() {
    if (this.isChromiumBased()) {
      if (this.isNWJS())
        return Number.parseInt(process.versions.chromium, 10);
      const t = "Cloudflare-Workers";
      if (t.match(/Chrome/))
        return Number.parseInt(t.match(/Chrome\/([\d.]+)/)[1], 10);
    }
    return -1;
  }
  isIOSMobile() {
    return this.isMobile && this._bowser.getOSName() === "iOS";
  }
};
var Te = new hv();
var ut = {};
var pv = {
  get exports() {
    return ut;
  },
  set exports(s) {
    ut = s;
  }
};
var La = typeof Reflect == "object" ? Reflect : null;
var sp = La && typeof La.apply == "function" ? La.apply : function(t, e, r) {
  return Function.prototype.apply.call(t, e, r);
};
var hd;
La && typeof La.ownKeys == "function" ? hd = La.ownKeys : Object.getOwnPropertySymbols ? hd = /* @__PURE__ */ __name(function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
}, "hd") : hd = /* @__PURE__ */ __name(function(t) {
  return Object.getOwnPropertyNames(t);
}, "hd");
function gv(s) {
  console && console.warn && console.warn(s);
}
__name(gv, "gv");
var sm = Number.isNaN || function(t) {
  return t !== t;
};
function ce() {
  ce.init.call(this);
}
__name(ce, "ce");
pv.exports = ce;
ut.once = vv;
ce.EventEmitter = ce;
ce.prototype._events = void 0;
ce.prototype._eventsCount = 0;
ce.prototype._maxListeners = void 0;
var rp = 10;
function xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
__name(xl, "xl");
Object.defineProperty(ce, "defaultMaxListeners", {
  enumerable: true,
  get: /* @__PURE__ */ __name(function() {
    return rp;
  }, "get"),
  set: /* @__PURE__ */ __name(function(s) {
    if (typeof s != "number" || s < 0 || sm(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    rp = s;
  }, "set")
});
ce.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
ce.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || sm(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function rm(s) {
  return s._maxListeners === void 0 ? ce.defaultMaxListeners : s._maxListeners;
}
__name(rm, "rm");
ce.prototype.getMaxListeners = function() {
  return rm(this);
};
ce.prototype.emit = function(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e.push(arguments[r]);
  var i = t === "error", n = this._events;
  if (n !== void 0)
    i = i && n.error === void 0;
  else if (!i)
    return false;
  if (i) {
    var o;
    if (e.length > 0 && (o = e[0]), o instanceof Error)
      throw o;
    var c = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw c.context = o, c;
  }
  var d = n[t];
  if (d === void 0)
    return false;
  if (typeof d == "function")
    sp(d, this, e);
  else
    for (var l = d.length, p = cm(d, l), r = 0; r < l; ++r)
      sp(p[r], this, e);
  return true;
};
function im(s, t, e, r) {
  var i, n, o;
  if (xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = rm(s), i > 0 && o.length > i && !o.warned) {
    o.warned = true;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, gv(c);
  }
  return s;
}
__name(im, "im");
ce.prototype.addListener = function(t, e) {
  return im(this, t, e, false);
};
ce.prototype.on = ce.prototype.addListener;
ce.prototype.prependListener = function(t, e) {
  return im(this, t, e, true);
};
function mv() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
__name(mv, "mv");
function am(s, t, e) {
  var r = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i = mv.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
__name(am, "am");
ce.prototype.once = function(t, e) {
  return xl(e), this.on(t, am(this, t, e)), this;
};
ce.prototype.prependOnceListener = function(t, e) {
  return xl(e), this.prependListener(t, am(this, t, e)), this;
};
ce.prototype.removeListener = function(t, e) {
  var r, i, n, o, c;
  if (xl(e), i = this._events, i === void 0)
    return this;
  if (r = i[t], r === void 0)
    return this;
  if (r === e || r.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e));
  else if (typeof r != "function") {
    for (n = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === e || r[o].listener === e) {
        c = r[o].listener, n = o;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? r.shift() : fv(r, n), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, c || e);
  }
  return this;
};
ce.prototype.off = ce.prototype.removeListener;
ce.prototype.removeAllListeners = function(t) {
  var e, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var n = Object.keys(r), o;
    for (i = 0; i < n.length; ++i)
      o = n[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = r[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function nm(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? Sv(i) : cm(i, i.length);
}
__name(nm, "nm");
ce.prototype.listeners = function(t) {
  return nm(this, t, true);
};
ce.prototype.rawListeners = function(t) {
  return nm(this, t, false);
};
ce.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : om.call(s, t);
};
ce.prototype.listenerCount = om;
function om(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
__name(om, "om");
ce.prototype.eventNames = function() {
  return this._eventsCount > 0 ? hd(this._events) : [];
};
function cm(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
__name(cm, "cm");
function fv(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
__name(fv, "fv");
function Sv(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
__name(Sv, "Sv");
function vv(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    __name(i, "i");
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    __name(n, "n");
    dm(s, t, n, { once: true }), t !== "error" && yv(s, i, { once: true });
  });
}
__name(vv, "vv");
function yv(s, t, e) {
  typeof s.on == "function" && dm(s, "error", t, e);
}
__name(yv, "yv");
function dm(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, /* @__PURE__ */ __name(function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    }, "i"));
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
__name(dm, "dm");
var z;
(function(s) {
  s[s.MAJOR_EVENT = 0] = "MAJOR_EVENT", s[s.MINOR_EVENT = 1] = "MINOR_EVENT";
})(z || (z = {}));
var O;
(function(s) {
  s.PRECALL_TEST_BEGIN = "precall_begin", s.PRECALL_TEST_COMPLETE = "precall_end", s.CALL_JOIN_BEGIN = "call_join", s.NET_QUALITY_TEST_BEGIN = "net_quality_test_begin", s.NET_QUALITY_TEST_END = "net_quality_test_end", s.WEBSOCKET_CONNECTED = "websocket_connected", s.TRANSPORT_CONNECTED = "transport_connected", s.AUDIO_ON = "audio_on", s.AUDIO_OFF = "audio_off", s.VIDEO_ON = "video_on", s.VIDEO_OFF = "video_off", s.PARTICIPANT_ROLE = "participant_role", s.PING_STAT = "ping_stat", s.DISCONNECT = "disconnect", s.RECONNECT_ATTEMPT = "reconnect_attempt", s.SCREENSHARE_START_REQUESTED = "screenshare_start_requested", s.SCREENSHARE_STARTED = "screenshare_started", s.SCREENSHARE_STOPPED = "screenshare_stopped", s.TAB_CHANGE = "tab_change", s.BROWSER_BACKGROUNDED = "browser_backgrounded", s.BROWSER_FOREGROUNDED = "browser_foregrounded", s.DOMINANT_SPEAKER = "dominant_speaker", s.AUDIO_DEVICES_UPDATES = "audio_devices_updates", s.VIDEO_DEVICES_UPDATES = "video_devices_updates", s.SPEAKER_DEVICES_UPDATES = "speaker_devices_updates", s.SELECTED_MICROHPONE_UPDATE = "selected_microphone_update", s.SELECTED_CAMERA_UPDATE = "selected_camera_update", s.SELECTED_SPEAKER_UPDATE = "selected_speaker_update", s.EXPECTED_VIDEO_RESOLUTION = "expected_video_resolution", s.EXPECTED_SCREENSHARE_RESOLUTION = "expected_screenshare_resolution", s.MEDIA_PERMISSION = "media_permission", s.LEGACY_SWITCH = "legacy_switch", s.AUDIO_PLAY_FAILED = "audio_play_failed", s.VIDEO_PLAY_FAILED = "video_play_failed", s.AUDIO_TRACK_MUTED = "audio_track_muted", s.VIDEO_TRACK_MUTED = "video_track_muted", s.IVS_PLAYER_REBUFFERING = "ivs_player_rebuffering", s.IVS_PLAYER_AUDIO_BLOCKED = "ivs_player_audio_blocked", s.IVS_PLAYER_PLAYBACK_BLOCKED = "ivs_player_playback_blocked", s.IVS_PLAYER_ERROR = "ivs_player_error", s.IVS_PLAYER_RECOVERABLE_ERROR = "ivs_player_recoverable_error", s.IVS_PLAYER_WORKER_ERROR = "ivs_player_worker_error", s.IVS_PLAYER_NETWORK_UNAVAILABLE = "ivs_player_network_unavailable", s.LIVESTREAM_LATENCY = "livestream_latency", s.IVS_PLAYER_ANALYTICS_EVENT = "ivs_player_analytics_event", s.IVS_PLAYER_PLAYBACK_RATE_CHANGED = "ivs_player_playback_rate_changed", s.IVS_PLAYER_QUALITY_CHANGED = "ivs_player_quality_changed", s.IVS_PLAYER_INITIALIZED = "ivs_player_initialized";
})(O || (O = {}));
var Tv = /* @__PURE__ */ new Map([
  [O.PRECALL_TEST_BEGIN, z.MINOR_EVENT],
  [O.PRECALL_TEST_COMPLETE, z.MINOR_EVENT],
  [O.CALL_JOIN_BEGIN, z.MAJOR_EVENT],
  [O.NET_QUALITY_TEST_BEGIN, z.MINOR_EVENT],
  [O.NET_QUALITY_TEST_END, z.MINOR_EVENT],
  [O.WEBSOCKET_CONNECTED, z.MINOR_EVENT],
  [O.TRANSPORT_CONNECTED, z.MAJOR_EVENT],
  [O.AUDIO_ON, z.MINOR_EVENT],
  [O.AUDIO_OFF, z.MINOR_EVENT],
  [O.VIDEO_ON, z.MINOR_EVENT],
  [O.VIDEO_OFF, z.MINOR_EVENT],
  [O.PARTICIPANT_ROLE, z.MINOR_EVENT],
  [O.PING_STAT, z.MAJOR_EVENT],
  [O.DISCONNECT, z.MAJOR_EVENT],
  [O.RECONNECT_ATTEMPT, z.MAJOR_EVENT],
  [O.SCREENSHARE_START_REQUESTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STARTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STOPPED, z.MINOR_EVENT],
  [O.TAB_CHANGE, z.MINOR_EVENT],
  [O.BROWSER_BACKGROUNDED, z.MINOR_EVENT],
  [O.BROWSER_FOREGROUNDED, z.MINOR_EVENT],
  [O.DOMINANT_SPEAKER, z.MINOR_EVENT],
  [O.AUDIO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.VIDEO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SPEAKER_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SELECTED_MICROHPONE_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_CAMERA_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_SPEAKER_UPDATE, z.MINOR_EVENT],
  [O.MEDIA_PERMISSION, z.MINOR_EVENT],
  [O.LEGACY_SWITCH, z.MINOR_EVENT],
  [O.AUDIO_PLAY_FAILED, z.MINOR_EVENT],
  [O.VIDEO_PLAY_FAILED, z.MINOR_EVENT],
  [O.AUDIO_TRACK_MUTED, z.MINOR_EVENT],
  [O.VIDEO_TRACK_MUTED, z.MINOR_EVENT],
  [O.IVS_PLAYER_REBUFFERING, z.MAJOR_EVENT],
  [O.IVS_PLAYER_AUDIO_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_RECOVERABLE_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_WORKER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_NETWORK_UNAVAILABLE, z.MAJOR_EVENT],
  [O.LIVESTREAM_LATENCY, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ANALYTICS_EVENT, z.MINOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_RATE_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_QUALITY_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_INITIALIZED, z.MINOR_EVENT],
  [O.EXPECTED_VIDEO_RESOLUTION, z.MINOR_EVENT],
  [O.EXPECTED_SCREENSHARE_RESOLUTION, z.MINOR_EVENT]
]);
var Ev = class {
  static {
    __name(this, "Ev");
  }
  constructor() {
    h(this, "events");
    this.events = [];
  }
  add(t) {
    this.events.push(t);
  }
  flush() {
    return {
      entries: this.events.splice(0, 25)
    };
  }
};
var _v = class extends ut {
  static {
    __name(this, "_v");
  }
  constructor({ logger: e, peerId: r, apiHostnames: i }) {
    super();
    h(this, "logger");
    h(this, "peerId");
    h(this, "eventStore");
    h(this, "apiEndpoint");
    this.logger = e, this.peerId = r, this.apiEndpoint = `https://${i.daCollector}/api/v1/message`, this.eventStore = new Ev();
  }
  sendEventsChunkToServer(e) {
    return u(this, null, function* () {
      var i;
      const r = {
        payload: e,
        peerId: this.peerId
      };
      try {
        return yield fetch(this.apiEndpoint, {
          method: "POST",
          body: JSON.stringify(r)
        }), true;
      } catch (n) {
        return this.logger.error("callStats::sendEventsChunkToServer::catch", { error: n }), (i = e.entries) == null || i.forEach((o) => {
          this.eventStore.add(o);
        }), false;
      }
    });
  }
  callEvent(e) {
    e.timestamp = /* @__PURE__ */ new Date(), this.eventStore.add(e), this.emit(e.event, e.metaData), Tv.get(e.event) === z.MAJOR_EVENT && this.flush();
  }
  flush() {
    return u(this, null, function* () {
      var r;
      const e = this.eventStore.flush();
      return (r = e == null ? void 0 : e.entries) != null && r.length ? (yield this.sendEventsChunkToServer(e), true) : false;
    });
  }
};
var ip;
(function(s) {
  s.CHROMIUM = "chromum", s.FIREFOX = "firefox", s.SAFARI = "safari";
})(ip || (ip = {}));
var bo = {
  DEVEL: "devel",
  PREPROD: "preprod",
  PROD: "prod"
};
var Jt;
(function(s) {
  s.AUDIO = "AUDIO", s.VIDEO = "VIDEO", s.SPEAKER = "SPEAKER", s.SCREENSHARE = "SCREENSHARE";
})(Jt || (Jt = {}));
var ap;
(function(s) {
  s[s.INIT = 0] = "INIT", s[s.ACCEPTED = 1] = "ACCEPTED", s[s.DENIED = 2] = "DENIED", s[s.SYS_DENIED = 3] = "SYS_DENIED", s[s.FAILED = 4] = "FAILED", s[s.NOTFOUND = 5] = "NOTFOUND", s[s.NOT_APPLICABLE = 6] = "NOT_APPLICABLE";
})(ap || (ap = {}));
function Zr(s) {
  return s ? s.split(".").slice(0, 2).concat(["0", "0"]).join(".") : "";
}
__name(Zr, "Zr");
function bd({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
__name(bd, "bd");
function kd({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
__name(kd, "kd");
var lm = 240;
var um = 720;
var hm = 8;
var pm = 3;
var Ul = 10;
var $l = 0.02;
var Fl = 0.03;
function fr({ stat: s, weight: t, rangeMin: e, rangeMax: r, rangeRankingDirection: i }) {
  return s == null ? t : e === r ? i === "UP" ? s <= e ? t : 0 : s >= r ? t : 0 : i === "UP" ? (1 - Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e)) * t : i === "DOWN" ? Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e) * t : t;
}
__name(fr, "fr");
function gm({ isLowQualityVideo: s, isVideoStuck: t, isVideoLagging: e, jitterQuality: r, packetsLostQuality: i }) {
  const n = 0.8 * ((s ? 0.85 : 1) * (e ? 0.7 : 1) * (t ? 0.5 : 1)) + 0.2 * (r * i);
  return Math.round((n + Number.EPSILON) * 100) / 100;
}
__name(gm, "gm");
function mm({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
__name(mm, "mm");
function fm({ packetsLost: s, packetsSent: t, jitter: e }) {
  const i = fr({
    stat: mm({
      packetsLost: s,
      packetsSent: t
    }),
    weight: 0.7,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), o = fr({
    stat: e,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return i + o;
}
__name(fm, "fm");
function Pv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
__name(Pv, "Pv");
function Cv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
__name(Cv, "Cv");
function Rv({ framesEncoded: s }) {
  return s === 0;
}
__name(Rv, "Rv");
function Sm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsSent: r, jitter: i, isScreenShare: n, framesEncoded: o }) {
  const c = fr({
    stat: mm({
      packetsLost: e,
      packetsSent: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = Pv({
    frameWidth: s,
    isScreenShare: n
  }), p = Cv({
    framesPerSecond: t,
    isScreenShare: n
  }), f = Rv({
    framesEncoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
__name(Sm, "Sm");
function vm({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
__name(vm, "vm");
function ym({ concealmentEvents: s, packetsLost: t, packetsReceived: e, jitter: r }) {
  const n = fr({
    stat: s,
    weight: 0.2,
    rangeMin: 0,
    rangeMax: 3,
    rangeRankingDirection: "UP"
  }), o = 0.5, c = fr({
    stat: vm({
      packetsLost: t,
      packetsReceived: e
    }),
    weight: o,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), l = fr({
    stat: r,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return n + c + l;
}
__name(ym, "ym");
function wv({ framesDecoded: s }) {
  return s === 0;
}
__name(wv, "wv");
function bv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
__name(bv, "bv");
function kv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
__name(kv, "kv");
function Tm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsReceived: r, jitter: i, isScreenShare: n, framesDecoded: o }) {
  const c = fr({
    stat: vm({
      packetsLost: e,
      packetsReceived: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = kv({
    frameWidth: s,
    isScreenShare: n
  }), p = bv({
    framesPerSecond: t,
    isScreenShare: n
  }), f = wv({
    framesDecoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
__name(Tm, "Tm");
var Sr = class _Sr {
  static {
    __name(this, "Sr");
  }
  constructor(t) {
    h(this, "pc1");
    h(this, "pc2");
    h(this, "constrainVideoBitrateKbps");
    h(this, "constrainOfferToRemoveVideoFec", false);
    h(this, "iceCandidateFilter");
    const e = new RTCPeerConnection(t), r = new RTCPeerConnection(t);
    this.pc1 = e, this.pc2 = r, this.iceCandidateFilter = _Sr.noFilter, this.pc1.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc2)), this.pc2.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc1));
  }
  static parseCandidate(t) {
    const e = "candidate:", r = t.indexOf(e) + e.length, i = t.substr(r).split(" ");
    return {
      type: i[7],
      protocol: i[2],
      address: i[4]
    };
  }
  static isNotHostCandidate(t) {
    return t.type !== "host";
  }
  static isHost(t) {
    return t.type === "host";
  }
  static isRelay(t) {
    return t.type === "relay";
  }
  static isReflexive(t) {
    return t.type === "srflx";
  }
  static noFilter(t) {
    return true;
  }
  onIceCandidate(t, e) {
    if (e.candidate) {
      const r = _Sr.parseCandidate(e.candidate.candidate);
      this.iceCandidateFilter(r) && t.addIceCandidate(e.candidate);
    }
  }
  setIceCandidateFilter(t) {
    this.iceCandidateFilter = t;
  }
  constrainVideoBitrate(t) {
    this.constrainVideoBitrateKbps = t;
  }
  disableVideoFec() {
    this.constrainOfferToRemoveVideoFec = true;
  }
  gotOffer(t) {
    this.constrainOfferToRemoveVideoFec && (t.sdp = t.sdp.replace(/(m=video 1 [^\r]+)(116 117)(\r\n)/g, `$1\r
`), t.sdp = t.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=fmtp:98 apt=116\r\n/g, "")), this.pc1.setLocalDescription(t), this.pc2.setRemoteDescription(t), this.pc2.createAnswer().then(this.gotAnswer.bind(this), this.reportFatal.bind(this));
  }
  gotAnswer(t) {
    this.constrainVideoBitrateKbps && (t.sdp = t.sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r
b=AS:${this.constrainVideoBitrateKbps}\r
`)), this.pc2.setLocalDescription(t), this.pc1.setRemoteDescription(t);
  }
  establishConnection() {
    this.pc1.createOffer().then(this.gotOffer.bind(this), this.reportFatal.bind(this));
  }
  reportFatal(t) {
    console.error("Error:", t);
  }
  getRoundTripTime() {
    return u(this, null, function* () {
      const [t, e] = yield Promise.all([this.pc1.getStats(), this.pc2.getStats()]);
      let r, i;
      if (t.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === true && n.bytesSent > 0 && (r = n);
      }), e.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === true && n.bytesReceived > 0 && (i = n);
      }), r && i)
        try {
          if (r.currentRoundTripTime && i.currentRoundTripTime)
            return {
              rtt: r.currentRoundTripTime,
              backendRTT: i.currentRoundTripTime
            };
          const n = (i.lastPacketReceivedTimestamp - r.lastPacketSentTimestamp) / 1e3;
          return {
            rtt: n,
            backendRTT: n
          };
        } catch (n) {
          return;
        }
    });
  }
  close() {
    this.pc1.close(), this.pc2.close();
  }
};
var Em = class extends ut {
  static {
    __name(this, "Em");
  }
  constructor(e) {
    super();
    h(this, "call");
    h(this, "timeOut");
    this.call = new Sr(e);
  }
  start(e = 1e4) {
    this.call.establishConnection(), this.timeOut = setTimeout(this.testFailed.bind(this), e);
  }
  testComplete(e) {
    clearTimeout(this.timeOut), this.call.close(), this.emit("done", e);
  }
  testFailed(e) {
    this.call.close(), this.emit("failed", e);
  }
};
var Iv = 8;
var Av = 1 / 1e3;
var Mv = class extends Em {
  static {
    __name(this, "Mv");
  }
  constructor(e) {
    super(e);
    h(this, "senderChannel");
    h(this, "recieveChannel");
    h(this, "startTime");
    h(this, "lastBitrateMeasureTime");
    h(this, "sentPayloadBytes", 0);
    h(this, "recievedPayloadBytes", 0);
    h(this, "lastReceivedPayloadBytes", 0);
    h(this, "stopSending", false);
    h(this, "testProgress", 0);
    h(this, "samplePacket", "");
    h(this, "finalBitrateSum", 0);
    h(this, "bitRateSampels", 0);
    h(this, "maxNumberOfPacketsToSend", 0);
    h(this, "bytesToKeepBuffered", 0);
    h(this, "testDurationSeconds", 5);
    this.call.setIceCandidateFilter(Sr.isNotHostCandidate), this.senderChannel = this.call.pc1.createDataChannel(null);
    for (let r = 0; r < 1024 * 256; r += 1)
      this.samplePacket += "h";
    this.maxNumberOfPacketsToSend = 1, this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend, this.testDurationSeconds = 4, this.senderChannel.addEventListener("open", this.sendingStep.bind(this)), this.call.pc2.addEventListener("datachannel", this.onRecieverChannel.bind(this));
  }
  sendingStep() {
    const e = /* @__PURE__ */ new Date();
    this.startTime || (this.startTime = e, this.lastBitrateMeasureTime = e);
    for (let i = 0; i !== this.maxNumberOfPacketsToSend && !(this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered); i += 1) {
      this.sentPayloadBytes += this.samplePacket.length;
      try {
        this.senderChannel.send(this.samplePacket);
      } catch (n) {
      }
    }
    const r = e.getTime() - this.startTime.getTime();
    r >= 1e3 * this.testDurationSeconds ? (this.stopSending = true, this.testProgress = 100) : (this.testProgress = r / (10 * this.testDurationSeconds), setTimeout(this.sendingStep.bind(this), 1));
  }
  onMessageRecieved(e) {
    this.recievedPayloadBytes += e.data.length;
    const r = /* @__PURE__ */ new Date(), i = r.getTime() - this.lastBitrateMeasureTime.getTime();
    if (i >= 1e3) {
      const o = (this.recievedPayloadBytes - this.lastReceivedPayloadBytes) * Iv / (i / 1e3);
      this.finalBitrateSum += o, this.bitRateSampels += 1, this.lastReceivedPayloadBytes = this.recievedPayloadBytes, this.lastBitrateMeasureTime = r;
    }
    if (this.stopSending && this.sentPayloadBytes === this.recievedPayloadBytes) {
      const n = this.finalBitrateSum / this.bitRateSampels;
      this.testComplete({
        throughput: Math.round(n * Av)
      });
    }
  }
  testComplete(e) {
    this.call.getRoundTripTime().then(({ rtt: r, backendRTT: i }) => super.testComplete({
      RTT: r,
      backendRTT: i,
      throughput: e.throughput
    }));
  }
  onRecieverChannel(e) {
    this.recieveChannel = e.channel, this.recieveChannel.addEventListener("message", this.onMessageRecieved.bind(this));
  }
};
var vh = class extends Em {
  static {
    __name(this, "vh");
  }
  constructor(e, r = Sr.noFilter) {
    super(e);
    h(this, "ch1");
    h(this, "ch2");
    this.call.setIceCandidateFilter(r);
    const i = this.call.pc1.createDataChannel(null);
    this.ch1 = i, i.addEventListener("open", () => {
      i.send("hello");
    }), i.addEventListener("message", this.onCh1Recieve.bind(this)), this.call.pc2.addEventListener("datachannel", this.dataChannelHandler.bind(this));
  }
  onCh1Recieve(e) {
    e.data !== "world" ? this.hangup("Invalid data transmitted.") : this.testComplete({
      connectivity: true
    });
  }
  onCh2Recieve(e) {
    if (e.data !== "hello")
      this.hangup("Invalid data transmitted.");
    else
      try {
        this.ch2.send("world");
      } catch (r) {
      }
  }
  dataChannelHandler(e) {
    const r = e.channel;
    this.ch2 = r, r.addEventListener("message", this.onCh2Recieve.bind(this));
  }
  hangup(e) {
    this.testFailed(e);
  }
};
var Dv = class extends vh {
  static {
    __name(this, "Dv");
  }
  constructor(t) {
    super(t, Sr.isHost);
  }
};
var Ov = class extends vh {
  static {
    __name(this, "Ov");
  }
  constructor(t) {
    super(t, Sr.isRelay);
  }
};
var Nv = class extends vh {
  static {
    __name(this, "Nv");
  }
  constructor(t) {
    super(t, Sr.isReflexive);
  }
};
var Vv = class {
  static {
    __name(this, "Vv");
  }
  constructor() {
    h(this, "ipInformation", null);
  }
  getIPDetails(i) {
    return u(this, arguments, function* ({ peerId: t, apiHostnames: e, logger: r }) {
      var n, o, c;
      if (!this.ipInformation) {
        try {
          const d = `https://${e.location}`, p = yield (yield fetch(d)).json();
          if (((n = p.loc) == null ? void 0 : n.length) > 5)
            return this.ipInformation = p, (o = this.ipInformation) != null && o.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip)), p;
          throw Error("Insufficient data");
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using location service", { error: d });
        }
        try {
          const d = yield fetch(`https://${e.locationLegacy}/?token=3c493932b0624c&peerId=${t}`, {
            method: "POST"
          });
          this.ipInformation = yield d.json(), (c = this.ipInformation) != null && c.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip));
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using legacy location service", { error: d });
        }
      }
      return this.ipInformation;
    });
  }
  resetCache() {
    this.ipInformation = null;
  }
};
var yh = new Vv();
var np = [
  {
    urls: "turn:turn.dyte.in:443?transport=tcp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  },
  {
    urls: "turn:turn.dyte.in:3478?transport=udp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  }
];
function op(s) {
  const [t, e] = s.split(",");
  return {
    coords: {
      latitude: Number(t),
      longitude: Number(e)
    }
  };
}
__name(op, "op");
var _m = class {
  static {
    __name(this, "_m");
  }
  constructor() {
    h(this, "transport");
    h(this, "candidatePair");
    h(this, "outboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "inboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "outboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "inboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "remoteInboundRtp", /* @__PURE__ */ new Map());
    h(this, "producerStreamMap", /* @__PURE__ */ new Map());
    h(this, "consumerStreamMap", /* @__PURE__ */ new Map());
    h(this, "staleProducerStreamMap", false);
    h(this, "staleConsumerStreamMap", false);
  }
};
var Pm = class extends ut {
  static {
    __name(this, "Pm");
  }
  constructor() {
    super();
    h(this, "observer");
    h(this, "outboundProducerMap", /* @__PURE__ */ new Map());
    h(this, "inboundConsumerMap", /* @__PURE__ */ new Map());
    h(this, "consumerPeerIdMap", /* @__PURE__ */ new Map());
    h(this, "pausedConsumerMap", /* @__PURE__ */ new Map());
    h(this, "pausedProducerMap", /* @__PURE__ */ new Map());
    h(this, "overallProducingTransportsStatsMap", {});
    h(this, "overallConsumingTransportsStatsMap", {});
    h(this, "overallConsumersStatsMap", {});
    h(this, "overallProducersStatsMap", {});
    h(this, "videoProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "videoConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "consumerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "consumerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "freezedProducingTransportIds", /* @__PURE__ */ new Set());
    h(this, "freezedConsumingTransportIds", /* @__PURE__ */ new Set());
    h(this, "screenShareProducers", /* @__PURE__ */ new Set());
    h(this, "screenShareConsumers", /* @__PURE__ */ new Set());
    h(this, "ipDetails");
    h(this, "callStatsInstance");
    this.observer = new ut();
  }
  registerProducer(e) {
    return u(this, null, function* () {
      yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
    });
  }
  pauseProducer(e) {
    this.pausedProducerMap.set(e, {
      lastReportCalculated: false
    });
  }
  resumeProducer(e) {
    this.pausedProducerMap.delete(e);
  }
  processInboundConsumerVideoStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalVideoPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "pause", e))) : (r.totalVideoPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedVideo.has(e) && (this.consumerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "resume", e))));
  }
  processInboundConsumerAudioStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalAudioPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "pause", e))) : (r.totalAudioPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedAudio.has(e) && (this.consumerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "resume", e))));
  }
  processOutboundProducerVideoStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalVideoPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "pause", e))) : (r.totalVideoPacketsSent = i.packetsSent, this.producerIdsWithFreezedVideo.has(e) && (this.producerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "resume", e))));
  }
  processOutboundProducerAudioStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalAudioPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "pause", e))) : (r.totalAudioPacketsSent = i.packetsSent, this.producerIdsWithFreezedAudio.has(e) && (this.producerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "resume", e))));
  }
  processProducingTransportStats(e, r, i) {
    var p;
    const n = ((p = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : p.currentUserMediaStates) || {}, { audio: o, video: c, screen: d } = n, l = o || c || d;
    r.totalPacketsSent === i.packetsSent ? (this.freezedProducingTransportIds.add(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "pause", e))) : (r.totalPacketsSent = i.packetsSent, this.freezedProducingTransportIds.has(e) && (this.freezedProducingTransportIds.delete(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "resume", e))));
  }
  processConsumingTransportStats(e, r, i) {
    var c, d;
    const o = !!Array.from(((d = (c = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : c.consumerSharedMediaStatesMap) == null ? void 0 : d.values()) || []).reduce((l, p) => l || p.audio || p.video || p.screen, false);
    r.totalPacketsReceived === i.packetsSent ? (this.freezedConsumingTransportIds.add(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "pause", e))) : (r.totalPacketsReceived = i.packetsSent, this.freezedConsumingTransportIds.has(e) && (this.freezedConsumingTransportIds.delete(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "resume", e))));
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
    });
  }
  pauseConsumer(e) {
    this.pausedConsumerMap.set(e, {
      lastReportCalculated: false
    });
  }
  resumeConsumer(e) {
    this.pausedConsumerMap.delete(e);
  }
  generateProducerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getProducerStatsFromReport(this.parseRTCReport(i, ["outbound-rtp", "remote-inbound-rtp"], false, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "outbound-rtp": {
            this.outboundProducerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  generateConsumerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getConsumerStatsFromReport(this.parseRTCReport(i, ["inbound-rtp"], false, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  deregisterProducer(e) {
    this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  getWorkingSimulcastVideoStats(e) {
    return e.find((i) => {
      const n = i.framesEncoded > 0, o = i.packetsSent > 0, c = i.frameWidth && i.frameHeight;
      return n && o && !!c;
    }) || e[e.length - 1];
  }
  parseRTCReport(e, r = [], i = false, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === true || I.selected === true) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            dtlsState: y.dtlsState,
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: true
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = true;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped,
                framesPerSecond: b.framesPerSecond,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                totalEncodeTime: b.targetBitrate,
                totalPacketSendDelay: b.totalPacketSendDelay,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: true
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = true;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped,
                framesPerSecond: V.framesPerSecond,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateProducerStreamMap(i, true));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  getConsumersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateConsumerStreamMap(i, true));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  getTransportReport(e) {
    return u(this, null, function* () {
      return e.getStats();
    });
  }
  getProcessedStats(e, r, i) {
    return u(this, null, function* () {
      const n = yield this.getTransportReport(e), o = { producing: i, consuming: r, id: e.id }, c = n, d = this.parseRTCReport(c, ["transport", "candidate-pair", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "local-candidate", "remote-candidate"], false, void 0, o);
      if (!d)
        return;
      const l = {
        stats: d.transport,
        transportId: e.id,
        consuming: r,
        producing: i
      }, p = d.staleProducerStreamMap ? void 0 : this.getProducerStatsFromReport(d), f = d.staleConsumerStreamMap ? void 0 : this.getConsumerStatsFromReport(d);
      return {
        transportReport: l,
        producerReport: p,
        consumerReport: f
      };
    });
  }
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        var o, c;
        r.push({
          producerId: n,
          videoStats: i.outboundVideoRtpId.map((d) => e.outboundVideoRtp.get(d)),
          audioStats: i.outboundAudioRtpId.map((d) => e.outboundAudioRtp.get(d)),
          appData: ((c = (o = this.callStatsInstance.producers) == null ? void 0 : o.get(n)) == null ? void 0 : c.appData) || null
        });
      });
    } catch (i) {
      this.callStatsInstance.logger.error("callStats::measurements::getProducerStatsFromReport", {
        error: { reason: i.reason, message: i.message }
      });
    }
    return r;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(n);
        r.push({
          consumerId: n,
          peerId: o,
          producerId: c,
          appData: d,
          videoStats: i.inboundVideoRtpId.map((l) => e.inboundVideoRtp.get(l)),
          audioStats: i.inboundAudioRtpId.map((l) => e.inboundAudioRtp.get(l))
        });
      });
    } catch (i) {
      console.error("getConsumersReport: ", i, e);
    }
    return r;
  }
  getUserLocation() {
    return u(this, null, function* () {
      return new Promise((e, r) => {
        try {
          navigator.geolocation ? navigator.geolocation.getCurrentPosition((i) => {
            e(i);
          }) : r();
        } catch (i) {
          r(i);
        }
      });
    });
  }
  getConnectivity(e) {
    return u(this, null, function* () {
      try {
        const r = {
          iceServers: e || np
        }, i = new Promise((p, f) => {
          try {
            const S = new Dv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), n = new Promise((p, f) => {
          try {
            const S = new Ov(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), o = new Promise((p, f) => {
          try {
            const S = new Nv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), [c, d, l] = yield Promise.all([i, n, o]);
        return {
          host: c == null ? void 0 : c.connectivity,
          relay: d == null ? void 0 : d.connectivity,
          reflexive: l == null ? void 0 : l.connectivity
        };
      } catch (r) {
        return {
          host: false,
          relay: false,
          reflexive: false
        };
      }
    });
  }
  getThroughput(e) {
    return u(this, null, function* () {
      try {
        const i = yield new Promise((n, o) => {
          try {
            const c = {
              iceServers: e || np
            }, d = new Mv(c);
            d.addListener("done", n), d.addListener("failed", o), d.start(1e4);
          } catch (c) {
            o(c);
          }
        });
        return {
          throughput: i.throughput,
          fractionalLoss: 0,
          RTT: i.RTT,
          jitter: 0,
          backendRTT: i.backendRTT
        };
      } catch (r) {
        return;
      }
    });
  }
  getIPDetails() {
    return u(this, null, function* () {
      var e, r;
      try {
        return this.ipDetails || (this.ipDetails = yield yh.getIPDetails({
          peerId: (e = this.callStatsInstance) == null ? void 0 : e.peerId,
          apiHostnames: (r = this.callStatsInstance) == null ? void 0 : r.apiHostnames,
          logger: this.callStatsInstance.logger
        })), this.ipDetails;
      } catch (i) {
        return;
      }
    });
  }
  getNetworkQuality(e) {
    return u(this, null, function* () {
      const [r, i] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e)
      ]);
      return {
        connectivity: r,
        throughput: i == null ? void 0 : i.throughput,
        fractionalLoss: i == null ? void 0 : i.fractionalLoss,
        RTT: i == null ? void 0 : i.RTT,
        jitter: i == null ? void 0 : i.jitter,
        backendRTT: i == null ? void 0 : i.backendRTT
      };
    });
  }
  getNetworkInfo(e, r = false) {
    return u(this, null, function* () {
      var c, d;
      if (r) {
        const l = yield this.getIPDetails();
        return {
          ipDetails: l,
          effectiveNetworkType: (c = navigator.connection) == null ? void 0 : c.effectiveType,
          location: l != null && l.loc ? op(l == null ? void 0 : l.loc) : void 0
        };
      }
      const [i, n, o] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e),
        this.getIPDetails()
      ]);
      return {
        ipDetails: o,
        effectiveNetworkType: (d = navigator.connection) == null ? void 0 : d.effectiveType,
        location: o != null && o.loc ? op(o == null ? void 0 : o.loc) : void 0,
        turnConnectivity: i ? i.host || i.relay || i.reflexive : false,
        connectivity: i,
        throughput: n == null ? void 0 : n.throughput,
        fractionalLoss: n == null ? void 0 : n.fractionalLoss,
        RTT: n == null ? void 0 : n.RTT,
        jitter: n == null ? void 0 : n.jitter,
        backendRTT: n == null ? void 0 : n.backendRTT
      };
    });
  }
};
var Lv = class extends Pm {
  static {
    __name(this, "Lv");
  }
};
var Cm = class extends Pm {
  static {
    __name(this, "Cm");
  }
  constructor() {
    super(...arguments);
    h(this, "producerMap", /* @__PURE__ */ new Map());
    h(this, "consumerMap", /* @__PURE__ */ new Map());
  }
  registerProducer(e) {
    return u(this, null, function* () {
      this.producerMap.set(e.id, e), yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
    });
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      this.consumerMap.set(e.id, e), yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
    });
  }
  generateConsumerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = this.parseRTCReport(i, ["inbound-rtp"], false, e.id), o = [...n.consumerStreamMap.values()][0], c = r ? this.getConsumerStatsFromParsedConsumerStats(n, o, e.id) : void 0;
      for (const d of i.values())
        switch (d.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(d.id, e.id);
            break;
          }
        }
      return c;
    });
  }
  deregisterProducer(e) {
    this.producerMap.delete(e.id), this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.consumerMap.delete(e.id), this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  parseRTCReport(e, r = [], i = false, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === true || I.selected === true) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            dtlsState: y.dtlsState,
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: true
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = true;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped ? b.framesDropped : b.droppedFrames,
                framesPerSecond: b.framesPerSecond ? b.framesPerSecond : b.framerateMean,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                totalEncodeTime: b.totalEncodeTime,
                totalPacketSendDelay: b.totalEncodeTime,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: true
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = true;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped ? V.framesDropped : V.droppedFrames,
                framesPerSecond: V.framesPerSecond ? V.framesPerSecond : V.framerateMean,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.bytesReceived = d.candidatePair.bytesReceived, d.transport.bytesSent = d.candidatePair.bytesSent, d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        const o = this.producerMap.get(n), c = o.track.getSettings(), d = i.outboundVideoRtpId.map((p) => {
          const f = e.outboundVideoRtp.get(p);
          return f.frameHeight || (f.frameHeight = c.height, f.frameWidth = c.width, f.framesPerSecond = c.frameRate), f;
        }), l = {
          producerId: n,
          appData: o.appData,
          videoStats: d,
          audioStats: i.outboundAudioRtpId.map((p) => e.outboundAudioRtp.get(p))
        };
        r.push(l);
      });
    } catch (i) {
      console.error("getProducersReport: ", i, e);
    }
    return r;
  }
  getConsumerStatsFromParsedConsumerStats(e, r, i) {
    let n;
    try {
      const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(i), l = r == null ? void 0 : r.inboundVideoRtpId.map((p) => {
        const S = this.consumerMap.get(i).track.getSettings(), T = e.inboundVideoRtp.get(p);
        return T.frameHeight || (T.frameHeight = S.height, T.frameWidth = S.width, T.framesPerSecond = S.frameRate), T;
      });
      n = {
        consumerId: i,
        peerId: o,
        producerId: c,
        appData: d,
        videoStats: l,
        audioStats: r == null ? void 0 : r.inboundAudioRtpId.map((p) => e.inboundAudioRtp.get(p))
      };
    } catch (o) {
      console.error("getConsumerStatsFromParsedConsumerStats: ", o, e);
    }
    return n;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        r.push(this.getConsumerStatsFromParsedConsumerStats(e, i, n));
      });
    } catch (i) {
      console.error("getConsumerStatsFromReport: ", i, e);
    }
    return r;
  }
};
var xv = class extends Cm {
  static {
    __name(this, "xv");
  }
};
function Id(s, t, e, r) {
  if (s != null && s.logger && s.logger.error("Callstats::handleError", { error: r }), typeof e == "function" && r instanceof t)
    e.call(null, r, s);
  else
    throw r;
}
__name(Id, "Id");
function cp(s, t, e) {
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        Id(this, t, e, o);
      }) : n;
    } catch (n) {
      Id(this, t, e, n);
    }
    return null;
  }, s;
}
__name(cp, "cp");
var Z = /* @__PURE__ */ __name((s, t) => (e, r, i) => {
  const n = i.value;
  return i.value = function(...o) {
    try {
      const c = n.apply(this, o);
      return c && c instanceof Promise ? c.catch((d) => {
        Id(this, s, t, d);
      }) : c;
    } catch (c) {
      Id(this, s, t, c);
    }
    return null;
  }, i;
}, "Z");
var Uv = /* @__PURE__ */ __name((s, t) => (e, r, i) => {
  if (i)
    return cp(i, s, t);
  for (const n of Reflect.ownKeys(e.prototype).filter((o) => o !== "constructor")) {
    const o = Object.getOwnPropertyDescriptor(e.prototype, n);
    o.value instanceof Function && Object.defineProperty(e.prototype, n, cp(o, s, t));
  }
}, "Uv");
var Y = globalThis && globalThis.__decorate || function(s, t, e, r) {
  var i = arguments.length, n = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(s, t, e, r);
  else
    for (var c = s.length - 1; c >= 0; c--)
      (o = s[c]) && (n = (i < 3 ? o(n) : i > 3 ? o(t, e, n) : o(t, e)) || n);
  return i > 3 && n && Object.defineProperty(t, e, n), n;
};
var Q = console;
var J = class extends ut {
  static {
    __name(this, "J");
  }
  constructor(e = "https://api.testingv3.dyte.in", r = "Blink", i = bo.PROD, n, o, c, d) {
    super();
    h(this, "observer");
    h(this, "eventHandler");
    h(this, "measurements");
    h(this, "producingTransport");
    h(this, "consumingTransport");
    h(this, "producers", /* @__PURE__ */ new Map());
    h(this, "consumers", /* @__PURE__ */ new Map());
    h(this, "iceServers");
    h(this, "connectionInfoPromise");
    h(this, "pingStatsTimeout");
    h(this, "logger");
    h(this, "env");
    h(this, "apiHostnames");
    h(this, "peerId");
    h(this, "consumerSharedMediaStatesMap", /* @__PURE__ */ new Map());
    h(this, "currentUserMediaStates", {});
    switch (this.env = i, this.apiHostnames = d, this.logger = o, this.peerId = c, this.eventHandler = new _v({ logger: o, peerId: c, apiHostnames: d }), this.logger.debug("callStats::engineName: ", { engineName: r }), r) {
      case "Blink":
        this.measurements = new Lv();
        break;
      case "Gecko":
        this.measurements = new Cm();
        break;
      case "WebKit":
        this.measurements = new xv();
        break;
      default:
        throw Error(`Unknown engineName! ${r}`);
    }
    this.measurements.callStatsInstance = this, this.registerProducer = this.registerProducer.bind(this), this.registerConsumer = this.registerConsumer.bind(this), this.observer = new ut(), this.measurements.observer.on("consumer_score", (l) => {
      o.debug(`callStats::consumer_score ${[...l.entries()]}`), this.eventHandler.emit("consumer_score", l);
    }), this.measurements.observer.on("producer_score", (l) => {
      o.debug(`callStats::producer_score ${[...l.entries()]}`), this.eventHandler.emit("producer_score", l);
    });
  }
  registerIceServers(e) {
    this.iceServers = e;
  }
  registerConsumer(e) {
    var r;
    this.consumerSharedMediaStatesMap.has(e.id) || this.consumerSharedMediaStatesMap.set(e.id, {}), this.consumers.set(e.id, e), this.measurements.registerConsumer(e), this.logger.debug("callStats::registerConsumer", { consumerId: e.id, consumerkind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterConsumer.bind(this, e));
  }
  registerProducer(e) {
    var r;
    this.producers.set(e.id, e), this.measurements.registerProducer(e), this.logger.debug("callStats::registerProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterProducer.bind(this, e));
  }
  sendConsumerSharedMediaStateEvent(e, r) {
    this.consumerSharedMediaStatesMap.has(e) || this.consumerSharedMediaStatesMap.set(e, {});
    const i = this.consumerSharedMediaStatesMap.get(e);
    this.consumerSharedMediaStatesMap.set(e, Object.assign(i, r));
  }
  registerProducingTransport(e) {
    var i;
    this.producingTransport = e, e.on("close", this.disconnectProducingTransport.bind(this, e)), e.on("disconnect", this.disconnectProducingTransport.bind(this, e)), Array.from(
      ((i = e._producers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerProducer(n);
    }), e.on("newproducer", this.registerProducer);
  }
  registerConsumingTransport(e) {
    var i;
    this.consumingTransport = e, e.on("close", this.disconnectConsumingTransport.bind(this, e)), e.on("disconnect", this.disconnectConsumingTransport.bind(this, e)), Array.from(
      ((i = e._consumers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerConsumer(n);
    }), e.on("newconsumer", this.registerConsumer);
  }
  deRegisterConsumer(e) {
    this.consumers.delete(e.id);
  }
  deRegisterProducer(e) {
    var r;
    this.producers.delete(e.id), this.logger.debug("callStats::deRegisterProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) });
  }
  disconnectConsumingTransport() {
    this.consumingTransport = void 0;
  }
  disconnectProducingTransport() {
    this.producingTransport = void 0;
  }
  callEvent(e) {
    this.eventHandler.callEvent(e);
  }
  sendPreCallTestBeginEvent(e = false, r) {
    this.connectionInfoPromise = this.measurements.getNetworkInfo(this.iceServers, e), this.eventHandler.callEvent({
      event: O.PRECALL_TEST_BEGIN,
      timestamp: r
    }), this.connectionInfoPromise && this.connectionInfoPromise.then((i) => {
      this.eventHandler.callEvent({
        event: O.PRECALL_TEST_COMPLETE,
        metaData: {
          connectionInfo: i
        },
        timestamp: r
      });
    });
  }
  sendScreenShareToggleEvent(e, r = null, i) {
    this.currentUserMediaStates.screen = e, this.eventHandler.callEvent({
      event: e ? O.SCREENSHARE_STARTED : O.SCREENSHARE_STOPPED,
      metaData: {
        ssrc: r
      },
      timestamp: i
    });
  }
  sendScreenShareRequestedEvent(e) {
    this.eventHandler.callEvent({
      event: O.SCREENSHARE_START_REQUESTED,
      timestamp: e
    });
  }
  sendActiveSpeakerEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.DOMINANT_SPEAKER,
      metaData: {
        peerId: e
      },
      timestamp: r
    });
  }
  devices(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_DEVICES_UPDATES || e === Jt.VIDEO && O.VIDEO_DEVICES_UPDATES || e === Jt.SPEAKER && O.SPEAKER_DEVICES_UPDATES,
      metaData: {
        deviceList: r
      },
      timestamp: i
    });
  }
  selectedDevice(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.SELECTED_MICROHPONE_UPDATE || e === Jt.VIDEO && O.SELECTED_CAMERA_UPDATE || e === Jt.SPEAKER && O.SELECTED_SPEAKER_UPDATE,
      metaData: {
        device: r
      },
      timestamp: i
    });
  }
  mediaPermission(e, r, i) {
    this.eventHandler.callEvent({
      event: O.MEDIA_PERMISSION,
      metaData: {
        deviceType: e,
        permission: r
      },
      timestamp: i
    });
  }
  mediaPlaybackFailed(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_PLAY_FAILED || e === Jt.VIDEO && O.VIDEO_PLAY_FAILED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  mediaTrackMuted(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_TRACK_MUTED || e === Jt.VIDEO && O.VIDEO_TRACK_MUTED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  tabChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.TAB_CHANGE,
      metaData: { isMeetingsTabActive: e },
      timestamp: r
    });
  }
  browserBackgrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_BACKGROUNDED,
      timestamp: e
    });
  }
  browserForegrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_FOREGROUNDED,
      timestamp: e
    });
  }
  legacySwitch(e, r) {
    this.eventHandler.callEvent({
      event: O.LEGACY_SWITCH,
      metadata: { on: e },
      timestamp: r
    });
  }
  getPreCallTestResults() {
    return u(this, null, function* () {
      return this.connectionInfoPromise;
    });
  }
  sendCallJoinBeginEvent(e, r) {
    e = B(D({}, e), {
      meetingEnv: this.env
    }), e.deviceInfo = B(D({}, e.deviceInfo), {
      userAgent: "Cloudflare-Workers",
      cpus: navigator.hardwareConcurrency,
      memory: navigator.deviceMemory
    }), this.eventHandler.callEvent({
      event: O.CALL_JOIN_BEGIN,
      metaData: {
        peerMetaData: e
      },
      timestamp: r
    });
  }
  sendNetworkQualityTestBeginEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.NET_QUALITY_TEST_BEGIN,
      timestamp: r
    }), new Promise((n, o) => u(this, null, function* () {
      const c = [];
      try {
        for (const d of e)
          try {
            if (d.iceServers && d.iceServers.length > 0) {
              const l = yield this.measurements.getNetworkQuality(d.iceServers);
              c.push(B(D({}, d), {
                networkResults: l
              }));
            }
          } catch (l) {
            console.warn("Error handling ", l);
          }
        n({
          regionData: c
        });
      } catch (d) {
        console.warn("Error in callstats, ", d), o(d);
      }
    })).then((n) => {
      this.eventHandler.callEvent({
        event: O.NET_QUALITY_TEST_END,
        timestamp: r,
        metaData: n
      });
    });
  }
  sendWebSocketConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.WEBSOCKET_CONNECTED,
      timestamp: e
    });
  }
  sendTransportConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.TRANSPORT_CONNECTED,
      timestamp: e
    });
  }
  sendAudioToggleEvent(e, r) {
    this.currentUserMediaStates.audio = e;
    let i;
    e ? i = O.AUDIO_ON : i = O.AUDIO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendVideoToggleEvent(e, r) {
    this.currentUserMediaStates.video = e;
    let i;
    e ? i = O.VIDEO_ON : i = O.VIDEO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendParticipantRoleToggleEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.PARTICIPANT_ROLE,
      timestamp: r,
      metaData: e
    });
  }
  startPingStats(e = 7e3) {
    this.sendPingStatsEvent(false, /* @__PURE__ */ new Date()), this.pingStatsTimeout = setInterval(this.sendPingStatsEvent.bind(this), e);
  }
  stopPingStats() {
    clearInterval(this.pingStatsTimeout);
  }
  sendPingStatsEvent(e = true, r) {
    return u(this, null, function* () {
      let i, n;
      if (this.producingTransport && (i = yield this.measurements.getProcessedStats(this.producingTransport, false, true), !i || !(i != null && i.producerReport))) {
        this.logger.debug("callStats::sendPingStatsEvent::staleProducingTransport", { disclaimer: "Stale producer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getProducersReport([...this.producers.values()]);
        i && c ? i.producerReport = c : (i = yield this.measurements.getProcessedStats(this.producingTransport, false, true), (!i || !(i != null && i.producerReport)) && this.logger.debug("callStats::sendPingStatsEvent::noProducingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      if (this.consumingTransport && (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), !n || !n.consumerReport)) {
        this.logger.debug("callStats::sendPingStatsEvent::staleConsumingTransport", { disclaimer: "Stale consumer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getConsumersReport([...this.consumers.values()]);
        n && c ? n.consumerReport = c : (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), (!n || !n.consumerReport) && this.logger.debug("callStats::sendPingStatsEvent::noConsumingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      const o = {
        producingTransportStats: i ? i == null ? void 0 : i.transportReport : void 0,
        consumingTransportStats: n ? n == null ? void 0 : n.transportReport : void 0,
        producerStats: [].concat((i == null ? void 0 : i.producerReport) || []).concat((n == null ? void 0 : n.producerReport) || []),
        consumerStats: [].concat((n == null ? void 0 : n.consumerReport) || []).concat((i == null ? void 0 : i.consumerReport) || [])
      };
      if (e && o.producerStats.length === 0 && o.consumerStats.length === 0) {
        yield this.eventHandler.flush();
        return;
      }
      this.eventHandler.callEvent({
        event: O.PING_STAT,
        metaData: o,
        timestamp: r
      });
    });
  }
  sendIVSPlayerRebufferEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_REBUFFERING,
      timestamp: e
    });
  }
  sendIVSPlayerAudioBlockEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_AUDIO_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerPlaybackBlockedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerNetworkUnavailableEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_NETWORK_UNAVAILABLE,
      timestamp: e
    });
  }
  sendIVSPlayerInitializedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_INITIALIZED,
      timestamp: e
    });
  }
  sendIVSPlayerWorkerErrorEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_WORKER_ERROR,
      timestamp: e
    });
  }
  sendIVSPlayerErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerRecoverableErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_RECOVERABLE_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerAnalyticsEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ANALYTICS_EVENT,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerPlaybackRateChangedEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_RATE_CHANGED,
      timestamp: r,
      metaData: {
        updatedPlaybackRate: e
      }
    });
  }
  sendIVSPlayerQualityChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_QUALITY_CHANGED,
      timestamp: r,
      metaData: e
    });
  }
  sendPlayerLiveLatency(e, r) {
    this.eventHandler.callEvent({
      event: O.LIVESTREAM_LATENCY,
      timestamp: r,
      metaData: {
        latency: e
      }
    });
  }
  sendDisconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.DISCONNECT,
      timestamp: e
    });
  }
  sendReconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.RECONNECT_ATTEMPT,
      timestamp: e
    });
  }
  expectedVideoResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_VIDEO_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
  expectedScreenshareResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_SCREENSHARE_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
};
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerIceServers", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendConsumerSharedMediaStateEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPreCallTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareRequestedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendActiveSpeakerEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "devices", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "selectedDevice", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPermission", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPlaybackFailed", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaTrackMuted", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "tabChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserBackgrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserForegrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "legacySwitch", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "getPreCallTestResults", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendCallJoinBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendNetworkQualityTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendWebSocketConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendTransportConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendAudioToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendVideoToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendParticipantRoleToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "startPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "stopPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPingStatsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRebufferEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAudioBlockEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackBlockedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerNetworkUnavailableEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerInitializedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerWorkerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRecoverableErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAnalyticsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackRateChangedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerQualityChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPlayerLiveLatency", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendDisconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendReconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedVideoResolution", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedScreenshareResolution", null);
J = Y([
  Uv(TypeError, (s, t) => Q.error(t, s))
], J);
var $v = J;
var Rm = class extends ut {
  static {
    __name(this, "Rm");
  }
  constructor() {
    super(...arguments);
    h(this, "stats");
    h(this, "peerId");
    h(this, "backend");
    h(this, "iceServers");
    h(this, "initialized", false);
    h(this, "stalled", false);
    h(this, "ipInformation");
    h(this, "logger");
  }
  initialize(f) {
    return u(this, arguments, function* ({ peerId: e, engineName: r, env: i = bo.PROD, iceServers: n, apiBase: o = "https://api.cluster.dyte.in", flags: c, logger: d = console, apiHostnames: l, skipConnectivityChecks: p = false }) {
      var S, T, _;
      try {
        this.peerId = e, this.logger = d, this.ipInformation = yield yh.getIPDetails({ peerId: e, apiHostnames: l, logger: d }), this.backend = new $v(o, r, i, c, d, e, l), this.iceServers = n, (S = this.backend) == null || S.registerIceServers(this.iceServers), this.initialized = true, (_ = (T = this.backend) == null ? void 0 : T.eventHandler) == null || _.emit("initialized", this.ipInformation), this.emit("initialized", this.ipInformation), this.startPreCallTest(p);
      } catch (P) {
        this.logger.error("callStats::CallStatsIntegration: ", { error: P }), this.stallCallStats();
      }
    });
  }
  configureSendTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerProducingTransport(e);
    });
  }
  configureRecvTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerConsumingTransport(e);
    });
  }
  candidateRegionalNetworkQualityTest(e) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i;
        try {
          (i = this.backend) == null || i.sendNetworkQualityTestBeginEvent(e, r);
        } catch (n) {
          this.logger.error("callStats::sendNetworkQualityTestBeginEvent", { error: { reason: n.reason } });
        }
      });
    });
  }
  roomJoined(e) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i, n;
        (i = this.backend) == null || i.sendCallJoinBeginEvent(e, r), this.backend, (n = this.backend) == null || n.startPingStats();
      });
    });
  }
  audioOff() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(false, e);
    });
  }
  audioOn() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(true, e);
    });
  }
  videoOff() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(false, e);
    });
  }
  videoOn() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(true, e);
    });
  }
  callEnded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r, i;
      (r = this.backend) == null || r.stopPingStats(), (i = this.backend) == null || i.sendDisconnectEvent(e);
    });
  }
  screenShareStart(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(true, e, r);
    });
  }
  consumerSharedMediaState(e, r) {
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendConsumerSharedMediaStateEvent(e, r);
    });
  }
  screenShareStop(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(false, e, r);
    });
  }
  screenShareRequested() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendScreenShareRequestedEvent(e);
    });
  }
  activeSpeaker(e) {
    if (e !== this.peerId)
      return;
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendActiveSpeakerEvent(e, r);
    });
  }
  devices(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.devices(e, r, i);
    });
  }
  selectedDevice(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.selectedDevice(e, r, i);
    });
  }
  mediaPermission(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.mediaPermission(e, r, i);
    });
  }
  mediaPlaybackFailed(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaPlaybackFailed(e, r);
    });
  }
  mediaTrackMuted(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaTrackMuted(e, r);
    });
  }
  tabChanged(e = false) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.tabChanged(e, r);
    });
  }
  browserBackgrounded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserBackgrounded(e);
    });
  }
  browserForegrounded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserForegrounded(e);
    });
  }
  legacySwitch(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.legacySwitch(e, r);
    });
  }
  startPreCallTest(e = false) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i;
        (i = this.backend) == null || i.sendPreCallTestBeginEvent(e, r);
      });
    });
  }
  onPreCallTestResults(e) {
    return this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.once("precall_end", e);
    }), e;
  }
  onReceivingConsumerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_audio_status", e);
    });
  }
  onReceivingConsumerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_video_status", e);
    });
  }
  onReceivingProducerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_audio_status", e);
    });
  }
  onReceivingProducerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_video_status", e);
    });
  }
  onReceivingProducingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producing_transport_status", e);
    });
  }
  onReceivingConsumingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consuming_transport_status", e);
    });
  }
  onProducerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_score", e);
    });
  }
  onConsumerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_score", e);
    });
  }
  onSafeInitialization(e) {
    if (this.initialized)
      e(this.ipInformation, false);
    else if (!this.stalled) {
      const r = /* @__PURE__ */ __name((i) => {
        e(i, true);
      }, "r");
      return this.once("initialized", r), r;
    }
    return () => {
    };
  }
  removeInitializationListener(e) {
    this.removeListener("initialized", e);
  }
  stallCallStats() {
    this.stalled = true, this.removeAllListeners("initialized");
  }
  ivsPlayerEvent(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n, o, c, d, l, p, f, S, T, _, P;
      switch (e) {
        case "PlayerRebuffering":
          (n = this.backend) == null || n.sendIVSPlayerRebufferEvent(i);
          break;
        case "PlayerAudioBlocked":
          (o = this.backend) == null || o.sendIVSPlayerAudioBlockEvent(i);
          break;
        case "PlayerPlaybackBlocked":
          (c = this.backend) == null || c.sendIVSPlayerPlaybackBlockedEvent(i);
          break;
        case "PlayerNetworkUnavailable":
          (d = this.backend) == null || d.sendIVSPlayerNetworkUnavailableEvent(i);
          break;
        case "PlayerInitialized":
          (l = this.backend) == null || l.sendIVSPlayerInitializedEvent(i);
          break;
        case "PlayerWorkerError":
          (p = this.backend) == null || p.sendIVSPlayerWorkerErrorEvent(i);
          break;
        case "PlayerError":
          (f = this.backend) == null || f.sendIVSPlayerErrorEvent(r, i);
          break;
        case "PlayerRecoverableError":
          (S = this.backend) == null || S.sendIVSPlayerRecoverableErrorEvent(r, i);
          break;
        case "PlayerAnalyticsEvent":
          (T = this.backend) == null || T.sendIVSPlayerAnalyticsEvent(r, i);
          break;
        case "PlayerPlaybackRateChanged":
          (_ = this.backend) == null || _.sendIVSPlayerPlaybackRateChangedEvent(r, i);
          break;
        case "PlayerQualityChanged":
          (P = this.backend) == null || P.sendIVSPlayerQualityChanged(r, i);
          break;
      }
    });
  }
  livestreamLatency(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendPlayerLiveLatency(e, r);
    });
  }
  expectedVideoResolution(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedVideoResolution(e, r, i);
    });
  }
  expectedScreenshareResolution(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedScreenshareResolution(e, r, i);
    });
  }
};
var Fv = new Rm();
Fv.setMaxListeners(30);
function Hv() {
  this.__data__ = [], this.size = 0;
}
__name(Hv, "Hv");
function qc(s, t) {
  return s === t || s !== s && t !== t;
}
__name(qc, "qc");
function Hl(s, t) {
  for (var e = s.length; e--; )
    if (qc(s[e][0], t))
      return e;
  return -1;
}
__name(Hl, "Hl");
var Bv = Array.prototype;
var qv = Bv.splice;
function jv(s) {
  var t = this.__data__, e = Hl(t, s);
  if (e < 0)
    return false;
  var r = t.length - 1;
  return e == r ? t.pop() : qv.call(t, e, 1), --this.size, true;
}
__name(jv, "jv");
function Gv(s) {
  var t = this.__data__, e = Hl(t, s);
  return e < 0 ? void 0 : t[e][1];
}
__name(Gv, "Gv");
function Wv(s) {
  return Hl(this.__data__, s) > -1;
}
__name(Wv, "Wv");
function Jv(s, t) {
  var e = this.__data__, r = Hl(e, s);
  return r < 0 ? (++this.size, e.push([s, t])) : e[r][1] = t, this;
}
__name(Jv, "Jv");
function Tr(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
__name(Tr, "Tr");
Tr.prototype.clear = Hv;
Tr.prototype.delete = jv;
Tr.prototype.get = Gv;
Tr.prototype.has = Wv;
Tr.prototype.set = Jv;
function Kv() {
  this.__data__ = new Tr(), this.size = 0;
}
__name(Kv, "Kv");
function zv(s) {
  var t = this.__data__, e = t.delete(s);
  return this.size = t.size, e;
}
__name(zv, "zv");
function Yv(s) {
  return this.__data__.get(s);
}
__name(Yv, "Yv");
function Qv(s) {
  return this.__data__.has(s);
}
__name(Qv, "Qv");
var Xv = typeof global == "object" && global && global.Object === Object && global;
var wm = Xv;
var Zv = typeof self == "object" && self && self.Object === Object && self;
var ey = wm || Zv || Function("return this")();
var Cs = ey;
var ty = Cs.Symbol;
var ti = ty;
var bm = Object.prototype;
var sy = bm.hasOwnProperty;
var ry = bm.toString;
var go = ti ? ti.toStringTag : void 0;
function iy(s) {
  var t = sy.call(s, go), e = s[go];
  try {
    s[go] = void 0;
    var r = true;
  } catch (n) {
  }
  var i = ry.call(s);
  return r && (t ? s[go] = e : delete s[go]), i;
}
__name(iy, "iy");
var ay = Object.prototype;
var ny = ay.toString;
function oy(s) {
  return ny.call(s);
}
__name(oy, "oy");
var cy = "[object Null]";
var dy = "[object Undefined]";
var dp = ti ? ti.toStringTag : void 0;
function ma(s) {
  return s == null ? s === void 0 ? dy : cy : dp && dp in Object(s) ? iy(s) : oy(s);
}
__name(ma, "ma");
function Ps(s) {
  var t = typeof s;
  return s != null && (t == "object" || t == "function");
}
__name(Ps, "Ps");
var ly = "[object AsyncFunction]";
var uy = "[object Function]";
var hy = "[object GeneratorFunction]";
var py = "[object Proxy]";
function Th(s) {
  if (!Ps(s))
    return false;
  var t = ma(s);
  return t == uy || t == hy || t == ly || t == py;
}
__name(Th, "Th");
var gy = Cs["__core-js_shared__"];
var nu = gy;
var lp = function() {
  var s = /[^.]+$/.exec(nu && nu.keys && nu.keys.IE_PROTO || "");
  return s ? "Symbol(src)_1." + s : "";
}();
function my(s) {
  return !!lp && lp in s;
}
__name(my, "my");
var fy = Function.prototype;
var Sy = fy.toString;
function fa(s) {
  if (s != null) {
    try {
      return Sy.call(s);
    } catch (t) {
    }
    try {
      return s + "";
    } catch (t) {
    }
  }
  return "";
}
__name(fa, "fa");
var vy = /[\\^$.*+?()[\]{}|]/g;
var yy = /^\[object .+?Constructor\]$/;
var Ty = Function.prototype;
var Ey = Object.prototype;
var _y = Ty.toString;
var Py = Ey.hasOwnProperty;
var Cy = RegExp(
  "^" + _y.call(Py).replace(vy, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ry(s) {
  if (!Ps(s) || my(s))
    return false;
  var t = Th(s) ? Cy : yy;
  return t.test(fa(s));
}
__name(Ry, "Ry");
function wy(s, t) {
  return s == null ? void 0 : s[t];
}
__name(wy, "wy");
function Sa(s, t) {
  var e = wy(s, t);
  return Ry(e) ? e : void 0;
}
__name(Sa, "Sa");
var by = Sa(Cs, "Map");
var Lo = by;
var ky = Sa(Object, "create");
var xo = ky;
function Iy() {
  this.__data__ = xo ? xo(null) : {}, this.size = 0;
}
__name(Iy, "Iy");
function Ay(s) {
  var t = this.has(s) && delete this.__data__[s];
  return this.size -= t ? 1 : 0, t;
}
__name(Ay, "Ay");
var My = "__lodash_hash_undefined__";
var Dy = Object.prototype;
var Oy = Dy.hasOwnProperty;
function Ny(s) {
  var t = this.__data__;
  if (xo) {
    var e = t[s];
    return e === My ? void 0 : e;
  }
  return Oy.call(t, s) ? t[s] : void 0;
}
__name(Ny, "Ny");
var Vy = Object.prototype;
var Ly = Vy.hasOwnProperty;
function xy(s) {
  var t = this.__data__;
  return xo ? t[s] !== void 0 : Ly.call(t, s);
}
__name(xy, "xy");
var Uy = "__lodash_hash_undefined__";
function $y(s, t) {
  var e = this.__data__;
  return this.size += this.has(s) ? 0 : 1, e[s] = xo && t === void 0 ? Uy : t, this;
}
__name($y, "$y");
function ha(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
__name(ha, "ha");
ha.prototype.clear = Iy;
ha.prototype.delete = Ay;
ha.prototype.get = Ny;
ha.prototype.has = xy;
ha.prototype.set = $y;
function Fy() {
  this.size = 0, this.__data__ = {
    hash: new ha(),
    map: new (Lo || Tr)(),
    string: new ha()
  };
}
__name(Fy, "Fy");
function Hy(s) {
  var t = typeof s;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? s !== "__proto__" : s === null;
}
__name(Hy, "Hy");
function Bl(s, t) {
  var e = s.__data__;
  return Hy(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
__name(Bl, "Bl");
function By(s) {
  var t = Bl(this, s).delete(s);
  return this.size -= t ? 1 : 0, t;
}
__name(By, "By");
function qy(s) {
  return Bl(this, s).get(s);
}
__name(qy, "qy");
function jy(s) {
  return Bl(this, s).has(s);
}
__name(jy, "jy");
function Gy(s, t) {
  var e = Bl(this, s), r = e.size;
  return e.set(s, t), this.size += e.size == r ? 0 : 1, this;
}
__name(Gy, "Gy");
function va(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
__name(va, "va");
va.prototype.clear = Fy;
va.prototype.delete = By;
va.prototype.get = qy;
va.prototype.has = jy;
va.prototype.set = Gy;
var Wy = 200;
function Jy(s, t) {
  var e = this.__data__;
  if (e instanceof Tr) {
    var r = e.__data__;
    if (!Lo || r.length < Wy - 1)
      return r.push([s, t]), this.size = ++e.size, this;
    e = this.__data__ = new va(r);
  }
  return e.set(s, t), this.size = e.size, this;
}
__name(Jy, "Jy");
function Us(s) {
  var t = this.__data__ = new Tr(s);
  this.size = t.size;
}
__name(Us, "Us");
Us.prototype.clear = Kv;
Us.prototype.delete = zv;
Us.prototype.get = Yv;
Us.prototype.has = Qv;
Us.prototype.set = Jy;
function Ky(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r && t(s[e], e, s) !== false; )
    ;
  return s;
}
__name(Ky, "Ky");
var zy = function() {
  try {
    var s = Sa(Object, "defineProperty");
    return s({}, "", {}), s;
  } catch (t) {
  }
}();
var Ad = zy;
function Eh(s, t, e) {
  t == "__proto__" && Ad ? Ad(s, t, {
    configurable: true,
    enumerable: true,
    value: e,
    writable: true
  }) : s[t] = e;
}
__name(Eh, "Eh");
var Yy = Object.prototype;
var Qy = Yy.hasOwnProperty;
function km(s, t, e) {
  var r = s[t];
  (!(Qy.call(s, t) && qc(r, e)) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
__name(km, "km");
function jc(s, t, e, r) {
  var i = !e;
  e || (e = {});
  for (var n = -1, o = t.length; ++n < o; ) {
    var c = t[n], d = r ? r(e[c], s[c], c, e, s) : void 0;
    d === void 0 && (d = s[c]), i ? Eh(e, c, d) : km(e, c, d);
  }
  return e;
}
__name(jc, "jc");
function Xy(s, t) {
  for (var e = -1, r = Array(s); ++e < s; )
    r[e] = t(e);
  return r;
}
__name(Xy, "Xy");
function $s(s) {
  return s != null && typeof s == "object";
}
__name($s, "$s");
var Zy = "[object Arguments]";
function up(s) {
  return $s(s) && ma(s) == Zy;
}
__name(up, "up");
var Im = Object.prototype;
var eT = Im.hasOwnProperty;
var tT = Im.propertyIsEnumerable;
var sT = up(/* @__PURE__ */ function() {
  return arguments;
}()) ? up : function(s) {
  return $s(s) && eT.call(s, "callee") && !tT.call(s, "callee");
};
var Md = sT;
var rT = Array.isArray;
var si = rT;
function iT() {
  return false;
}
__name(iT, "iT");
var Am = typeof exports == "object" && exports && !exports.nodeType && exports;
var hp = Am && typeof module == "object" && module && !module.nodeType && module;
var aT = hp && hp.exports === Am;
var pp = aT ? Cs.Buffer : void 0;
var nT = pp ? pp.isBuffer : void 0;
var oT = nT || iT;
var Bn = oT;
var cT = 9007199254740991;
var dT = /^(?:0|[1-9]\d*)$/;
function Mm(s, t) {
  var e = typeof s;
  return t = t == null ? cT : t, !!t && (e == "number" || e != "symbol" && dT.test(s)) && s > -1 && s % 1 == 0 && s < t;
}
__name(Mm, "Mm");
var lT = 9007199254740991;
function Dm(s) {
  return typeof s == "number" && s > -1 && s % 1 == 0 && s <= lT;
}
__name(Dm, "Dm");
var uT = "[object Arguments]";
var hT = "[object Array]";
var pT = "[object Boolean]";
var gT = "[object Date]";
var mT = "[object Error]";
var fT = "[object Function]";
var ST = "[object Map]";
var vT = "[object Number]";
var yT = "[object Object]";
var TT = "[object RegExp]";
var ET = "[object Set]";
var _T = "[object String]";
var PT = "[object WeakMap]";
var CT = "[object ArrayBuffer]";
var RT = "[object DataView]";
var wT = "[object Float32Array]";
var bT = "[object Float64Array]";
var kT = "[object Int8Array]";
var IT = "[object Int16Array]";
var AT = "[object Int32Array]";
var MT = "[object Uint8Array]";
var DT = "[object Uint8ClampedArray]";
var OT = "[object Uint16Array]";
var NT = "[object Uint32Array]";
var ye = {};
ye[wT] = ye[bT] = ye[kT] = ye[IT] = ye[AT] = ye[MT] = ye[DT] = ye[OT] = ye[NT] = true;
ye[uT] = ye[hT] = ye[CT] = ye[pT] = ye[RT] = ye[gT] = ye[mT] = ye[fT] = ye[ST] = ye[vT] = ye[yT] = ye[TT] = ye[ET] = ye[_T] = ye[PT] = false;
function VT(s) {
  return $s(s) && Dm(s.length) && !!ye[ma(s)];
}
__name(VT, "VT");
function _h(s) {
  return function(t) {
    return s(t);
  };
}
__name(_h, "_h");
var Om = typeof exports == "object" && exports && !exports.nodeType && exports;
var ko = Om && typeof module == "object" && module && !module.nodeType && module;
var LT = ko && ko.exports === Om;
var ou = LT && wm.process;
var xT = function() {
  try {
    var s = ko && ko.require && ko.require("util").types;
    return s || ou && ou.binding && ou.binding("util");
  } catch (t) {
  }
}();
var qn = xT;
var gp = qn && qn.isTypedArray;
var UT = gp ? _h(gp) : VT;
var ql = UT;
var $T = Object.prototype;
var FT = $T.hasOwnProperty;
function Nm(s, t) {
  var e = si(s), r = !e && Md(s), i = !e && !r && Bn(s), n = !e && !r && !i && ql(s), o = e || r || i || n, c = o ? Xy(s.length, String) : [], d = c.length;
  for (var l in s)
    (t || FT.call(s, l)) && !(o && (l == "length" || i && (l == "offset" || l == "parent") || n && (l == "buffer" || l == "byteLength" || l == "byteOffset") || Mm(l, d))) && c.push(l);
  return c;
}
__name(Nm, "Nm");
var HT = Object.prototype;
function jl(s) {
  var t = s && s.constructor, e = typeof t == "function" && t.prototype || HT;
  return s === e;
}
__name(jl, "jl");
function Vm(s, t) {
  return function(e) {
    return s(t(e));
  };
}
__name(Vm, "Vm");
var BT = Vm(Object.keys, Object);
var qT = BT;
var jT = Object.prototype;
var GT = jT.hasOwnProperty;
function Lm(s) {
  if (!jl(s))
    return qT(s);
  var t = [];
  for (var e in Object(s))
    GT.call(s, e) && e != "constructor" && t.push(e);
  return t;
}
__name(Lm, "Lm");
function Gc(s) {
  return s != null && Dm(s.length) && !Th(s);
}
__name(Gc, "Gc");
function Ph(s) {
  return Gc(s) ? Nm(s) : Lm(s);
}
__name(Ph, "Ph");
function WT(s, t) {
  return s && jc(t, Ph(t), s);
}
__name(WT, "WT");
function JT(s) {
  var t = [];
  if (s != null)
    for (var e in Object(s))
      t.push(e);
  return t;
}
__name(JT, "JT");
var KT = Object.prototype;
var zT = KT.hasOwnProperty;
function YT(s) {
  if (!Ps(s))
    return JT(s);
  var t = jl(s), e = [];
  for (var r in s)
    r == "constructor" && (t || !zT.call(s, r)) || e.push(r);
  return e;
}
__name(YT, "YT");
function Wc(s) {
  return Gc(s) ? Nm(s, true) : YT(s);
}
__name(Wc, "Wc");
function QT(s, t) {
  return s && jc(t, Wc(t), s);
}
__name(QT, "QT");
var xm = typeof exports == "object" && exports && !exports.nodeType && exports;
var mp = xm && typeof module == "object" && module && !module.nodeType && module;
var XT = mp && mp.exports === xm;
var fp = XT ? Cs.Buffer : void 0;
var Sp = fp ? fp.allocUnsafe : void 0;
function Um(s, t) {
  if (t)
    return s.slice();
  var e = s.length, r = Sp ? Sp(e) : new s.constructor(e);
  return s.copy(r), r;
}
__name(Um, "Um");
function $m(s, t) {
  var e = -1, r = s.length;
  for (t || (t = Array(r)); ++e < r; )
    t[e] = s[e];
  return t;
}
__name($m, "$m");
function ZT(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length, i = 0, n = []; ++e < r; ) {
    var o = s[e];
    t(o, e, s) && (n[i++] = o);
  }
  return n;
}
__name(ZT, "ZT");
function Fm() {
  return [];
}
__name(Fm, "Fm");
var eE = Object.prototype;
var tE = eE.propertyIsEnumerable;
var vp = Object.getOwnPropertySymbols;
var sE = vp ? function(s) {
  return s == null ? [] : (s = Object(s), ZT(vp(s), function(t) {
    return tE.call(s, t);
  }));
} : Fm;
var Ch = sE;
function rE(s, t) {
  return jc(s, Ch(s), t);
}
__name(rE, "rE");
function Hm(s, t) {
  for (var e = -1, r = t.length, i = s.length; ++e < r; )
    s[i + e] = t[e];
  return s;
}
__name(Hm, "Hm");
var iE = Vm(Object.getPrototypeOf, Object);
var Rh = iE;
var aE = Object.getOwnPropertySymbols;
var nE = aE ? function(s) {
  for (var t = []; s; )
    Hm(t, Ch(s)), s = Rh(s);
  return t;
} : Fm;
var Bm = nE;
function oE(s, t) {
  return jc(s, Bm(s), t);
}
__name(oE, "oE");
function qm(s, t, e) {
  var r = t(s);
  return si(s) ? r : Hm(r, e(s));
}
__name(qm, "qm");
function Eu(s) {
  return qm(s, Ph, Ch);
}
__name(Eu, "Eu");
function cE(s) {
  return qm(s, Wc, Bm);
}
__name(cE, "cE");
var dE = Sa(Cs, "DataView");
var _u = dE;
var lE = Sa(Cs, "Promise");
var Pu = lE;
var uE = Sa(Cs, "Set");
var Cu = uE;
var hE = Sa(Cs, "WeakMap");
var Ru = hE;
var yp = "[object Map]";
var pE = "[object Object]";
var Tp = "[object Promise]";
var Ep = "[object Set]";
var _p = "[object WeakMap]";
var Pp = "[object DataView]";
var gE = fa(_u);
var mE = fa(Lo);
var fE = fa(Pu);
var SE = fa(Cu);
var vE = fa(Ru);
var oi = ma;
(_u && oi(new _u(new ArrayBuffer(1))) != Pp || Lo && oi(new Lo()) != yp || Pu && oi(Pu.resolve()) != Tp || Cu && oi(new Cu()) != Ep || Ru && oi(new Ru()) != _p) && (oi = /* @__PURE__ */ __name(function(s) {
  var t = ma(s), e = t == pE ? s.constructor : void 0, r = e ? fa(e) : "";
  if (r)
    switch (r) {
      case gE:
        return Pp;
      case mE:
        return yp;
      case fE:
        return Tp;
      case SE:
        return Ep;
      case vE:
        return _p;
    }
  return t;
}, "oi"));
var jn = oi;
var yE = Object.prototype;
var TE = yE.hasOwnProperty;
function EE(s) {
  var t = s.length, e = new s.constructor(t);
  return t && typeof s[0] == "string" && TE.call(s, "index") && (e.index = s.index, e.input = s.input), e;
}
__name(EE, "EE");
var _E = Cs.Uint8Array;
var Dd = _E;
function wh(s) {
  var t = new s.constructor(s.byteLength);
  return new Dd(t).set(new Dd(s)), t;
}
__name(wh, "wh");
function PE(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.byteLength);
}
__name(PE, "PE");
var CE = /\w*$/;
function RE(s) {
  var t = new s.constructor(s.source, CE.exec(s));
  return t.lastIndex = s.lastIndex, t;
}
__name(RE, "RE");
var Cp = ti ? ti.prototype : void 0;
var Rp = Cp ? Cp.valueOf : void 0;
function wE(s) {
  return Rp ? Object(Rp.call(s)) : {};
}
__name(wE, "wE");
function jm(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.length);
}
__name(jm, "jm");
var bE = "[object Boolean]";
var kE = "[object Date]";
var IE = "[object Map]";
var AE = "[object Number]";
var ME = "[object RegExp]";
var DE = "[object Set]";
var OE = "[object String]";
var NE = "[object Symbol]";
var VE = "[object ArrayBuffer]";
var LE = "[object DataView]";
var xE = "[object Float32Array]";
var UE = "[object Float64Array]";
var $E = "[object Int8Array]";
var FE = "[object Int16Array]";
var HE = "[object Int32Array]";
var BE = "[object Uint8Array]";
var qE = "[object Uint8ClampedArray]";
var jE = "[object Uint16Array]";
var GE = "[object Uint32Array]";
function WE(s, t, e) {
  var r = s.constructor;
  switch (t) {
    case VE:
      return wh(s);
    case bE:
    case kE:
      return new r(+s);
    case LE:
      return PE(s, e);
    case xE:
    case UE:
    case $E:
    case FE:
    case HE:
    case BE:
    case qE:
    case jE:
    case GE:
      return jm(s, e);
    case IE:
      return new r();
    case AE:
    case OE:
      return new r(s);
    case ME:
      return RE(s);
    case DE:
      return new r();
    case NE:
      return wE(s);
  }
}
__name(WE, "WE");
var wp = Object.create;
var JE = /* @__PURE__ */ function() {
  function s() {
  }
  __name(s, "s");
  return function(t) {
    if (!Ps(t))
      return {};
    if (wp)
      return wp(t);
    s.prototype = t;
    var e = new s();
    return s.prototype = void 0, e;
  };
}();
var KE = JE;
function Gm(s) {
  return typeof s.constructor == "function" && !jl(s) ? KE(Rh(s)) : {};
}
__name(Gm, "Gm");
var zE = "[object Map]";
function YE(s) {
  return $s(s) && jn(s) == zE;
}
__name(YE, "YE");
var bp = qn && qn.isMap;
var QE = bp ? _h(bp) : YE;
var XE = QE;
var ZE = "[object Set]";
function e_(s) {
  return $s(s) && jn(s) == ZE;
}
__name(e_, "e_");
var kp = qn && qn.isSet;
var t_ = kp ? _h(kp) : e_;
var s_ = t_;
var r_ = 1;
var i_ = 2;
var a_ = 4;
var Wm = "[object Arguments]";
var n_ = "[object Array]";
var o_ = "[object Boolean]";
var c_ = "[object Date]";
var d_ = "[object Error]";
var Jm = "[object Function]";
var l_ = "[object GeneratorFunction]";
var u_ = "[object Map]";
var h_ = "[object Number]";
var Km = "[object Object]";
var p_ = "[object RegExp]";
var g_ = "[object Set]";
var m_ = "[object String]";
var f_ = "[object Symbol]";
var S_ = "[object WeakMap]";
var v_ = "[object ArrayBuffer]";
var y_ = "[object DataView]";
var T_ = "[object Float32Array]";
var E_ = "[object Float64Array]";
var __ = "[object Int8Array]";
var P_ = "[object Int16Array]";
var C_ = "[object Int32Array]";
var R_ = "[object Uint8Array]";
var w_ = "[object Uint8ClampedArray]";
var b_ = "[object Uint16Array]";
var k_ = "[object Uint32Array]";
var fe = {};
fe[Wm] = fe[n_] = fe[v_] = fe[y_] = fe[o_] = fe[c_] = fe[T_] = fe[E_] = fe[__] = fe[P_] = fe[C_] = fe[u_] = fe[h_] = fe[Km] = fe[p_] = fe[g_] = fe[m_] = fe[f_] = fe[R_] = fe[w_] = fe[b_] = fe[k_] = true;
fe[d_] = fe[Jm] = fe[S_] = false;
function pd(s, t, e, r, i, n) {
  var o, c = t & r_, d = t & i_, l = t & a_;
  if (e && (o = i ? e(s, r, i, n) : e(s)), o !== void 0)
    return o;
  if (!Ps(s))
    return s;
  var p = si(s);
  if (p) {
    if (o = EE(s), !c)
      return $m(s, o);
  } else {
    var f = jn(s), S = f == Jm || f == l_;
    if (Bn(s))
      return Um(s, c);
    if (f == Km || f == Wm || S && !i) {
      if (o = d || S ? {} : Gm(s), !c)
        return d ? oE(s, QT(o, s)) : rE(s, WT(o, s));
    } else {
      if (!fe[f])
        return i ? s : {};
      o = WE(s, f, c);
    }
  }
  n || (n = new Us());
  var T = n.get(s);
  if (T)
    return T;
  n.set(s, o), s_(s) ? s.forEach(function(w) {
    o.add(pd(w, t, e, w, s, n));
  }) : XE(s) && s.forEach(function(w, A) {
    o.set(A, pd(w, t, e, A, s, n));
  });
  var _ = l ? d ? cE : Eu : d ? Wc : Ph, P = p ? void 0 : _(s);
  return Ky(P || s, function(w, A) {
    P && (A = w, w = s[A]), km(o, A, pd(w, t, e, A, s, n));
  }), o;
}
__name(pd, "pd");
var I_ = 1;
var A_ = 4;
function bh(s) {
  return pd(s, I_ | A_);
}
__name(bh, "bh");
var M_ = "[object Symbol]";
function D_(s) {
  return typeof s == "symbol" || $s(s) && ma(s) == M_;
}
__name(D_, "D_");
var O_ = Object.defineProperty;
var N_ = /* @__PURE__ */ __name((s, t) => {
  for (var e in t)
    O_(s, e, { get: t[e], enumerable: true });
}, "N_");
var V_ = {};
N_(V_, {
  permissions: /* @__PURE__ */ __name(() => L_, "permissions"),
  theme: /* @__PURE__ */ __name(() => x_, "theme")
});
var Mt = /* @__PURE__ */ ((s) => (s.GroupCall = "GROUP_CALL", s.Webinar = "WEBINAR", s.AudioRoom = "AUDIO_ROOM", s.Livestream = "LIVESTREAM", s.Chat = "CHAT", s))(Mt || {});
var j = /* @__PURE__ */ ((s) => (s.Allowed = "ALLOWED", s.NotAllowed = "NOT_ALLOWED", s.CanRequest = "CAN_REQUEST", s))(j || {});
var L_ = {
  view_type: "GROUP_CALL",
  accept_waiting_requests: false,
  accept_present_requests: false,
  request_produce: false,
  can_allow_participant_audio: false,
  can_allow_participant_screensharing: false,
  can_allow_participant_video: false,
  can_spotlight: false,
  request_kick_participant: false,
  kick_participant: false,
  pin_participant: false,
  can_edit_display_name: false,
  can_record: false,
  can_livestream: false,
  can_present: true,
  waiting_room_type: "SKIP_ON_ACCEPT",
  recorder_type: "NONE",
  plugins: {
    can_close: true,
    can_start: true
  },
  polls: {
    can_create: true,
    can_vote: true,
    can_view: true
  },
  produce: {
    video: {
      allow: true,
      quality: "vga",
      frame_rate: 24
    },
    audio: true,
    screenshare: {
      allow: true,
      quality: "hd",
      frame_rate: 5
    }
  },
  chat: {
    public: {
      can_send: true,
      text: true,
      files: true
    },
    private: {
      can_send: false,
      can_receive: false,
      text: false,
      files: false
    }
  },
  connected_meetings: {
    can_alter_connected_meetings: false,
    can_switch_connected_meetings: false,
    can_switch_to_parent_meeting: false
  },
  reactions: false,
  hidden_participant: false,
  is_recorder: false,
  show_participant_list: true,
  can_change_participant_role: false,
  can_change_theme: false,
  max_screenshare_count: 1
};
var x_ = {
  setup_screen: {
    is_enabled: true
  },
  alone_here: {
    is_enabled: true
  },
  waiting_room: {
    is_enabled: false,
    enable_preview: true
  },
  control_bar: {
    is_enabled: true,
    elements: {
      plugins: true,
      screenshare: true,
      invite: true,
      participants: true,
      chat: true,
      reactions: false,
      polls: true,
      fullscreen: true,
      layout: true
    }
  },
  header: {
    is_enabled: true,
    elements: {
      timer: true,
      title: true,
      participant_count: true,
      change_layout: true
    }
  },
  pip_mode: true,
  auto_tune: true,
  grid: {
    multi: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    single: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    defaultView: "multi"
  },
  controls: {
    pip_toggle: false
  }
};
var zm = "hXgU8Wc8pwuGNq9ms5q9Hh";
var wg;
typeof process != "undefined" && (wg = process == null ? void 0 : process.env) != null && wg.FLAGSMITH_ENVIRONMENT_KEY && (zm = {}.FLAGSMITH_ENVIRONMENT_KEY);
function U_(s = []) {
  const t = {};
  return s.forEach((e) => {
    t[e.feature.name] = {
      enabled: e.enabled,
      value: e.feature_state_value
    };
  }), t;
}
__name(U_, "U_");
var Ym = class {
  static {
    __name(this, "Ym");
  }
  constructor(s = zm) {
    h(this, "flags", {});
    h(this, "environmentKey", null);
    this.environmentKey = s;
  }
  identifyAndFetchFlagsWithRetry(c) {
    return u(this, arguments, function* ({
      primaryEndpoint: s,
      secondaryEndpoint: t,
      forceEvaluate: e,
      timeout: r,
      uniqueIdentifier: i,
      traitsObj: n,
      logger: o
    }) {
      const d = JSON.parse(JSON.stringify(n)), l = Object.entries(d).map((f) => ({
        trait_key: f[0],
        trait_value: f[1]
      })), p = [s, t, t];
      for (const f of p)
        try {
          const S = new AbortController(), T = setTimeout(() => S.abort(), r), _ = "_" + (Math.random() + 1).toString(36).substring(2), P = yield fetch(`https://${f}/api/v1/identities/`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Environment-Key": this.environmentKey
            },
            body: JSON.stringify({
              identifier: i + (e ? _ : ""),
              traits: l
            }),
            signal: S.signal
          });
          if (clearTimeout(T), !P.ok)
            throw new Error(`Request failed with status ${P.status}`);
          const w = yield P.json();
          return U_(w.flags || []);
        } catch (S) {
          o.error("Flagsmith identify failed!!", { error: S, url: f });
        }
      return {};
    });
  }
  identify(o) {
    return u(this, arguments, function* (s, t = {}, e = false, r = 5e3, i = "edge.api.flagsmith.com", n = console) {
      return this.flags = yield this.identifyAndFetchFlagsWithRetry({
        traitsObj: t,
        uniqueIdentifier: s,
        forceEvaluate: e,
        timeout: r,
        primaryEndpoint: i,
        secondaryEndpoint: "edge.api.flagsmith.com",
        logger: n
      }), this.flags;
    });
  }
  getValue(s) {
    return this.flags && this.flags[s] && this.flags[s].value;
  }
  hasFeature(s) {
    return this.flags && this.flags[s] && this.flags[s].enabled;
  }
  getAllFlags() {
    return this.flags;
  }
};
var $_ = new Ym();
function F_(s) {
  return new Ym(s);
}
__name(F_, "F_");
var Qm = [-2, -1, 0, 1, 2];
var H_ = [0, 1, 2, 3, 4];
function B_(s) {
  s = s.trim();
  let t = "0", e = "0", r = "0";
  return s.length == 4 ? (t = "0x" + s[1] + s[1], e = "0x" + s[2] + s[2], r = "0x" + s[3] + s[3]) : s.length > 6 && (t = "0x" + s[1] + s[2], e = "0x" + s[3] + s[4], r = "0x" + s[5] + s[6]), [+t, +e, +r];
}
__name(B_, "B_");
var q_ = /* @__PURE__ */ __name((s, t, e) => {
  let r, i, n;
  if (t == 0)
    r = i = n = e;
  else {
    const o = /* @__PURE__ */ __name((l, p, f) => (f < 0 && (f += 1), f > 1 && (f -= 1), f < 0.16666666666666666 ? l + (p - l) * 6 * f : f < 0.5 ? p : f < 0.6666666666666666 ? l + (p - l) * (0.6666666666666666 - f) * 6 : l), "o"), c = e < 0.5 ? e * (1 + t) : e + t - e * t, d = 2 * e - c;
    r = o(d, c, s + 1 / 3), i = o(d, c, s), n = o(d, c, s - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(i * 255), Math.round(n * 255)];
}, "q_");
var j_ = /* @__PURE__ */ __name((s, t, e) => {
  s /= 255, t /= 255, e /= 255;
  const r = Math.max(s, t, e), i = Math.min(s, t, e);
  let n, o;
  const c = (r + i) / 2;
  if (r == i)
    n = o = 0;
  else {
    const d = r - i;
    switch (o = c > 0.5 ? d / (2 - r - i) : d / (r + i), r) {
      case s:
        n = (t - e) / d + (t < e ? 6 : 0);
        break;
      case t:
        n = (e - s) / d + 2;
        break;
      case e:
        n = (s - t) / d + 4;
        break;
    }
    n /= 6;
  }
  return [n, o, c];
}, "j_");
var G_ = /* @__PURE__ */ __name((s, t, e) => {
  const r = /* @__PURE__ */ __name((i) => i.toString(16).padStart(2, "0"), "r");
  return `#${r(s)}${r(t)}${r(e)}`;
}, "G_");
var Xm = /* @__PURE__ */ __name((s, t = Qm, e = 0.4) => {
  const r = [], [i, n, o] = B_(s), [c, d, l] = j_(i, n, o), p = Math.round(l * 100);
  p > 70 ? e = 0.8 : p > 60 ? e = 0.9 : p < 10 ? e = 0.075 : p < 42 && (e = 0.3);
  const f = t.findIndex((w) => w === 0);
  if (f === -1)
    throw new Error("Invalid reducer provided, it must contain atleast one zero");
  const S = 5 - f, T = f + 1, _ = (100 - p) / S, P = p / T;
  for (const w of t) {
    let A;
    w < 0 ? A = p + w * P * e : w > 0 ? A = p + w * _ * e : A = p;
    const [N, H, $] = q_(c, d, A / 100);
    r.push(G_(N, H, $));
  }
  return r;
}, "Xm");
var Ip = {
  dark: {
    background: {
      1e3: "#252525",
      900: "#2F2F2F",
      800: "#323232",
      700: "#3E3E3E",
      600: "#4A4A4A"
    },
    text: "#F5F5F5",
    "video-bg": "#1C1C1C"
  },
  light: {
    background: {
      1e3: "#FFFFFF",
      900: "#F5F5F5",
      800: "#EBEBEB",
      700: "#E0E0E0",
      600: "#D6D6D6"
    },
    text: "#111111",
    "text-on-brand": "#ffffff",
    "video-bg": "#DADADA"
  }
};
var W_ = /* @__PURE__ */ __name((s) => {
  const [t, e, r, i, n] = Xm(s, Qm);
  return { 300: t, 400: e, 500: r, 600: i, 700: n };
}, "W_");
var J_ = /* @__PURE__ */ __name((s) => {
  if (s === "#FFFFFF")
    return Ip.light.background;
  if (s === "#000000")
    return Ip.dark.background;
  const [t, e, r, i, n] = Xm(s, H_);
  return { 1e3: t, 900: e, 800: r, 700: i, 600: n };
}, "J_");
var K_ = {
  border_radius: "rounded",
  border_width: "thin",
  spacing_base: 4,
  theme: "dark",
  colors: {
    brand: W_("#2160FD"),
    background: J_("#141414"),
    danger: "#FF2D2D",
    text: "#EEEEEE",
    text_on_brand: "#EEEEEE",
    success: "#62A504",
    video_bg: "#191919",
    warning: "#FFCD07"
  }
};
function Zm() {
  return bh(K_);
}
__name(Zm, "Zm");
var z_ = {
  permissions: {
    can_accept_production_requests: false,
    can_edit_display_name: true,
    accept_waiting_requests: false,
    disable_participant_audio: false,
    disable_participant_screensharing: false,
    disable_participant_video: false,
    can_spotlight: false,
    kick_participant: false,
    pin_participant: false,
    can_record: false,
    can_livestream: false,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: true,
      can_start: true,
      can_edit_config: false,
      config: {}
    },
    polls: {
      can_create: true,
      can_vote: true,
      can_view: true
    },
    media: {
      video: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
      },
      audio: {
        can_produce: "ALLOWED"
      },
      screenshare: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
      }
    },
    chat: {
      public: {
        can_send: true,
        text: true,
        files: true
      },
      private: {
        can_send: false,
        can_receive: false,
        text: false,
        files: false
      },
      channel: {
        can_create: "ALL",
        can_delete: "ALL",
        can_update: "ALL",
        can_read_all: false
      },
      message: {
        can_delete: "ALL",
        can_edit: "ALL",
        delete_cutoff_time_seconds: 0,
        edit_cutoff_time_seconds: 0
      }
    },
    hidden_participant: false,
    is_recorder: false,
    recorder_type: "NONE",
    show_participant_list: true,
    transcription_enabled: false,
    can_change_participant_permissions: false,
    connected_meetings: {
      can_alter_connected_meetings: false,
      can_switch_connected_meetings: false,
      can_switch_to_parent_meeting: false
    },
    stage_enabled: false,
    stage_access: void 0,
    accept_stage_requests: false
  },
  ui: {
    oldTheme: {
      setup_screen: {
        is_enabled: false
      },
      alone_here: {
        is_enabled: false
      },
      waiting_room: {
        is_enabled: false,
        enable_preview: true
      },
      control_bar: {
        is_enabled: true,
        elements: {
          plugins: true,
          screenshare: true,
          invite: false,
          participants: true,
          chat: true,
          reactions: false,
          polls: true,
          fullscreen: true,
          layout: true
        }
      },
      header: {
        is_enabled: true,
        elements: {
          timer: true,
          title: true,
          participant_count: true,
          change_layout: true
        }
      },
      pip_mode: true,
      auto_tune: true,
      colors: {
        primary: "#2160FD",
        secondary: "#1A1A1A",
        text: "#EEEEEE",
        background: "#1A1A1A",
        textPrimary: "#EEEEEE",
        videoBackground: "#1A1A1A"
      },
      dimensions: {
        mode: "fillParent"
      },
      grid: {
        multi: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        single: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        defaultView: "MULTI"
      },
      controls: {
        pip_toggle: false
      },
      plugins: []
    },
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: false,
        enable_high_bitrate: false
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "hybrid"
};
function Y_() {
  return bh(z_);
}
__name(Y_, "Y_");
var Q_ = {
  permissions: {
    can_accept_production_requests: false,
    can_edit_display_name: true,
    accept_waiting_requests: false,
    disable_participant_audio: false,
    disable_participant_screensharing: false,
    disable_participant_video: false,
    can_spotlight: false,
    kick_participant: false,
    pin_participant: false,
    can_record: false,
    can_livestream: false,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: true,
      can_start: true,
      can_edit_config: false,
      config: {}
    },
    polls: {
      can_create: true,
      can_vote: true,
      can_view: true
    },
    media: {
      video: {
        can_produce: "ALLOWED"
      },
      audio: {
        can_produce: "ALLOWED"
      },
      screenshare: {
        can_produce: "ALLOWED"
      }
    },
    chat: {
      public: {
        can_send: true,
        text: true,
        files: true
      },
      private: {
        can_send: false,
        can_receive: false,
        text: false,
        files: false
      }
    },
    hidden_participant: false,
    is_recorder: false,
    recorder_type: "NONE",
    show_participant_list: true,
    transcription_enabled: false,
    can_change_participant_permissions: false,
    connected_meetings: {
      can_alter_connected_meetings: false,
      can_switch_connected_meetings: false,
      can_switch_to_parent_meeting: false
    },
    stage_enabled: false,
    stage_access: void 0,
    accept_stage_requests: false
  },
  ui: {
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: false,
        enable_high_bitrate: false
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "2.0.0"
};
function kh() {
  return bh(Q_);
}
__name(kh, "kh");
var $o;
var ef = class {
  static {
    __name(this, "ef");
  }
  constructor() {
    g(this, $o, void 0);
  }
  get telemetry() {
    var t;
    return (t = a(this, $o)) == null ? void 0 : t.getValue("telemetry");
  }
  init(t) {
    m(this, $o, t);
  }
  info(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "info",
      t,
      e,
      r
    );
  }
  error(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "error",
      t,
      e,
      r
    );
  }
  debug(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "debug",
      t,
      e,
      r
    );
  }
  log(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "log",
      t,
      e,
      r
    );
  }
  warn(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "warn",
      t,
      e,
      r
    );
  }
};
$o = /* @__PURE__ */ new WeakMap();
var js;
var Gs;
var zh = class extends ut.EventEmitter {
  static {
    __name(this, "zh");
  }
  constructor(e) {
    super();
    g(this, js, void 0);
    g(this, Gs, void 0);
    h(this, "asyncPromiseTimeout");
    h(this, "logger");
    this.logger = e, m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), this.asyncPromiseTimeout = 8e3;
  }
  emitAsync(e, ...r) {
    return u(this, null, function* () {
      a(this, js).set(e, []);
      const i = a(this, Gs).get(e).map(
        () => new Promise((n) => {
          a(this, js).get(e).push(n);
        })
      );
      tp(zh.prototype, this, "emit").call(this, e, ...r), yield Promise.race([
        Promise.all(i),
        new Promise(
          (n, o) => setTimeout(
            () => o(new Error(`emitAsync failed to resolve for event ${e}.`)),
            this.asyncPromiseTimeout
          )
        )
      ]), a(this, js).delete(e);
    });
  }
  onAsync(e, r) {
    const i = a(this, js), n = /* @__PURE__ */ __name((...o) => u(this, null, function* () {
      var d;
      try {
        yield r(...o);
      } catch (l) {
        this.logger.error("[onAsync]", { error: l });
      }
      const c = (d = i.get(e)) == null ? void 0 : d.shift();
      c == null || c();
    }), "n");
    return a(this, Gs).get(e) || a(this, Gs).set(e, []), a(this, Gs).get(e).push(n), super.on(e, n);
  }
  reset() {
    m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), super.removeAllListeners();
  }
};
var wu = zh;
js = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap();
var X_ = /\s/;
function Z_(s) {
  for (var t = s.length; t-- && X_.test(s.charAt(t)); )
    ;
  return t;
}
__name(Z_, "Z_");
var eP = /^\s+/;
function tP(s) {
  return s && s.slice(0, Z_(s) + 1).replace(eP, "");
}
__name(tP, "tP");
var Ap = 0 / 0;
var sP = /^[-+]0x[0-9a-f]+$/i;
var rP = /^0b[01]+$/i;
var iP = /^0o[0-7]+$/i;
var aP = parseInt;
function Mp(s) {
  if (typeof s == "number")
    return s;
  if (D_(s))
    return Ap;
  if (Ps(s)) {
    var t = typeof s.valueOf == "function" ? s.valueOf() : s;
    s = Ps(t) ? t + "" : t;
  }
  if (typeof s != "string")
    return s === 0 ? s : +s;
  s = tP(s);
  var e = rP.test(s);
  return e || iP.test(s) ? aP(s.slice(2), e ? 2 : 8) : sP.test(s) ? Ap : +s;
}
__name(Mp, "Mp");
function tf(s) {
  return s;
}
__name(tf, "tf");
function nP(s, t, e) {
  switch (e.length) {
    case 0:
      return s.call(t);
    case 1:
      return s.call(t, e[0]);
    case 2:
      return s.call(t, e[0], e[1]);
    case 3:
      return s.call(t, e[0], e[1], e[2]);
  }
  return s.apply(t, e);
}
__name(nP, "nP");
var oP = 800;
var cP = 16;
var dP = Date.now;
function lP(s) {
  var t = 0, e = 0;
  return function() {
    var r = dP(), i = cP - (r - e);
    if (e = r, i > 0) {
      if (++t >= oP)
        return arguments[0];
    } else
      t = 0;
    return s.apply(void 0, arguments);
  };
}
__name(lP, "lP");
function uP(s) {
  return function() {
    return s;
  };
}
__name(uP, "uP");
var hP = Ad ? function(s, t) {
  return Ad(s, "toString", {
    configurable: true,
    enumerable: false,
    value: uP(t),
    writable: true
  });
} : tf;
var pP = hP;
var gP = lP(pP);
var mP = gP;
var Dp = Math.max;
function fP(s, t, e) {
  return t = Dp(t === void 0 ? s.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, n = Dp(r.length - t, 0), o = Array(n); ++i < n; )
      o[i] = r[t + i];
    i = -1;
    for (var c = Array(t + 1); ++i < t; )
      c[i] = r[i];
    return c[t] = e(o), nP(s, this, c);
  };
}
__name(fP, "fP");
function SP(s, t) {
  return mP(fP(s, t, tf), s + "");
}
__name(SP, "SP");
function vP(s, t, e) {
  if (!Ps(e))
    return false;
  var r = typeof t;
  return (r == "number" ? Gc(e) && Mm(t, e.length) : r == "string" && t in e) ? qc(e[t], s) : false;
}
__name(vP, "vP");
function yP(s) {
  return SP(function(t, e) {
    var r = -1, i = e.length, n = i > 1 ? e[i - 1] : void 0, o = i > 2 ? e[2] : void 0;
    for (n = s.length > 3 && typeof n == "function" ? (i--, n) : void 0, o && vP(e[0], e[1], o) && (n = i < 3 ? void 0 : n, i = 1), t = Object(t); ++r < i; ) {
      var c = e[r];
      c && s(t, c, r, n);
    }
    return t;
  });
}
__name(yP, "yP");
var TP = "[object Object]";
var EP = Function.prototype;
var _P = Object.prototype;
var sf = EP.toString;
var PP = _P.hasOwnProperty;
var CP = sf.call(Object);
function RP(s) {
  if (!$s(s) || ma(s) != TP)
    return false;
  var t = Rh(s);
  if (t === null)
    return true;
  var e = PP.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e instanceof e && sf.call(e) == CP;
}
__name(RP, "RP");
var wP = "__lodash_hash_undefined__";
function bP(s) {
  return this.__data__.set(s, wP), this;
}
__name(bP, "bP");
function kP(s) {
  return this.__data__.has(s);
}
__name(kP, "kP");
function Od(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.__data__ = new va(); ++t < e; )
    this.add(s[t]);
}
__name(Od, "Od");
Od.prototype.add = Od.prototype.push = bP;
Od.prototype.has = kP;
function IP(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r; )
    if (t(s[e], e, s))
      return true;
  return false;
}
__name(IP, "IP");
function AP(s, t) {
  return s.has(t);
}
__name(AP, "AP");
var MP = 1;
var DP = 2;
function rf(s, t, e, r, i, n) {
  var o = e & MP, c = s.length, d = t.length;
  if (c != d && !(o && d > c))
    return false;
  var l = n.get(s), p = n.get(t);
  if (l && p)
    return l == t && p == s;
  var f = -1, S = true, T = e & DP ? new Od() : void 0;
  for (n.set(s, t), n.set(t, s); ++f < c; ) {
    var _ = s[f], P = t[f];
    if (r)
      var w = o ? r(P, _, f, t, s, n) : r(_, P, f, s, t, n);
    if (w !== void 0) {
      if (w)
        continue;
      S = false;
      break;
    }
    if (T) {
      if (!IP(t, function(A, N) {
        if (!AP(T, N) && (_ === A || i(_, A, e, r, n)))
          return T.push(N);
      })) {
        S = false;
        break;
      }
    } else if (!(_ === P || i(_, P, e, r, n))) {
      S = false;
      break;
    }
  }
  return n.delete(s), n.delete(t), S;
}
__name(rf, "rf");
function OP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r, i) {
    e[++t] = [i, r];
  }), e;
}
__name(OP, "OP");
function NP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r) {
    e[++t] = r;
  }), e;
}
__name(NP, "NP");
var VP = 1;
var LP = 2;
var xP = "[object Boolean]";
var UP = "[object Date]";
var $P = "[object Error]";
var FP = "[object Map]";
var HP = "[object Number]";
var BP = "[object RegExp]";
var qP = "[object Set]";
var jP = "[object String]";
var GP = "[object Symbol]";
var WP = "[object ArrayBuffer]";
var JP = "[object DataView]";
var Op = ti ? ti.prototype : void 0;
var cu = Op ? Op.valueOf : void 0;
function KP(s, t, e, r, i, n, o) {
  switch (e) {
    case JP:
      if (s.byteLength != t.byteLength || s.byteOffset != t.byteOffset)
        return false;
      s = s.buffer, t = t.buffer;
    case WP:
      return !(s.byteLength != t.byteLength || !n(new Dd(s), new Dd(t)));
    case xP:
    case UP:
    case HP:
      return qc(+s, +t);
    case $P:
      return s.name == t.name && s.message == t.message;
    case BP:
    case jP:
      return s == t + "";
    case FP:
      var c = OP;
    case qP:
      var d = r & VP;
      if (c || (c = NP), s.size != t.size && !d)
        return false;
      var l = o.get(s);
      if (l)
        return l == t;
      r |= LP, o.set(s, t);
      var p = rf(c(s), c(t), r, i, n, o);
      return o.delete(s), p;
    case GP:
      if (cu)
        return cu.call(s) == cu.call(t);
  }
  return false;
}
__name(KP, "KP");
var zP = 1;
var YP = Object.prototype;
var QP = YP.hasOwnProperty;
function XP(s, t, e, r, i, n) {
  var o = e & zP, c = Eu(s), d = c.length, l = Eu(t), p = l.length;
  if (d != p && !o)
    return false;
  for (var f = d; f--; ) {
    var S = c[f];
    if (!(o ? S in t : QP.call(t, S)))
      return false;
  }
  var T = n.get(s), _ = n.get(t);
  if (T && _)
    return T == t && _ == s;
  var P = true;
  n.set(s, t), n.set(t, s);
  for (var w = o; ++f < d; ) {
    S = c[f];
    var A = s[S], N = t[S];
    if (r)
      var H = o ? r(N, A, S, t, s, n) : r(A, N, S, s, t, n);
    if (!(H === void 0 ? A === N || i(A, N, e, r, n) : H)) {
      P = false;
      break;
    }
    w || (w = S == "constructor");
  }
  if (P && !w) {
    var $ = s.constructor, F = t.constructor;
    $ != F && "constructor" in s && "constructor" in t && !(typeof $ == "function" && $ instanceof $ && typeof F == "function" && F instanceof F) && (P = false);
  }
  return n.delete(s), n.delete(t), P;
}
__name(XP, "XP");
var ZP = 1;
var Np = "[object Arguments]";
var Vp = "[object Array]";
var td = "[object Object]";
var eC = Object.prototype;
var Lp = eC.hasOwnProperty;
function tC(s, t, e, r, i, n) {
  var o = si(s), c = si(t), d = o ? Vp : jn(s), l = c ? Vp : jn(t);
  d = d == Np ? td : d, l = l == Np ? td : l;
  var p = d == td, f = l == td, S = d == l;
  if (S && Bn(s)) {
    if (!Bn(t))
      return false;
    o = true, p = false;
  }
  if (S && !p)
    return n || (n = new Us()), o || ql(s) ? rf(s, t, e, r, i, n) : KP(s, t, d, e, r, i, n);
  if (!(e & ZP)) {
    var T = p && Lp.call(s, "__wrapped__"), _ = f && Lp.call(t, "__wrapped__");
    if (T || _) {
      var P = T ? s.value() : s, w = _ ? t.value() : t;
      return n || (n = new Us()), i(P, w, e, r, n);
    }
  }
  return S ? (n || (n = new Us()), XP(s, t, e, r, i, n)) : false;
}
__name(tC, "tC");
function af(s, t, e, r, i) {
  return s === t ? true : s == null || t == null || !$s(s) && !$s(t) ? s !== s && t !== t : tC(s, t, e, r, af, i);
}
__name(af, "af");
function sC(s) {
  return function(t, e, r) {
    for (var i = -1, n = Object(t), o = r(t), c = o.length; c--; ) {
      var d = o[s ? c : ++i];
      if (e(n[d], d, n) === false)
        break;
    }
    return t;
  };
}
__name(sC, "sC");
var rC = sC();
var iC = rC;
var aC = /* @__PURE__ */ __name(function() {
  return Cs.Date.now();
}, "aC");
var du = aC;
var nC = "Expected a function";
var oC = Math.max;
var cC = Math.min;
function Ih(s, t, e) {
  var r, i, n, o, c, d, l = 0, p = false, f = false, S = true;
  if (typeof s != "function")
    throw new TypeError(nC);
  t = Mp(t) || 0, Ps(e) && (p = !!e.leading, f = "maxWait" in e, n = f ? oC(Mp(e.maxWait) || 0, t) : n, S = "trailing" in e ? !!e.trailing : S);
  function T(K) {
    var re = r, Je = i;
    return r = i = void 0, l = K, o = s.apply(Je, re), o;
  }
  __name(T, "T");
  function _(K) {
    return l = K, c = setTimeout(A, t), p ? T(K) : o;
  }
  __name(_, "_");
  function P(K) {
    var re = K - d, Je = K - l, ks = t - re;
    return f ? cC(ks, n - Je) : ks;
  }
  __name(P, "P");
  function w(K) {
    var re = K - d, Je = K - l;
    return d === void 0 || re >= t || re < 0 || f && Je >= n;
  }
  __name(w, "w");
  function A() {
    var K = du();
    if (w(K))
      return N(K);
    c = setTimeout(A, P(K));
  }
  __name(A, "A");
  function N(K) {
    return c = void 0, S && r ? T(K) : (r = i = void 0, o);
  }
  __name(N, "N");
  function H() {
    c !== void 0 && clearTimeout(c), l = 0, r = d = i = c = void 0;
  }
  __name(H, "H");
  function $() {
    return c === void 0 ? o : N(du());
  }
  __name($, "$");
  function F() {
    var K = du(), re = w(K);
    if (r = arguments, i = this, d = K, re) {
      if (c === void 0)
        return _(d);
      if (f)
        return clearTimeout(c), c = setTimeout(A, t), T(d);
    }
    return c === void 0 && (c = setTimeout(A, t)), o;
  }
  __name(F, "F");
  return F.cancel = H, F.flush = $, F;
}
__name(Ih, "Ih");
function bu(s, t, e) {
  (e !== void 0 && !qc(s[t], e) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
__name(bu, "bu");
function dC(s) {
  return $s(s) && Gc(s);
}
__name(dC, "dC");
function ku(s, t) {
  if (!(t === "constructor" && typeof s[t] == "function") && t != "__proto__")
    return s[t];
}
__name(ku, "ku");
function lC(s) {
  return jc(s, Wc(s));
}
__name(lC, "lC");
function uC(s, t, e, r, i, n, o) {
  var c = ku(s, e), d = ku(t, e), l = o.get(d);
  if (l) {
    bu(s, e, l);
    return;
  }
  var p = n ? n(c, d, e + "", s, t, o) : void 0, f = p === void 0;
  if (f) {
    var S = si(d), T = !S && Bn(d), _ = !S && !T && ql(d);
    p = d, S || T || _ ? si(c) ? p = c : dC(c) ? p = $m(c) : T ? (f = false, p = Um(d, true)) : _ ? (f = false, p = jm(d, true)) : p = [] : RP(d) || Md(d) ? (p = c, Md(c) ? p = lC(c) : (!Ps(c) || Th(c)) && (p = Gm(d))) : f = false;
  }
  f && (o.set(d, p), i(p, d, r, n, o), o.delete(d)), bu(s, e, p);
}
__name(uC, "uC");
function nf(s, t, e, r, i) {
  s !== t && iC(t, function(n, o) {
    if (i || (i = new Us()), Ps(n))
      uC(s, t, o, e, nf, r, i);
    else {
      var c = r ? r(ku(s, o), n, o + "", s, t, i) : void 0;
      c === void 0 && (c = n), bu(s, o, c);
    }
  }, Wc);
}
__name(nf, "nf");
var hC = "[object Map]";
var pC = "[object Set]";
var gC = Object.prototype;
var mC = gC.hasOwnProperty;
function fC(s) {
  if (s == null)
    return true;
  if (Gc(s) && (si(s) || typeof s == "string" || typeof s.splice == "function" || Bn(s) || ql(s) || Md(s)))
    return !s.length;
  var t = jn(s);
  if (t == hC || t == pC)
    return !s.size;
  if (jl(s))
    return !Lm(s).length;
  for (var e in s)
    if (mC.call(s, e))
      return false;
  return true;
}
__name(fC, "fC");
function SC(s, t) {
  return af(s, t);
}
__name(SC, "SC");
var vC = yP(function(s, t, e) {
  nf(s, t, e);
});
var br = vC;
var Iu = /* @__PURE__ */ ((s) => (s.PARTICIPANT = "PARTICIPANT", s.PEER = "PEER", s.CLIENT = "CLIENT", s))(Iu || {});
var X = {
  PROPAGATE_KICK_ALL: "propagate_kick_across_rooms",
  REFRESH_ID_ON_DISCONNECTION: "refresh_id_on_disconnection",
  SIMULCAST: "simulcast",
  CHAT_SOCKET_SERVER: "chat_socket_server",
  POLL_SOCKET_SERVER: "poll_socket_server",
  PLUGIN_SOCKET_SERVER: "plugin_socket_server",
  NR_OTEL_WEB: "nr_otel_web",
  ICE_RESTART_ON_FAILED_STATE: "ice_restart_on_failed_state",
  ICE_RESTART_ON_DISCONNECTED_STATE: "ice_restart_on_disconnected_state",
  ENABLE_ICE_STATE_LOGGING: "enable_ice_state_logging",
  SUPPRESS_PEER_MUTE_UNMUTE_EMITS: "web_core_suppress_peer_mute_unmute_emits",
  SKIP_OTEL_TRACES: "skip_otel_traces",
  USE_USERIDS_IN_CHAT: "use_userids_in_chat",
  CUSTOM_PING_PONG: "custom_ping_pong",
  ENABLE_HIVE_SIMULCAST: "enable_hive_simulcast",
  ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_hive_transport_reconnection_on_ice_failed",
  ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY: "enable_hive_fail_recovery",
  ENABLE_HIVE_INFINITE_RETRIES: "enable_hive_infinite_retries",
  HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "hive_transport_force_relay_on_ice_failed",
  ENABLE_HIVE_CONSUME_OVER_DC: "enable_hive_consume_over_dc",
  ENABLE_CF_SIMULCAST: "enable_cf_simulcast",
  ENABLE_CF_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_cf_transport_reconnection_on_ice_failed",
  ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY: "enable_cf_fail_recovery",
  ENABLE_CF_INFINITE_RETRIES: "enable_cf_infinite_retries",
  CF_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "cf_transport_force_relay_on_ice_failed",
  BYPASS_LOG_EXCLUSION_LIST: "bypass_log_exclusion_list",
  LOG_LEVEL: "log_level",
  V1_PLUGINS: "v1_plugins",
  SCREENSHARE_DTX: "screenshare_dtx",
  SCREENSHARE_PRIORITY: "screenshare_priority",
  SCREENSHARE_MIN_BITRATE: "screenshare_minbitrate",
  SCREENSHARE_SIMULCAST: "screenshare_simulcast",
  DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE: "disable_webcam_layers_on_screenshare",
  SCREENSHARE_FORCE_GOOG_CONFERENCE: "screenshare_force_goog_conference",
  LIVESTREAM: "feat_livestream",
  FETCH_RETRY: "fetch_retry",
  DISABLE_WEBCAM_SIMULCAST: "webcore_disable_webcam_simulcast",
  OVERRIDE_WEBCAM_SIMULCAST: "override_webcam_simulcast",
  SOCKET_POLLING: "socket_polling",
  FEAT_PAGINATED_CHAT: "feat_paginated_chat",
  VAL_MIN_FRAMERATE: "val_min_framerate",
  SCREEENSHARE_ERR_HACK: "screenshare_err_hack",
  SCREEENSHARE_CONSTRAINTS_RETRY: "screenshare_constraints_retry",
  TROUBLESHOOTING: "feat_troubleshooting",
  VIDEO_CONSTRAINTS: "video_constraints",
  SCREENSHARE_CONSTRAINTS: "screenshare_constraints",
  FEAT_CHAT_SDK: "feat_chat_sdk",
  FEAT_CHAT_SDK_SEARCH: "chat_search",
  OBS_QUALITY: "obs_quality",
  ALLOW_SAFARI_MEDIA_MIDDLEWARES: "allow_safari_media_middlewares",
  DYNAMIC_VIDEO_QUALITY: "dynamic_video_quality",
  EXP_RESHARE: "exp_reshare",
  LEAVE_STAGE_ON_END: "leave_stage_on_end",
  SKIP_SETTING_IN_USE_DEVICE: "skip_setting_in_use_device",
  PRECALL_BANDWIDTH_TEST: "precall_bandwidth_test",
  CONSUMER_BIND_NO_RETRY: "consumer_bind_no_retry",
  DEBUG_SOCKET_JOIN: "debug_socket_join",
  FORCE_RELAY: "force_relay",
  FORCE_VIDEO_CODEC: "force_video_codec",
  USE_EXPERIMENTAL_SFU_HANDLER: "use_experimental_sfu_handler",
  TRACK_HINT: "track_hint",
  OVERRIDE_HIVE_SIMULCAST_DYNAMIC: "override_hive_simulcast_dynamic",
  PRECREATE_PRODUCERS: "precreate_producers",
  DISABLE_OPUS_DTX_CF: "disable_opus_dtx_cf",
  ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS: "enable_audio_activity_debug_logs",
  NEW_SYNC_CONSUMERS: "new_sync_consumers"
};
function gd(s) {
  const t = {};
  return typeof (s == null ? void 0 : s.code) == "number" && (t.code = s.code), typeof (s == null ? void 0 : s.code) == "string" && (t.code = s.code.substring(0, 100)), typeof (s == null ? void 0 : s.name) == "string" && (t.name = s.name.substring(0, 500)), typeof (s == null ? void 0 : s.message) == "string" && (t.message = s.message.substring(0, 500)), typeof (s == null ? void 0 : s.reason) == "string" && (t.reason = s.reason.substring(0, 500)), typeof (s == null ? void 0 : s.stack) == "string" && (t.stack = s.stack.substring(0, 500)), t;
}
__name(gd, "gd");
function yC(s) {
  var r, i, n, o;
  const t = typeof navigator != "undefined" && !navigator.isReactNative && typeof window != "undefined" && ((r = window.location.host) == null ? void 0 : r.includes("devel")) && ((i = window.location.host) == null ? void 0 : i.includes("dyte.io")), e = !!((o = (n = s == null ? void 0 : s.getValue("modules")) == null ? void 0 : n.devTools) != null && o.logs);
  return t || e;
}
__name(yC, "yC");
function TC(s, t) {
  var e;
  if (s != null && s.getValue("flagsmith").hasFeature(X.LOG_LEVEL)) {
    let r = ((e = s.getValue("flagsmith").getValue(X.LOG_LEVEL)) == null ? void 0 : e.toString()) || "all";
    if (r = r.toLowerCase().trim(), r === "off")
      return false;
    if (r !== "all") {
      const i = ["debug", "log", "info", "warn", "error"], n = i.indexOf(
        t
      ), o = i.indexOf(r);
      if (n < o)
        return false;
    }
  }
  return true;
}
__name(TC, "TC");
function of(s, t, e = {}) {
  return Object.getOwnPropertyNames(s).forEach((r) => {
    var n;
    if ([null, void 0, NaN].includes(s[r]) || t && (((n = t.match(/\./g)) == null ? void 0 : n.length) || 0) >= 10)
      return;
    const i = t ? `${t}.${r}` : r;
    typeof s[r] == "object" ? of(s[r], i, e) : ["number", "string", "boolean"].includes(typeof s[r]) && (e[i] = s[r]);
  }), e;
}
__name(of, "of");
function xp(s, t, e = {}, r = "") {
  const i = {};
  try {
    const n = JSON.stringify(e), o = JSON.parse(n), c = of(
      o,
      r
    ), d = JSON.stringify(c);
    return JSON.parse(d);
  } catch (n) {
    const o = gd(n);
    i[`${r}.error.message`] = o.message || "", i[`${r}.error.stack`] = o.stack || "", i[`${r}.error.reason`] = o.reason || "", i[`${r}.error.source`] = "safelyFlattenObjForOpenTelemetry";
  }
  return i;
}
__name(xp, "xp");
var EC = {
  audio: true,
  video: true,
  screenshareAudio: true,
  screenshareVideo: true
};
var mo = {
  baseURL: "http://localhost:5000",
  createdAt: "2021-08-05T10:49:56.602Z",
  description: "Develop plugins locally",
  id: "09259e3b-7be8-46f6-9801-106bf1866e1c",
  name: "Localhost Dev",
  organizationId: "4ad15a19-80e2-4105-bf43-48039fd2963e",
  picture: "https://dyte-uploads.s3.ap-south-1.amazonaws.com/dyte.png",
  private: false,
  published: true,
  staggered: false,
  tags: ["#localhost", "#dev"],
  type: "self_hosted",
  updatedAt: "2021-08-05T10:50:07.681Z"
};
var _C = {
  pip: true,
  poll: true,
  chat: true,
  stage: true,
  theme: true,
  plugin: true,
  tracing: true,
  internals: true,
  recording: true,
  livestream: true,
  participant: true,
  connectedMeetings: true,
  devTools: {
    logs: false
  }
};
function Gn(s, t) {
  const e = s.getValue("overrides");
  return e && e[t] ? e[t] : false;
}
__name(Gn, "Gn");
function PC({ baseURI: s }) {
  return s.includes("preprod.dyte") || s.includes("preprod.realtime") ? bo.PREPROD : s.includes("devel.dyte") || s.includes("devel.realtime") ? bo.DEVEL : bo.PROD;
}
__name(PC, "PC");
function da({ servicePrefix: s, baseURI: t }) {
  return `${s}.${t}`;
}
__name(da, "da");
function cf(s) {
  const t = s.getValue("baseURI");
  return {
    location: da({
      servicePrefix: "location",
      baseURI: t
    }),
    locationLegacy: da({
      servicePrefix: "location-legacy",
      baseURI: t
    }),
    daCollector: da({
      servicePrefix: "da-collector",
      baseURI: t.replace("realtime.cloudflare.com", "dyte.io")
    })
  };
}
__name(cf, "cf");
var CC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>';
var RC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 12.02c0 1.06.2 2.1.6 3.08l.6 1.42c.22.55.64 1.01 1.17 1.29.27.14.56.21.86.21h2.55c.77 0 1.49-.41 1.87-1.08.5-.87 1.02-1.7 1.72-2.43l1.32-1.39c.44-.46.97-.84 1.49-1.23l.59-.45a.6.6 0 0 0 .23-.47c0-.75-.54-1.57-1.22-1.79a3.34 3.34 0 0 0-2.78.29V4.5a1.5 1.5 0 0 0-2.05-1.4 1.5 1.5 0 0 0-2.9 0A1.5 1.5 0 0 0 6 4.5v.09A1.5 1.5 0 0 0 4 6v6.02ZM8 4.5v4a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0v5a.5.5 0 0 0 1 0v-4a.5.5 0 0 1 1 0v6a.5.5 0 0 0 .85.37h.01c.22-.22.44-.44.72-.58.7-.35 2.22-.57 2.4.5l-.53.4c-.52.4-1.04.78-1.48 1.24l-1.33 1.38c-.75.79-1.31 1.7-1.85 2.63-.21.36-.6.58-1.01.58H7.23a.87.87 0 0 1-.4-.1 1.55 1.55 0 0 1-.71-.78l-.59-1.42a7.09 7.09 0 0 1-.53-2.7V6a.5.5 0 0 1 1 0v3.5a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0Z" fill="currentColor"></path></svg>';
var sd = /* @__PURE__ */ __name((s) => {
  if (!s)
    return;
  if (!s.startsWith("<svg"))
    return new Promise((n) => {
      n(s);
    });
  const e = new Blob([s], { type: "image/svg+xml" }), r = new Image(), i = window.URL.createObjectURL(e);
  return new Promise((n, o) => {
    r.onload = () => {
      n(r), window.URL.revokeObjectURL(i);
    }, r.onerror = () => {
      o(), window.URL.revokeObjectURL(i);
    }, r.src = i;
  });
}, "sd");
var Yh = class {
  static {
    __name(this, "Yh");
  }
  constructor() {
    h(this, "logsCache", []);
    h(this, "logsProcessorTimer");
    h(this, "tracingEnabled", true);
    h(this, "initialized", false);
    h(this, "logsProcessingInterval", 7e3);
    h(this, "logExclusionList", [
      "message",
      "websocket/message",
      "roomMessage",
      "websocket/room-message",
      "websocket/room-legacy-mode",
      "chatMessage",
      "websocket/new-chat-message",
      "websocket/no-active-speaker",
      "websocket/selected-peers",
      "websocket/active-speaker",
      "ping",
      "websocket/new-consumer",
      "websocket/producer-score",
      "websocket/consumer-score",
      "websocket/plugin-event",
      "websocket/plugin-data",
      "websocket/plugin-internal-data"
    ]);
    h(this, "meetingMetadata", {});
  }
  get logsEndpoint() {
    const t = mr.getContext(this.meetingMetadata.peerId);
    return `https://${da({
      servicePrefix: "api-silos",
      baseURI: t.getValue("baseURI")
    })}/otel/logs`;
  }
  resetPeerId(t) {
    this.meetingMetadata.peerId = t;
  }
  init(t, e, r) {
    this.tracingEnabled = true, this.initialized = false, this.logsCache = [];
    const i = t.getValue("peerId");
    this.meetingMetadata = e, this.tracingEnabled = r, this.meetingMetadata.peerId = i, this.meetingMetadata.sdkVersion = t.getValue("sdkVersion");
    const { RNDeviceInfoImpl: n } = navigator;
    this.meetingMetadata.deviceInfo = navigator.isReactNative ? n == null ? void 0 : n.getDeviceInfo() : Te.getDeviceInfo(), this.meetingMetadata.visitedUrl = !navigator.isReactNative && typeof window != "undefined" && window.location.href, this.logsProcessorTimer = setInterval(
      this.processCachedLogs.bind(this),
      this.logsProcessingInterval
    ), r && (this.initialized = true);
  }
  static trace(t, e = void 0) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var S;
        const l = this == null ? void 0 : this.telemetry;
        if (!l || !l.initialized || navigator.isReactNative || !l.tracingEnabled || (S = mr.getContext(l.meetingMetadata.peerId)) != null && S.getValue("flagsmith").hasFeature(X.SKIP_OTEL_TRACES))
          return o.apply(this, d);
        l.addLogInCurrentSpan("info", t, e);
        const p = performance.now(), f = o.apply(this, d);
        return Promise.resolve(f).then(() => {
          const T = performance.now();
          T - p > 10 && l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p,
            country: Yh.location.country
          });
        }).catch(() => {
          const T = performance.now();
          l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p
          });
        }), f;
      }, n;
    };
  }
  injectContext(t) {
    var i;
    const e = v4().replace(/-/g, "").substring(0, 16), r = (i = this.meetingMetadata.peerId) == null ? void 0 : i.replace(/-/g, "");
    t.TRACEPARENT = `00-${r}-${e}-01`;
  }
  addLogInCurrentSpan(t, e, r = {}, i = false) {
    r != null && r.error && Object.assign(r, { error: gd(r.error) });
    const n = mr.getContext(this.meetingMetadata.peerId);
    if (yC(n) && (fC(r) ? console[t]("DyteInternalLogs:: ", t, e) : console[t](
      "DyteInternalLogs:: ",
      t,
      e,
      r
    )), !!TC(n, t))
      try {
        const c = xp(
          n,
          e,
          r,
          "metadata"
        ), d = /* @__PURE__ */ new Date(), l = B(D({
          message: e,
          level: t
        }, c), {
          loggedAt: d.toISOString(),
          loggedAtTzOffset: d.getTimezoneOffset()
        });
        i ? this.sendOtelLogsToNewRelic([l]) : this.logsCache.push(l);
      } catch (c) {
        this.addLogInCurrentSpan(
          "error",
          "opentelemetry::addLogInCurrentSpan_failed",
          {
            error: gd(c)
          }
        );
      }
  }
  sendOtelLogsToNewRelic(t) {
    const e = mr.getContext(this.meetingMetadata.peerId);
    fetch(this.logsEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        meetingMetadata: xp(
          e,
          "sendOtelLogsToNewRelic",
          this.meetingMetadata,
          "meetingMetadata"
        ),
        serviceName: e.getValue("sdkName"),
        logs: t
      })
    }).catch((r) => {
      this.addLogInCurrentSpan(
        "error",
        "opentelemetry::sendOtelLogToNewRelic_failed",
        {
          error: gd(r)
        }
      ), this.logsCache.push(...t);
    });
  }
  processCachedLogs() {
    const t = this.logsCache.splice(0, 25);
    t != null && t.length && this.sendOtelLogsToNewRelic(t);
  }
  destruct() {
    clearInterval(this.logsProcessorTimer), this.processCachedLogs();
  }
};
var E = Yh;
h(E, "location", {
  country: void 0
});
function wC(s) {
  const t = D({}, s), e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ __name((l, p) => (e.has(l) || e.set(l, /* @__PURE__ */ new Set()), e.get(l).add(p), () => {
    var f;
    return (f = e.get(l)) == null ? void 0 : f.delete(p);
  }), "r"), i = /* @__PURE__ */ __name((l, p) => {
    var f;
    (f = e.get(l)) == null || f.delete(p);
  }, "i"), n = /* @__PURE__ */ __name((l) => {
    var p;
    (p = e.get(l)) == null || p.forEach((f) => {
      try {
        f(t[l]);
      } catch (S) {
      }
    });
  }, "n");
  return {
    subscribe: r,
    unsubscribe: i,
    notify: n,
    setValue: /* @__PURE__ */ __name((l, p, f = true) => {
      t[l] = p, f && n(l);
    }, "setValue"),
    getValue: /* @__PURE__ */ __name((l) => t[l], "getValue"),
    getAllValues: /* @__PURE__ */ __name(() => t, "getAllValues")
  };
}
__name(wC, "wC");
var bC = class {
  static {
    __name(this, "bC");
  }
  constructor() {
    h(this, "contexts", /* @__PURE__ */ new Map());
    h(this, "mostRecentPeerId", null);
  }
  createContext(t, e) {
    if (this.contexts.has(t))
      return this.contexts.get(t);
    const r = new E(), i = new ef();
    this.contexts.set(t, wC(e)), this.contexts.get(t).setValue("peerSessionStore", new wu(i));
    const n = new Rm();
    return n.setMaxListeners(50), this.contexts.get(t).setValue("logger", i), this.contexts.get(t).setValue("telemetry", r), this.contexts.get(t).setValue("callstats", n), this.contexts.get(t).setValue("flagsmith", F_()), this.mostRecentPeerId = t, this.contexts.get(t);
  }
  remapContext(t, e) {
    const r = e.getValue("peerId");
    r !== t && (e.setValue("peerId", t), this.mostRecentPeerId = t, this.contexts.set(t, e), this.contexts.delete(r));
  }
  getContext(t) {
    return this.contexts.get(t);
  }
  getMostRecentPeerId() {
    return this.mostRecentPeerId;
  }
};
var mr = new bC();
var kC = {
  "00": "DyteClient",
  "01": "Controller",
  "02": "RoomNodeClient",
  "03": "HiveNodeClient",
  "04": "SocketService",
  "05": "Chat",
  "06": "Plugin",
  "07": "Polls",
  "08": "Meta",
  "09": "Preset",
  10: "Recording",
  11: "Self",
  12: "Participant",
  13: "Spotlight",
  14: "Remote Request",
  15: "Webinar",
  16: "LocalMediaHandler",
  17: "End-End Encryption",
  18: "AI",
  19: "Livestream",
  20: "Stage"
};
var md = {
  "0000": "Internal exception.",
  "0001": "Failed to initialize.",
  "0002": "Failed to join room.",
  "0003": "Failed to leave room.",
  "0004": "Invalid auth token",
  "0010": "Browser not supported",
  "0011": "HTTP Network Error",
  "0012": "Websocket Network Error",
  "0013": "Rate Limited",
  "0100": "Internal exception",
  "0101": "Permission denied",
  "0102": "Prerequisite module missing",
  "0200": "Internal exception.",
  "0300": "Internal exception",
  "0400": "Internal exception",
  "0404": "Missing prerequisites to establish a websocket connection",
  "0500": "Internal exception",
  "0501": "Permission denied.",
  "0502": "Invalid message body.",
  "0503": "Text Message is too large",
  "0504": "Message not found by the given id",
  "0505": "Action not permitted without joining room",
  "0506": "Message search is disabled",
  "0510": "Invalid channel name.",
  "0600": "Internal exception",
  "0601": "Permission denied.",
  "0602": "Auth token not set for plugin",
  "0603": "Iframe was not provided",
  "0700": "Internal exception",
  "0705": "Action not permitted without joining room",
  "0800": "Internal exception",
  "0801": "Permission denied",
  "0900": "Internal exception",
  "0904": "Could not load preset",
  1e3: "Internal exception",
  1001: "Permission denied",
  1004: "Could not find specified recording",
  1005: "Action not permitted in given recording state",
  1100: "Internal exception",
  1101: "Permission denied",
  1102: "Unsupported",
  1103: "Name cannot be empty",
  1104: "No device selected while calling meeting.self.setDevice",
  1105: "Action not permitted without joining room",
  1106: "Can't set currently used device",
  1200: "Internal exception",
  1201: "Permission denied",
  1202: "Invalid page number was requested",
  1203: "Invalid participant count per page was requested",
  1204: "No participants exists with the given UserIds",
  1205: "Action not permitted without joining room",
  1206: "Manual Subscription Mode was not ACTIVATED",
  1207: "Invalid view mode",
  1208: "Manual Subscription not enabled for organization",
  1209: "Broadcast message type must be a non-empty string",
  1300: "Internal exception",
  1400: "Internal exception",
  1402: "No existing remote requests",
  1403: "No peer exists with given id",
  1500: "Internal exception",
  1600: "Internal exception",
  1601: "Failed to get audio track",
  1602: "Failed to get video track",
  1603: "Incorrect device",
  1604: "Failed to change device",
  1605: "Failed to get audio & video track",
  1606: "No audio input devices are available",
  1607: "No video input devices are available",
  1608: "No audio output devices (speakers) are available",
  1609: "Failed to fetch list of media devices",
  1610: "No media track exists",
  1611: "Failed to unmute track",
  1612: "Failed to get screenshare tracks",
  1701: "Crypto error",
  1800: "Internal exception",
  1801: "Can't fetch transcript file",
  1900: "Internal exception",
  1901: "Permission denied.",
  1902: "Livestream that has not yet started, can't be stopped",
  2e3: "Internal exception",
  2001: "Permission denied",
  2002: "Unsupported",
  2003: "Stage is disabled",
  2004: "Method not implemented",
  2005: "Action not permitted without joining room",
  2006: "Action not permitted in current stage status",
  9900: "Internal exception"
};
Object.keys(md).forEach((s) => {
  md[s] = `{${kC[s.slice(0, 2)]}} ${md[s]}`;
});
var R = class extends Error {
  static {
    __name(this, "R");
  }
  constructor(e, r, i = void 0, n = false) {
    super(e);
    h(this, "code");
    this.code = r, this.name = "DyteError", this.message = `[ERR${this.code}]: ${md[this.code]}
${this.message}`;
    try {
      let o = n && !!i;
      r && r.endsWith("00") && i && (o = true), o && i.error("DyteError", {
        error: { message: this.message, name: this.name, code: r }
      });
      const c = mr.getContext(mr.getMostRecentPeerId());
      if (c) {
        const d = c.getValue("onError");
        try {
          d(this);
        } catch (l) {
        }
      }
      typeof window != "undefined" && window.dispatchEvent(new CustomEvent("dyteError", {
        detail: this
      }));
    } catch (o) {
    }
  }
};
function rd(s, t, e, r) {
  if (r instanceof R)
    throw r;
  if (r instanceof t) {
    const i = new R(r.message, e);
    throw i.stack = r.stack, i;
  } else
    throw r;
}
__name(rd, "rd");
function Up(s, t, e) {
  if (!s.value) {
    const i = s.get, n = s.set;
    return i && (s.get = function() {
      try {
        return i.apply(this);
      } catch (o) {
        rd(this, t, e, o);
      }
    }), n && (s.set = function(o) {
      try {
        return n.apply(this, [o]);
      } catch (c) {
        rd(this, t, e, c);
      }
    }), s;
  }
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        rd(this, t, e, o);
      }) : n;
    } catch (n) {
      rd(this, t, e, n);
    }
  }, s;
}
__name(Up, "Up");
function IC(s, t) {
  return (e, r, i) => {
    if (i)
      return Up(i, s, t);
    for (const n of Reflect.ownKeys(e.prototype).filter(
      (o) => o !== "constructor"
    )) {
      const o = Object.getOwnPropertyDescriptor(
        e.prototype,
        n
      );
      (o.value instanceof Function || o.get instanceof Function || o.set instanceof Function) && Object.defineProperty(
        e.prototype,
        n,
        Up(o, s, t)
      );
    }
  };
}
__name(IC, "IC");
var ht = /* @__PURE__ */ __name((s) => IC(Error, s), "ht");
function AC(s) {
  let t = 0, e, r;
  if (!s)
    return t;
  for (e = 0; e < s.length; e += 1)
    r = s.charCodeAt(e), t = (t << 5) - t + r, t |= 0;
  return Math.abs(t) % 100 + 1;
}
__name(AC, "AC");
function MC() {
  Te.isElectron() && window.dyteElectronGetDisplayMediaSource && (navigator.mediaDevices.getDisplayMedia = () => u(this, null, function* () {
    const s = yield window.dyteElectronGetDisplayMediaSource(
      {
        types: ["window", "screen"]
      }
    );
    let t = [];
    if (s && (Array.isArray(s) ? t = s : t = [s]), !(t != null && t.length))
      throw new Error("Couldn't find any media source for screen share.");
    let e = t.find(
      (n) => {
        var o;
        return (o = n.id) == null ? void 0 : o.includes("screen");
      }
    );
    e = e != null ? e : t[0];
    const r = {
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: e.id
        }
      }
    };
    return yield navigator.mediaDevices.getUserMedia(
      r
    );
  }));
}
__name(MC, "MC");
var k = /* @__PURE__ */ ((s) => (s.NEW_PRODUCER = "NEW_PRODUCER", s.PRODUCER_TRACK_ENDED = "PRODUCER_TRACK_ENDED", s.ROOM_NODE_CONNECTION_ERROR = "ROOM_NODE_CONNECTION_ERROR", s.SOCKET_SERVICE_ROOM_JOINED = "SOCKET_SERVICE_ROOM_JOINED", s.SOCKET_SERVICE_RECONNECTED = "SOCKET_SERVICE_RECONNECTED", s.SOCKET_SERVICE_DISCONNECTED = "SOCKET_SERVICE_DISCONNECTED", s.SOCKET_SERVICE_FAILED = "SOCKET_SERVICE_FAILED", s.SOCKET_STATE_UPDATE = "SOCKET_STATE_UPDATE", s.ROOM_NODE_RECONNECTED = "ROOM_NODE_RECONNECTED", s.ROOM_NODE_DISCONNECTED = "ROOM_NODE_DISCONNECTED", s.ROOM_NODE_FAILED = "ROOM_NODE_FAILED", s.TRANSPORT_STATE_UPDATE = "TRANSPORT_STATE_UPDATE", s.PRODUCER_SCORE_UPDATE = "PRODUCER_SCORE_UPDATE", s.CONSUMER_SCORE_UPDATE = "CONSUMER_SCORE_UPDATE", s.PRODUCER_STATUS_UPDATE = "PRODUCER_STATUS_UPDATE", s.CONSUMER_STATUS_UPDATE = "CONSUMER_STATUS_UPDATE", s.LOW_PRODUCER_SCORE = "LOW_PRODUCER_SCORE", s.LOW_CONSUMER_SCORE = "LOW_CONSUMER_SCORE", s.MEDIA_PERMISSION_ERROR = "MEDIA_PERMISSION_ERROR", s.MEDIA_PERMISSION_UPDATE = "MEDIA_PERMISSION_UPDATE", s.WAITLISTED = "WAIT_LISTED", s.MESSAGE = "websocket/message", s.ROOM_MESSAGE = "websocket/room-message", s.PEER_JOINED_INTERNAL = "peer/joined-internal", s.PEER_CLOSED = "websocket/peer-closed", s.CONSUMER_CLOSED = "websocket/consumer-closed", s.CONSUMER_PAUSED = "websocket/consumer-paused", s.CONSUMER_RESUMED = "websocket/consumer-resumed", s.PRODUCER_CLOSED = "websocket/producer-closed", s.NEW_CONSUMER = "websocket/new-consumer", s.PRODUCER_SCORE = "websocket/producer-score", s.CONSUMER_SCORE = "websocket/consumer-score", s.PRODUCER_TOGGLE = "hive/producer-toggle", s.CONSUMER_TOGGLE = "hive/consumer-toggle", s.SELECTED_PEERS_DIFF = "hive/selected-peers-diff", s.UPDATE_ACTIVE = "media/update-active", s.RESET_PRODUCER_STATE = "hive/reset-producer-state", s.CF_TRANSPORT_STATE_CHANGED = "cf/transport-state-changed", s.CF_ROOM_REJOINING = "cf/room-rejoining", s.CF_ROOM_REJOIN_FAILED = "cf/room-rejoining-failed", s.CF_ROOM_REJOINED = "cf/room-rejoined", s.CF_TRANPSORT_RECONNECTING = "cf/transport-reconnecting", s.ROOM_STATE = "sockethub/room-state", s.PEER_DISPLAY_NAME_CHANGED = "hive/display-name-changed", s.GET_STAGE_REQUESTS = "GET_STAGE_REQUESTS", s.UPDATE_STAGE_REQUESTS = "UPDATE_STAGE_REQUESTS", s.KICK_PEER = "KICK_PEER", s.UPDATE_PEER_STAGE_STATUS = "UPDATE_PEER_STAGE_STATUS", s.JOIN_MEDIA_ROOM = "JOIN_MEDIA_ROOM", s.LEAVE_MEDIA_ROOM = "LEAVE_MEDIA_ROOM", s.PIP_HANGUP = "PIP_HANGUP", s.E2EE_ACTIVE_PRODUCER = "E2EE_ACTIVE_PRODUCER", s.E2EE_INACTIVE_PRODUCER = "E2EE_INACTIVE_PRODUCER", s.E2EE_ACTIVE_CONSUMER = "E2EE_ACTIVE_CONSUMER", s.E2EE_INACTIVE_CONSUMER = "E2EE_INACTIVE_CONSUMER", s.SOCKET_PEERS = "SOCKET_PEERS", s.UPDATE_PERMISSIONS = "UPDATE_PERMISSIONS", s.MAX_SPATIAL_LAYER_CHANGE = "MAX_SPATIAL_LAYER_CHANGE", s.MUTE_SELF = "MUTE_SELF", s.MUTE_SELF_VIDEO = "MUTE_SELF_VIDEO", s))(k || {});
var Jn = class extends ut.EventEmitter {
  static {
    __name(this, "Jn");
  }
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
};
var qt = class extends ut.EventEmitter {
  static {
    __name(this, "qt");
  }
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
};
function DC(s, t = 2) {
  return s.replace(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/g, "").trim().split(/\s+/).slice(0, t).map((i) => i.charAt(0)).join("").toUpperCase();
}
__name(DC, "DC");
var $p = 1080;
var Fp = 1920;
var OC = /* @__PURE__ */ __name((s, t, e, r, i, n) => {
  let o = 0.5, c = 0.5;
  const d = i, l = n, p = Math.min(e / d, r / l);
  let f = d * p, S = l * p, T, _, P, w, A = 1;
  return f < e && (A = e / f), Math.abs(A - 1) < 1e-14 && S < r && (A = r / S), f *= A, S *= A, P = d / (f / e), w = l / (S / r), T = (d - P) * o, _ = (l - w) * c, T < 0 && (T = 0), _ < 0 && (_ = 0), P > d && (P = d), w > l && (w = l), [T, _, P, w, s, t, e, r];
}, "OC");
var Kt;
var Si;
var rt;
var zt;
var be;
var ds;
var Ws;
var mt;
var Oe;
var Fa;
var Ha;
var Js;
var Ba;
var Qh = class extends qt {
  static {
    __name(this, "Qh");
  }
  constructor(e, r, i, n) {
    const o = e.getValue("logger");
    super(o);
    g(this, Kt, void 0);
    g(this, Si, void 0);
    g(this, rt, void 0);
    g(this, zt, void 0);
    g(this, be, {
      height: $p,
      width: Fp
    });
    g(this, ds, {
      brand: "#2160FD",
      background: "#141414",
      text: "#000000",
      videoBackground: "#191919",
      textOnBrand: "#EEEEEE"
    });
    g(this, Ws, void 0);
    g(this, mt, {});
    g(this, Oe, void 0);
    g(this, Fa, void 0);
    g(this, Ha, void 0);
    g(this, Js, void 0);
    g(this, Ba, false);
    h(this, "cleanupEventListeners", () => {
      a(this, Si).unsubscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).removeListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).removeListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).removeListener("roomLeft", () => this.disable());
    });
    h(this, "enablePipMediaControls", () => {
      this.mountAudioEvents(), this.mountVideoEvents();
    });
    h(this, "onSelfVideoUpdateListener", ({ videoEnabled: e2 }) => {
      this.updateMediaSession("CAMERA", e2);
    });
    h(this, "onSelfAudioUpdateListener", ({ audioEnabled: e2 }) => {
      this.updateMediaSession("MIC", e2);
    });
    h(this, "handlePipMediaControls", (e2) => {
      e2 === "ON_STAGE" ? this.enablePipMediaControls() : this.unmountEvents();
    });
    h(this, "eventCallback", (e2) => {
      e2 === "CAMERA" && (a(this, Oe).videoEnabled ? a(this, Oe).disableVideo() : a(this, Oe).enableVideo(), this.emit("cameraToggled")), e2 === "MIC" && (a(this, Oe).audioEnabled ? a(this, Oe).disableAudio() : a(this, Oe).enableAudio(), this.emit("micToggled")), e2 === "END" && (a(this, Si).getValue("peerSessionStore").emit(k.PIP_HANGUP), this.cleanupEventListeners(), this.emit("hangup"), this.cleanup());
    });
    h(this, "unmountEvents", () => {
      navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("togglemicrophone", void 0), navigator.mediaSession.setActionHandler("togglecamera", void 0));
    });
    h(this, "animate", () => {
      if (!this.isActive && a(this, Js) === "active") {
        this.disable(true);
        return;
      }
      a(this, mt) !== void 0 && this.paintCanvas(), a(this, Ws) !== void 0 && m(this, Ws, requestAnimationFrame(() => this.animate()));
    });
    h(this, "disable", (e2 = false) => {
      m(this, Js, "idle"), this.cleanupEventListeners(), cancelAnimationFrame(a(this, Ws)), e2 !== true && document.body.removeChild(a(this, rt)), m(this, Ws, void 0), document.pictureInPictureElement && document.exitPictureInPicture();
    });
    m(this, Si, e), m(this, Js, "idle"), m(this, Oe, r), m(this, ds, {
      brand: r.config.designTokens.colors.brand[500],
      background: r.config.designTokens.colors.background[1e3],
      text: r.config.designTokens.colors.text,
      videoBackground: r.config.designTokens.colors.videoBg,
      textOnBrand: r.config.designTokens.colors.textOnBrand
    }), i && this.setupIcon("pin", i), n && this.setupIcon("handRaise", n);
  }
  static _init(e, r) {
    return u(this, null, function* () {
      let i, n;
      try {
        i = yield sd(CC), n = yield sd(RC);
      } catch (o) {
      }
      return new Qh(e, r, i, n);
    });
  }
  setupIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, r);
          break;
        case "pin":
          m(this, Fa, r);
          break;
      }
    });
  }
  overrideIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, yield sd(r));
          break;
        case "pin":
          m(this, Fa, yield sd(r));
          break;
      }
    });
  }
  constructImage(e) {
    const r = new Image(), i = new Blob([e], { type: "image/svg+xml" }), n = window.URL.createObjectURL(i);
    return new Promise((o) => {
      r.onload = () => {
        o(r), window.URL.revokeObjectURL(n);
      }, r.src = n;
    });
  }
  createVideoContainer() {
    m(this, rt, document.createElement("div")), a(this, rt).style.width = "0.1px", a(this, rt).style.height = "0.1px", a(this, rt).style.overflow = "hidden", a(this, rt).style.position = "absolute", a(this, rt).style.bottom = "0", a(this, rt).style.right = "0", a(this, rt).style.opacity = "0", a(this, rt).appendChild(a(this, zt));
  }
  setupEventListeners() {
    a(this, Si).subscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).addListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).addListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).addListener("roomLeft", () => this.disable());
  }
  createCanvas() {
    const e = document.createElement("canvas");
    e.height = a(this, be).height, e.width = a(this, be).width, m(this, Kt, e);
  }
  setupMediaSessionEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("hangup", () => {
      this.eventCallback("END");
    }), this.mountAudioEvents(), this.mountVideoEvents());
  }
  mountAudioEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setMicrophoneActive === void 0 || a(this, Oe).permissions.canProduceAudio && navigator.mediaSession.setActionHandler("togglemicrophone", () => {
      this.eventCallback("MIC");
    });
  }
  mountVideoEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || a(this, Oe).permissions.canProduceVideo && navigator.mediaSession.setActionHandler("togglecamera", () => {
      this.eventCallback("CAMERA");
    });
  }
  getSources() {
    const r = Object.values(a(this, mt)).reduce(
      (i, n) => (i[n.pinned ? "pinned" : "regular"].push(n), i),
      { pinned: [], regular: [] }
    );
    return [...r.pinned, ...r.regular];
  }
  drawEmptyTile(e, r, i, n) {
    if (a(this, Kt) === void 0)
      return;
    const o = a(this, Kt).getContext("2d"), c = a(this, Kt).width, d = 0, l = 0, p = r - d * 2, f = i - d * 2, S = Math.floor(c / p), T = Math.floor(e / S), P = e % S * (p + d) + d, w = T * (f + d) + d, { displayText: A, image: N } = n != null ? n : {};
    o.fillStyle = A || N ? a(this, ds).videoBackground : a(this, ds).background, o.strokeStyle = a(this, ds).brand, o.beginPath(), o.moveTo(P + l, w), o.arcTo(P + p, w, P + p, w + l, l), o.arcTo(
      P + p,
      w + f,
      P + p - l,
      w + f,
      l
    ), o.arcTo(P, w + f, P, w + f - l, l), o.arcTo(P, w, P + l, w, l), o.closePath(), o.fill(), o.stroke();
    const H = p / 6, $ = p / 2 + P, F = f / 2 + w;
    o.save(), (A || N) && (o.beginPath(), o.arc($, F, H, 0, Math.PI * 2), o.fillStyle = a(this, ds).brand, o.fill(), N ? (o.clip(), o.drawImage(
      N,
      $ - H,
      F - H,
      H * 2,
      H * 2
    ), o.restore()) : A && (o.fillStyle = a(this, ds).textOnBrand, o.font = `${H / 2}px sans-serif`, o.textAlign = "center", o.textBaseline = "middle", o.fillText(A, $, F)), this.drawIcons(n, P, w, Math.max(p, f)));
  }
  drawIcons(e, r, i, n) {
    const o = Math.min(Math.max(n * 0.15, 100), 200), c = o * 0.2, d = o * 0.2;
    let l = r + c;
    const p = i + c, f = /* @__PURE__ */ __name((S) => {
      const T = a(this, Kt).getContext("2d");
      T.save(), T.fillStyle = a(this, ds).background, T.beginPath(), T.moveTo(l + d, p), T.arcTo(l + o, p, l + o, p + d, d), T.arcTo(
        l + o,
        p + o,
        l + o - d,
        p + o,
        d
      ), T.arcTo(l, p + o, l, p + o - d, d), T.arcTo(l, p, l + d, p, d), T.closePath(), T.fill(), typeof S == "string" ? (T.font = `${o / 1.5}px sans-serif`, T.fillStyle = a(this, ds).text, T.textAlign = "center", T.textBaseline = "top", T.fillText(S, o / 2 + l, p + c)) : T.drawImage(
        S,
        l + c,
        p + c,
        o - c * 2,
        o - c * 2
      ), l += o + c, T.restore();
    }, "f");
    e.pinned && f(a(this, Fa)), e.handRaised && f(a(this, Ha));
  }
  drawTile(e, r, i) {
    var l, p;
    if (a(this, Kt) === void 0)
      return;
    const n = a(this, Kt).getContext("2d"), o = this.getSources();
    let c = 0, d = 0;
    for (; c < a(this, be).height - 5; ) {
      let f = 0;
      for (; f < a(this, be).width - 5 && d < i; ) {
        if ((l = o[d]) != null && l.enabled) {
          const S = o[d].element, [T, _, P, w, A, N, H, $] = OC(
            f,
            c,
            e,
            r,
            S.videoWidth,
            S.videoHeight
          );
          ((p = S == null ? void 0 : S.classList) == null ? void 0 : p.contains("mirror")) ? (n.save(), n.scale(-1, 1), n.drawImage(S, T, _, P, w, -1 * A, N, -1 * H, $), n.restore()) : n.drawImage(S, T, _, P, w, A, N, H, $), this.drawIcons(o[d], A, N, Math.max(H, $));
        } else
          this.drawEmptyTile(d, e, r, o[d]);
        d += 1, f += e;
      }
      c += r;
    }
  }
  calcGridElemSize(e) {
    switch (e) {
      case 0:
      case 1:
        return [a(this, be).width, a(this, be).height];
      case 2:
        return [Math.floor(a(this, be).width / 2), a(this, be).height];
      case 3:
      case 4:
        return [Math.floor(a(this, be).width / 2), Math.floor(a(this, be).height / 2)];
      case 5:
      case 6:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
      case 7:
      case 8:
      case 9:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 3)];
      default:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
    }
  }
  paintCanvas() {
    let e = this.getSources().length;
    e !== 1 && (e = e % 2 > 0 ? e + 1 : e);
    const [r, i] = this.calcGridElemSize(e);
    this.drawTile(r, i, e);
  }
  isSupported() {
    var e;
    return !!window.chrome && document.pictureInPictureEnabled && ((e = a(this, Oe).config) == null ? void 0 : e.viewType) !== "LIVESTREAM";
  }
  get isActive() {
    return document.pictureInPictureElement !== null;
  }
  cleanup() {
    if (m(this, Ba, false), this.isSupported() && document.exitPictureInPicture !== void 0 && document.pictureInPictureElement !== null && document.exitPictureInPicture(), a(this, rt))
      try {
        document.body.removeChild(a(this, rt));
      } catch (e) {
      }
    this.removeAllSources(), m(this, Kt, void 0), m(this, zt, void 0), m(this, Ws, void 0);
  }
  init({ height: e, width: r } = {}) {
    if (!this.isSupported())
      throw this.logger.error("DytePip.unsupported"), new Error("Picture-in-picture is not available in this environment");
    if (a(this, Ba))
      return;
    m(this, Ba, true), this.createCanvas(), this.setupMediaSessionEvents();
    const i = document.createElement("video");
    m(this, be, {
      height: e != null ? e : $p,
      width: r != null ? r : Fp
    }), i.height = a(this, be).height, i.width = a(this, be).width, i.autoplay = true, i.muted = true, i.srcObject = a(this, Kt).captureStream(24), m(this, zt, i), a(this, zt).onloadedmetadata = () => {
      try {
        this.emit("pipStarted"), a(this, zt).onleavepictureinpicture = () => {
          this.emit("pipEnded");
        };
      } catch (n) {
        this.emit("pipEnded");
      }
    }, this.createVideoContainer(), this.paintCanvas();
  }
  updateMediaSession(e, r) {
    navigator.mediaSession !== void 0 && (e === "CAMERA" && navigator.mediaSession.setCameraActive !== void 0 && navigator.mediaSession.setCameraActive(r), e === "MIC" && navigator.mediaSession.setMicrophoneActive !== void 0 && navigator.mediaSession.setMicrophoneActive(r));
  }
  enableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = true);
  }
  disableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = false);
  }
  generateAvatar(e, r) {
    return u(this, null, function* () {
      if (!r)
        return;
      const i = new Image();
      try {
        const n = yield (yield fetch(r)).blob(), o = window.URL.createObjectURL(n);
        i.onload = () => {
          this.updateSource(e, { image: i }), window.URL.revokeObjectURL(o);
        }, i.src = o;
      } catch (n) {
        this.logger.error("DytePip::GenerateAvatar", {
          error: n
        });
      }
    });
  }
  addSource(e, r, i, n = false, o = void 0, c = void 0, d = false) {
    this.logger.debug("DytePIP::AddSource", {
      pip: {
        id: e,
        handRaised: d
      }
    }), a(this, mt)[e] = {
      id: e,
      element: r,
      enabled: i,
      pinned: n,
      displayText: o ? DC(o) : void 0,
      imageUrl: c,
      handRaised: d
    }, c && this.generateAvatar(e, c);
  }
  updateSource(e, r) {
    this.logger.info("DytePIP::UpdateSource", {
      pip: {
        id: e,
        handRaised: r.handRaised
      }
    });
    const i = a(this, mt)[e];
    i && (a(this, mt)[e] = D(D({}, i), r));
  }
  removeSource(e) {
    delete a(this, mt)[e];
  }
  removePinnedSource() {
    Object.values(a(this, mt)).forEach((r) => {
      r.pinned && this.removeSource(r.id);
    });
  }
  removeAllSources() {
    m(this, mt, {});
  }
  enable() {
    m(this, Js, "activating"), this.setupEventListeners(), this.updateMediaSession("CAMERA", a(this, Oe).videoEnabled), this.updateMediaSession("MIC", a(this, Oe).audioEnabled), document.body.appendChild(a(this, rt)), m(this, Ws, requestAnimationFrame(() => this.animate())), a(this, zt).onloadedmetadata = () => {
      a(this, zt).requestPictureInPicture().then(() => {
        m(this, Js, "active");
      });
    }, a(this, zt).readyState === 4 && a(this, zt).requestPictureInPicture().then(() => {
      m(this, Js, "active");
    });
  }
};
var Au = Qh;
Kt = /* @__PURE__ */ new WeakMap(), Si = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), be = /* @__PURE__ */ new WeakMap(), ds = /* @__PURE__ */ new WeakMap(), Ws = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), Oe = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), Js = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap();
var vr;
(function(s) {
  s[s.PUBLISHER = 0] = "PUBLISHER", s[s.SUBSCRIBER = 1] = "SUBSCRIBER";
})(vr || (vr = {}));
var xs;
(function(s) {
  s[s.AUDIO = 0] = "AUDIO", s[s.VIDEO = 1] = "VIDEO";
})(xs || (xs = {}));
var NC = class extends MessageType {
  static {
    __name(this, "NC");
  }
  constructor() {
    super("media.Codec", [
      {
        no: 1,
        name: "channels",
        kind: "scalar",
        opt: true,
        T: 5
      },
      {
        no: 2,
        name: "clock_rate",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "mime_type",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "sdp_fmtp_line",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "payload_type",
        kind: "scalar",
        opt: true,
        T: 13
      }
    ]);
  }
};
var df = new NC();
var VC = class extends MessageType {
  static {
    __name(this, "VC");
  }
  constructor() {
    super("media.HeaderExtension", [
      {
        no: 1,
        name: "direction",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "uri",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var LC = new VC();
var xC = class extends MessageType {
  static {
    __name(this, "xC");
  }
  constructor() {
    super("media.Fingerprint", [
      {
        no: 1,
        name: "algorithm",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new xC();
var UC = class extends MessageType {
  static {
    __name(this, "UC");
  }
  constructor() {
    super("media.SessionDescription", [
      { no: 1, name: "target", kind: "enum", T: /* @__PURE__ */ __name(() => ["media.Target", vr], "T") },
      {
        no: 2,
        name: "type",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "sdp",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Rs = new UC();
var $C = class extends MessageType {
  static {
    __name(this, "$C");
  }
  constructor() {
    super("media.ProducerPayload", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
      },
      {
        no: 4,
        name: "msid",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var FC = new $C();
var HC = class extends MessageType {
  static {
    __name(this, "HC");
  }
  constructor() {
    super("media.CreateTransportRequest", [
      {
        no: 1,
        name: "consuming",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "force_tcp",
        kind: "scalar",
        opt: true,
        T: 8
      },
      { no: 3, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") },
      {
        no: 4,
        name: "private_ice",
        kind: "scalar",
        opt: true,
        T: 8
      },
      { no: 5, name: "producers", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => FC, "T") }
    ]);
  }
};
var BC = new HC();
var qC = class extends MessageType {
  static {
    __name(this, "qC");
  }
  constructor() {
    super("media.AudioActivityRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "energy",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "silent",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var jC = new qC();
var GC = class extends MessageType {
  static {
    __name(this, "GC");
  }
  constructor() {
    super("media.CreateTransportResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") },
      {
        no: 3,
        name: "transcription_enabled",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 4,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var lf = new GC();
var WC = class extends MessageType {
  static {
    __name(this, "WC");
  }
  constructor() {
    super("media.RenegotiateRequest", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
var JC = new WC();
var KC = class extends MessageType {
  static {
    __name(this, "KC");
  }
  constructor() {
    super("media.RenegotiateResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
new KC();
var zC = class extends MessageType {
  static {
    __name(this, "zC");
  }
  constructor() {
    super("media.NestedScore", [
      {
        no: 1,
        name: "encoding_idx",
        kind: "scalar",
        T: 5
      },
      {
        no: 2,
        name: "rid",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "score",
        kind: "scalar",
        T: 5
      },
      {
        no: 4,
        name: "ssrc",
        kind: "scalar",
        T: 3,
        L: 0
      }
    ]);
  }
};
var YC = new zC();
var QC = class extends MessageType {
  static {
    __name(this, "QC");
  }
  constructor() {
    super("media.ProducerTrack", [
      {
        no: 1,
        name: "track_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "stream_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var XC = new QC();
var ZC = class extends MessageType {
  static {
    __name(this, "ZC");
  }
  constructor() {
    super("media.ProducerEntry", [
      {
        no: 1,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new ZC();
var eR = class extends MessageType {
  static {
    __name(this, "eR");
  }
  constructor() {
    super("media.ConsumerEntry", [
      {
        no: 1,
        name: "consuming_transport_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "consumer_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new eR();
var tR = class extends MessageType {
  static {
    __name(this, "tR");
  }
  constructor() {
    super("media.ProducerState", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "kind", kind: "enum", T: /* @__PURE__ */ __name(() => ["media.ProducerKind", xs], "T") },
      {
        no: 3,
        name: "pause",
        kind: "scalar",
        T: 8
      },
      {
        no: 4,
        name: "screen_share",
        kind: "scalar",
        T: 8
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 8, name: "codec", kind: "message", T: /* @__PURE__ */ __name(() => df, "T") }
    ]);
  }
};
var Jc = new tR();
var sR = class extends MessageType {
  static {
    __name(this, "sR");
  }
  constructor() {
    super("media.ConsumerState", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "producer_state", kind: "message", T: /* @__PURE__ */ __name(() => Jc, "T") },
      { no: 3, name: "producer_track", kind: "message", T: /* @__PURE__ */ __name(() => XC, "T") },
      {
        no: 4,
        name: "error_code",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var rR = new sR();
var iR = class extends MessageType {
  static {
    __name(this, "iR");
  }
  constructor() {
    super("media.ProducerIdToConsumerMap", [
      { no: 1, name: "map", kind: "map", K: 9, V: { kind: "message", T: /* @__PURE__ */ __name(() => rR, "T") } }
    ]);
  }
};
var uf = new iR();
var aR = class extends MessageType {
  static {
    __name(this, "aR");
  }
  constructor() {
    super("media.PeerRtpCapabilitites", [
      { no: 1, name: "sender", kind: "message", T: /* @__PURE__ */ __name(() => Bp, "T") },
      { no: 2, name: "receiver", kind: "message", T: /* @__PURE__ */ __name(() => Bp, "T") }
    ]);
  }
};
var hf = new aR();
var nR = class extends MessageType {
  static {
    __name(this, "nR");
  }
  constructor() {
    super("media.RtpCapability", [
      { no: 1, name: "codecs", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => df, "T") },
      { no: 2, name: "header_extensions", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => LC, "T") }
    ]);
  }
};
var Hp = new nR();
var oR = class extends MessageType {
  static {
    __name(this, "oR");
  }
  constructor() {
    super("media.RtpCapabilitites", [
      { no: 1, name: "audio", kind: "message", T: /* @__PURE__ */ __name(() => Hp, "T") },
      { no: 2, name: "video", kind: "message", T: /* @__PURE__ */ __name(() => Hp, "T") }
    ]);
  }
};
var Bp = new oR();
var cR = class extends MessageType {
  static {
    __name(this, "cR");
  }
  constructor() {
    super("media.PreferredCodec", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var dR = new cR();
var lR = class extends MessageType {
  static {
    __name(this, "lR");
  }
  constructor() {
    super("media.Simulcast", [
      {
        no: 1,
        name: "preferred_rid",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "priority_ordering",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "rid_not_available",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var pf = new lR();
var uR = class extends MessageType {
  static {
    __name(this, "uR");
  }
  constructor() {
    super("media.edge.GeoLocation", [
      {
        no: 1,
        name: "latitude",
        kind: "scalar",
        T: 2
      },
      {
        no: 2,
        name: "longitude",
        kind: "scalar",
        T: 2
      },
      {
        no: 3,
        name: "region",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var hR = new uR();
var pR = class extends MessageType {
  static {
    __name(this, "pR");
  }
  constructor() {
    super("media.edge.PeerJoinRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "prejoined",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 6,
        name: "user_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 7,
        name: "organization_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 8, name: "location", kind: "message", T: /* @__PURE__ */ __name(() => hR, "T") },
      { no: 9, name: "capabilities", kind: "message", T: /* @__PURE__ */ __name(() => hf, "T") }
    ]);
  }
};
var gR = new pR();
var mR = class extends MessageType {
  static {
    __name(this, "mR");
  }
  constructor() {
    super("media.edge.PeerJoinCompleteRequest", []);
  }
};
var fR = new mR();
var SR = class extends MessageType {
  static {
    __name(this, "SR");
  }
  constructor() {
    super("media.edge.PeerLeaveRequest", [
      {
        no: 1,
        name: "close_room",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var vR = new SR();
var yR = class extends MessageType {
  static {
    __name(this, "yR");
  }
  constructor() {
    super("media.edge.ConsumeMultipleProducerRequest", [
      {
        no: 1,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
new yR();
var TR = class extends MessageType {
  static {
    __name(this, "TR");
  }
  constructor() {
    super("media.edge.ConsumePeerRequest", [
      {
        no: 1,
        name: "producing_peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 3,
        name: "producer_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 4, name: "preferred_codec", kind: "message", T: /* @__PURE__ */ __name(() => dR, "T") },
      {
        no: 5,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 6, name: "simulcast", kind: "message", T: /* @__PURE__ */ __name(() => pf, "T") }
    ]);
  }
};
var ER = new TR();
var _R = class extends MessageType {
  static {
    __name(this, "_R");
  }
  constructor() {
    super("media.edge.ConsumePeersRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => ER, "T") },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var PR = new _R();
var CR = class extends MessageType {
  static {
    __name(this, "CR");
  }
  constructor() {
    super("media.edge.UpdateConsumerSimulcastConfigRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "simulcast", kind: "message", T: /* @__PURE__ */ __name(() => pf, "T") },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "mid",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var RR = new CR();
var wR = class extends MessageType {
  static {
    __name(this, "wR");
  }
  constructor() {
    super("media.edge.UpdateConsumersSimulcastConfigRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => RR, "T") },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var bR = new wR();
var kR = class extends MessageType {
  static {
    __name(this, "kR");
  }
  constructor() {
    super("media.edge.ProducerCreateRequest", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
      },
      { no: 4, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") },
      {
        no: 5,
        name: "msid",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 8,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var IR = new kR();
var AR = class extends MessageType {
  static {
    __name(this, "AR");
  }
  constructor() {
    super("media.edge.SelectedPeersRequest", []);
  }
};
new AR();
var MR = class extends MessageType {
  static {
    __name(this, "MR");
  }
  constructor() {
    super("media.edge.GlobalPeerPinningRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var DR = new MR();
var OR = class extends MessageType {
  static {
    __name(this, "OR");
  }
  constructor() {
    super("media.edge.ProducerToggleRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var id = new OR();
var NR = class extends MessageType {
  static {
    __name(this, "NR");
  }
  constructor() {
    super("media.edge.ConsumerToggleRequest", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
new NR();
var VR = class extends MessageType {
  static {
    __name(this, "VR");
  }
  constructor() {
    super("media.edge.ProducerCloseRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var LR = new VR();
var xR = class extends MessageType {
  static {
    __name(this, "xR");
  }
  constructor() {
    super("media.edge.ConsumerCloseRequest", [
      {
        no: 1,
        name: "consumer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      { no: 2, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") },
      {
        no: 3,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var UR = new xR();
var $R = class extends MessageType {
  static {
    __name(this, "$R");
  }
  constructor() {
    super("media.edge.KickPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new $R();
var FR = class extends MessageType {
  static {
    __name(this, "FR");
  }
  constructor() {
    super("media.edge.KickAllPeersRequest", [
      {
        no: 1,
        name: "propagate_kick_across_rooms",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var gf = new FR();
var HR = class extends MessageType {
  static {
    __name(this, "HR");
  }
  constructor() {
    super("media.edge.PeerDisplayNameEditRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var BR = new HR();
var qR = class extends MessageType {
  static {
    __name(this, "qR");
  }
  constructor() {
    super("media.edge.HostMediaControlForPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "audio",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "video",
        kind: "scalar",
        T: 8
      },
      {
        no: 4,
        name: "scree_share",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var jR = new qR();
var GR = class extends MessageType {
  static {
    __name(this, "GR");
  }
  constructor() {
    super("media.edge.HostMediaControlForAllPeerRequest", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var WR = new GR();
var JR = class extends MessageType {
  static {
    __name(this, "JR");
  }
  constructor() {
    super("media.edge.GetRoomStateResponse", [
      {
        no: 1,
        name: "display_title",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "locked_mode",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "room_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "current_peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "is_recording",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 7,
        name: "recorder_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 8,
        name: "pinned_peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var KR = new JR();
var zR = class extends MessageType {
  static {
    __name(this, "zR");
  }
  constructor() {
    super("media.edge.ErrorResponse", [
      {
        no: 1,
        name: "error_message",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "event_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var YR = new zR();
var QR = class extends MessageType {
  static {
    __name(this, "QR");
  }
  constructor() {
    super("media.edge.EmptyResponse", []);
  }
};
new QR();
var XR = class extends MessageType {
  static {
    __name(this, "XR");
  }
  constructor() {
    super("media.edge.RoomParticipants", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "producer_states", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Jc, "T") },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "user_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 5, name: "capabilities", kind: "message", T: /* @__PURE__ */ __name(() => hf, "T") }
    ]);
  }
};
var mf = new XR();
var ZR = class extends MessageType {
  static {
    __name(this, "ZR");
  }
  constructor() {
    super("media.edge.SelectedPeersResponse", [
      {
        no: 1,
        name: "audio_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "compulsory_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var Mu = new ZR();
var ew = class extends MessageType {
  static {
    __name(this, "ew");
  }
  constructor() {
    super("media.edge.SelectedPeersDiffEntry", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "priority",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var tw = new ew();
var sw = class extends MessageType {
  static {
    __name(this, "sw");
  }
  constructor() {
    super("media.edge.SelectedPeersDiffResponse", [
      { no: 1, name: "entries", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => tw, "T") }
    ]);
  }
};
var qp = new sw();
var rw = class extends MessageType {
  static {
    __name(this, "rw");
  }
  constructor() {
    super("media.edge.PeerJoinResponse", []);
  }
};
new rw();
var iw = class extends MessageType {
  static {
    __name(this, "iw");
  }
  constructor() {
    super("media.edge.PeerJoinCompleteResponse", [
      { no: 1, name: "room_state", kind: "message", T: /* @__PURE__ */ __name(() => KR, "T") },
      { no: 2, name: "participants", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => mf, "T") },
      { no: 3, name: "selected_peers", kind: "message", T: /* @__PURE__ */ __name(() => Mu, "T") },
      {
        no: 4,
        name: "max_preferred_streams",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var Du = new iw();
var aw = class extends MessageType {
  static {
    __name(this, "aw");
  }
  constructor() {
    super("media.edge.PeerLeaveResponse", [
      {
        no: 1,
        name: "closed",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var nw = new aw();
var ow = class extends MessageType {
  static {
    __name(this, "ow");
  }
  constructor() {
    super("media.edge.ConsumeMultipleProducerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: /* @__PURE__ */ __name(() => uf, "T") }
    ]);
  }
};
new ow();
var cw = class extends MessageType {
  static {
    __name(this, "cw");
  }
  constructor() {
    super("media.edge.ConsumePeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: /* @__PURE__ */ __name(() => uf, "T") },
      { no: 3, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
var dw = new cw();
var lw = class extends MessageType {
  static {
    __name(this, "lw");
  }
  constructor() {
    super("media.edge.ProducerCreateResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
      },
      { no: 4, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
var uw = new lw();
var hw = class extends MessageType {
  static {
    __name(this, "hw");
  }
  constructor() {
    super("media.edge.ProducerScoreResponse", [
      {
        no: 1,
        name: "responseid",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "score", kind: "message", T: /* @__PURE__ */ __name(() => YC, "T") }
    ]);
  }
};
new hw();
var pw = class extends MessageType {
  static {
    __name(this, "pw");
  }
  constructor() {
    super("media.edge.ActiveSpeakerResponse", [
      {
        no: 1,
        name: "responsepeer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "volume",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
new pw();
var gw = class extends MessageType {
  static {
    __name(this, "gw");
  }
  constructor() {
    super("media.edge.NoActiveSpeakerResponse", []);
  }
};
new gw();
var mw = class extends MessageType {
  static {
    __name(this, "mw");
  }
  constructor() {
    super("media.edge.ProducerToggleResponse", []);
  }
};
new mw();
var fw = class extends MessageType {
  static {
    __name(this, "fw");
  }
  constructor() {
    super("media.edge.ConsumerToggleResponse", []);
  }
};
new fw();
var Sw = class extends MessageType {
  static {
    __name(this, "Sw");
  }
  constructor() {
    super("media.edge.ProducerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
var vw = new Sw();
var yw = class extends MessageType {
  static {
    __name(this, "yw");
  }
  constructor() {
    super("media.edge.ConsumerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: /* @__PURE__ */ __name(() => Rs, "T") }
    ]);
  }
};
var Tw = new yw();
var Ew = class extends MessageType {
  static {
    __name(this, "Ew");
  }
  constructor() {
    super("media.edge.GlobalPeerPinningResponse", []);
  }
};
new Ew();
var _w = class extends MessageType {
  static {
    __name(this, "_w");
  }
  constructor() {
    super("media.edge.KickPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new _w();
var Pw = class extends MessageType {
  static {
    __name(this, "Pw");
  }
  constructor() {
    super("media.edge.KickAllPeersResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new Pw();
var Cw = class extends MessageType {
  static {
    __name(this, "Cw");
  }
  constructor() {
    super("media.edge.HostMediaControlForPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Rw = new Cw();
var ww = class extends MessageType {
  static {
    __name(this, "ww");
  }
  constructor() {
    super("media.edge.HostMediaControlForAllPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var bw = new ww();
var kw = class extends MessageType {
  static {
    __name(this, "kw");
  }
  constructor() {
    super("media.edge.PeerDisplayNameEditResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Iw = new kw();
var Aw = class extends MessageType {
  static {
    __name(this, "Aw");
  }
  constructor() {
    super("media.edge.PeerJoinBroadcastResponse", [
      { no: 1, name: "participant", kind: "message", T: /* @__PURE__ */ __name(() => mf, "T") }
    ]);
  }
};
var jp = new Aw();
var Mw = class extends MessageType {
  static {
    __name(this, "Mw");
  }
  constructor() {
    super("media.edge.TrackSubscriptionKind", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var Gp = new Mw();
var Dw = class extends MessageType {
  static {
    __name(this, "Dw");
  }
  constructor() {
    super("media.edge.TrackSubscription", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "webcam", kind: "message", T: /* @__PURE__ */ __name(() => Gp, "T") },
      { no: 3, name: "screenshare", kind: "message", T: /* @__PURE__ */ __name(() => Gp, "T") }
    ]);
  }
};
var Ow = new Dw();
var Nw = class extends MessageType {
  static {
    __name(this, "Nw");
  }
  constructor() {
    super("media.edge.PeerProducingTransportCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "transport_details", kind: "message", T: /* @__PURE__ */ __name(() => lf, "T") },
      { no: 3, name: "track_subscriptions", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Ow, "T") }
    ]);
  }
};
new Nw();
var Vw = class extends MessageType {
  static {
    __name(this, "Vw");
  }
  constructor() {
    super("media.edge.PeerProducerCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "producer_state", kind: "message", T: /* @__PURE__ */ __name(() => Jc, "T") }
    ]);
  }
};
var Lw = new Vw();
var xw = class extends MessageType {
  static {
    __name(this, "xw");
  }
  constructor() {
    super("media.edge.PeerProducerToggleBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "producer_state", kind: "message", T: /* @__PURE__ */ __name(() => Jc, "T") },
      {
        no: 3,
        name: "initiator_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Wp = new xw();
var Uw = class extends MessageType {
  static {
    __name(this, "Uw");
  }
  constructor() {
    super("media.edge.PeerProducerCloseBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "producer_state", kind: "message", T: /* @__PURE__ */ __name(() => Jc, "T") }
    ]);
  }
};
var $w = new Uw();
var Fw = class extends MessageType {
  static {
    __name(this, "Fw");
  }
  constructor() {
    super("media.edge.PeerLeaveBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Ou = new Fw();
var Hw = class extends MessageType {
  static {
    __name(this, "Hw");
  }
  constructor() {
    super("media.edge.GlobalPeerPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Jp = new Hw();
var Bw = class extends MessageType {
  static {
    __name(this, "Bw");
  }
  constructor() {
    super("media.edge.GlobalPeerUnPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new Bw();
var qw = class extends MessageType {
  static {
    __name(this, "qw");
  }
  constructor() {
    super("media.edge.RecordingStartedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new qw();
var jw = class extends MessageType {
  static {
    __name(this, "jw");
  }
  constructor() {
    super("media.edge.RecordingStoppedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new jw();
var Gw = class extends MessageType {
  static {
    __name(this, "Gw");
  }
  constructor() {
    super("media.edge.PeerDisplayNameEditBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new Gw();
var Ww = class extends MessageType {
  static {
    __name(this, "Ww");
  }
  constructor() {
    super("media.edge.PeerPingRequestBroadcastResponse", [
      {
        no: 1,
        name: "password",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new Ww();
var Jw = class extends MessageType {
  static {
    __name(this, "Jw");
  }
  constructor() {
    super("media.edge.MediaRoomTerminationBroadcastResponse", [
      {
        no: 1,
        name: "reason",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new Jw();
var Kw = class extends MessageType {
  static {
    __name(this, "Kw");
  }
  constructor() {
    super("socket.ai.MeetingTranscript", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "transcript",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "is_partial",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var lu = new Kw();
var zw = class extends MessageType {
  static {
    __name(this, "zw");
  }
  constructor() {
    super("socket.api.BaseSocketHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
new zw();
var Yw = class extends MessageType {
  static {
    __name(this, "Yw");
  }
  constructor() {
    super("socket.api.ErrorMessage", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        opt: true,
        T: 5
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Qw = new Yw();
var la;
(function(s) {
  s[s.BROWSER = 0] = "BROWSER", s[s.TRACK = 1] = "TRACK", s[s.COMPOSITE = 2] = "COMPOSITE";
})(la || (la = {}));
var pr;
(function(s) {
  s[s.UNSPECIFIED = 0] = "UNSPECIFIED", s[s.ON_STAGE = 1] = "ON_STAGE", s[s.APPROVED_STAGE = 2] = "APPROVED_STAGE", s[s.REQUESTED_STAGE = 3] = "REQUESTED_STAGE", s[s.OFF_STAGE = 4] = "OFF_STAGE";
})(pr || (pr = {}));
var Nu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.RECORDER = 1] = "RECORDER", s[s.LIVESTREAMER = 2] = "LIVESTREAMER";
})(Nu || (Nu = {}));
var Vu;
(function(s) {
  s[s.PEERS = 0] = "PEERS", s[s.ROOMS = 1] = "ROOMS";
})(Vu || (Vu = {}));
var Nd;
(function(s) {
  s[s.HIVE = 0] = "HIVE", s[s.CHAT = 1] = "CHAT", s[s.PING = 2] = "PING";
})(Nd || (Nd = {}));
var Xw = class extends MessageType {
  static {
    __name(this, "Xw");
  }
  constructor() {
    super("socket.room.PeerFlags", [
      {
        no: 1,
        name: "preset_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "recorder_type",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "hidden_participant",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var Zw = new Xw();
var eb = class extends MessageType {
  static {
    __name(this, "eb");
  }
  constructor() {
    super("socket.room.Peer", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      { no: 4, name: "stage_type", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.room.StageType", pr, "STAGE_TYPE_"], "T") },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 7,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 8,
        name: "waitlisted",
        kind: "scalar",
        T: 8
      },
      { no: 9, name: "flags", kind: "message", T: /* @__PURE__ */ __name(() => Zw, "T") }
    ]);
  }
};
var Gl = new eb();
var tb = class extends MessageType {
  static {
    __name(this, "tb");
  }
  constructor() {
    super("socket.room.PeerInfoResponse", [
      { no: 1, name: "peer", kind: "message", T: /* @__PURE__ */ __name(() => Gl, "T") }
    ]);
  }
};
var Ca = new tb();
var sb = class extends MessageType {
  static {
    __name(this, "sb");
  }
  constructor() {
    super("socket.room.PeerStatusUpdate", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "stage_type", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.room.StageType", pr, "STAGE_TYPE_"], "T") }
    ]);
  }
};
var Kp = new sb();
var rb = class extends MessageType {
  static {
    __name(this, "rb");
  }
  constructor() {
    super("socket.room.RoomPeersInfoRequest", [
      {
        no: 1,
        name: "seach_query",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "offset",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var ib = new rb();
var ab = class extends MessageType {
  static {
    __name(this, "ab");
  }
  constructor() {
    super("socket.room.RoomPeersInfoResponse", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Gl, "T") }
    ]);
  }
};
var uu = new ab();
var nb = class extends MessageType {
  static {
    __name(this, "nb");
  }
  constructor() {
    super("socket.room.RoomPeerCountResponse", [
      {
        no: 1,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 2
      }
    ]);
  }
};
var zp = new nb();
var ob = class extends MessageType {
  static {
    __name(this, "ob");
  }
  constructor() {
    super("socket.room.Room", [
      {
        no: 1,
        name: "room_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
      },
      { no: 5, name: "active_recordings", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => db, "T") },
      {
        no: 6,
        name: "room_uuid",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var ff = new ob();
var cb = class extends MessageType {
  static {
    __name(this, "cb");
  }
  constructor() {
    super("socket.room.ActiveRecording", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "recording_type", kind: "enum", T: /* @__PURE__ */ __name(() => ["common.RecordingType", la], "T") },
      {
        no: 3,
        name: "recording_status",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var db = new cb();
var lb = class extends MessageType {
  static {
    __name(this, "lb");
  }
  constructor() {
    super("socket.room.RoomInfoResponse", [
      { no: 1, name: "room", kind: "message", T: /* @__PURE__ */ __name(() => ff, "T") }
    ]);
  }
};
var Yp = new lb();
var ub = class extends MessageType {
  static {
    __name(this, "ub");
  }
  constructor() {
    super("socket.room.GetPeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Sf = new ub();
var hb = class extends MessageType {
  static {
    __name(this, "hb");
  }
  constructor() {
    super("socket.room.UpdatePeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
new hb();
var pb = class extends MessageType {
  static {
    __name(this, "pb");
  }
  constructor() {
    super("socket.room.JoinRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: /* @__PURE__ */ __name(() => Gl, "T") },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "organization_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "use_hive",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 6,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 12
      },
      { no: 7, name: "capabilities", kind: "enum", repeat: 1, T: /* @__PURE__ */ __name(() => ["socket.room.Capabilities", Nd, "CAPABILITIES_"], "T") },
      {
        no: 8,
        name: "timestamp",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
      }
    ]);
  }
};
var gb = new pb();
var mb = class extends MessageType {
  static {
    __name(this, "mb");
  }
  constructor() {
    super("socket.room.LeaveRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: /* @__PURE__ */ __name(() => Gl, "T") },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
      }
    ]);
  }
};
var fb = new mb();
var Sb = class extends MessageType {
  static {
    __name(this, "Sb");
  }
  constructor() {
    super("socket.room.UpdateRoomInfoRequest", [
      { no: 1, name: "room", kind: "message", T: /* @__PURE__ */ __name(() => ff, "T") }
    ]);
  }
};
new Sb();
var vb = class extends MessageType {
  static {
    __name(this, "vb");
  }
  constructor() {
    super("socket.room.GetConnectedRoomsDumpRequest", []);
  }
};
new vb();
var yb = class extends MessageType {
  static {
    __name(this, "yb");
  }
  constructor() {
    super("socket.room.ServiceError", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "code",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Ah = new yb();
var Tb = class extends MessageType {
  static {
    __name(this, "Tb");
  }
  constructor() {
    super("socket.room.ConnectedMeetingPeer", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Eb = new Tb();
var _b = class extends MessageType {
  static {
    __name(this, "_b");
  }
  constructor() {
    super("socket.room.ConnectedMeetingDump", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Eb, "T") }
    ]);
  }
};
var Qp = new _b();
var Pb = class extends MessageType {
  static {
    __name(this, "Pb");
  }
  constructor() {
    super("socket.room.GetConnectedRoomsDumpResponse", [
      { no: 1, name: "parent_meeting", kind: "message", T: /* @__PURE__ */ __name(() => Qp, "T") },
      { no: 2, name: "meetings", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Qp, "T") }
    ]);
  }
};
var Cb = new Pb();
var Rb = class extends MessageType {
  static {
    __name(this, "Rb");
  }
  constructor() {
    super("socket.room.CreateRoomRequestPayload", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var wb = new Rb();
var bb = class extends MessageType {
  static {
    __name(this, "bb");
  }
  constructor() {
    super("socket.room.CreateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => wb, "T") }
    ]);
  }
};
var kb = new bb();
var Ib = class extends MessageType {
  static {
    __name(this, "Ib");
  }
  constructor() {
    super("socket.room.CreateRoomResponsePayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 3, name: "error", kind: "message", T: /* @__PURE__ */ __name(() => Ah, "T") }
    ]);
  }
};
var Ab = new Ib();
var Mb = class extends MessageType {
  static {
    __name(this, "Mb");
  }
  constructor() {
    super("socket.room.CreateConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Ab, "T") }
    ]);
  }
};
var Xp = new Mb();
var Db = class extends MessageType {
  static {
    __name(this, "Db");
  }
  constructor() {
    super("socket.room.UpdateRoomRequestPayload", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Ob = new Db();
var Nb = class extends MessageType {
  static {
    __name(this, "Nb");
  }
  constructor() {
    super("socket.room.UpdateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Ob, "T") }
    ]);
  }
};
new Nb();
var Vb = class extends MessageType {
  static {
    __name(this, "Vb");
  }
  constructor() {
    super("socket.room.DisableRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Lb = new Vb();
var xb = class extends MessageType {
  static {
    __name(this, "xb");
  }
  constructor() {
    super("socket.room.DisableConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Lb, "T") }
    ]);
  }
};
var Ub = new xb();
var $b = class extends MessageType {
  static {
    __name(this, "$b");
  }
  constructor() {
    super("socket.room.DisableConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Bb, "T") }
    ]);
  }
};
var Fb = new $b();
var Hb = class extends MessageType {
  static {
    __name(this, "Hb");
  }
  constructor() {
    super("socket.room.DisableConnectedRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "status",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 4, name: "error", kind: "message", T: /* @__PURE__ */ __name(() => Ah, "T") }
    ]);
  }
};
var Bb = new Hb();
var qb = class extends MessageType {
  static {
    __name(this, "qb");
  }
  constructor() {
    super("socket.room.MovePeerPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var jb = new qb();
var Gb = class extends MessageType {
  static {
    __name(this, "Gb");
  }
  constructor() {
    super("socket.room.MovePeersBetweenRoomsRequest", [
      {
        no: 1,
        name: "source_meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "destination_meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => jb, "T") }
    ]);
  }
};
var Wb = new Gb();
var Jb = class extends MessageType {
  static {
    __name(this, "Jb");
  }
  constructor() {
    super("socket.room.MovedPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 3, name: "error", kind: "message", T: /* @__PURE__ */ __name(() => Ah, "T") }
    ]);
  }
};
var vf = new Jb();
var Kb = class extends MessageType {
  static {
    __name(this, "Kb");
  }
  constructor() {
    super("socket.room.MovePeersBetweenRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => vf, "T") }
    ]);
  }
};
new Kb();
var zb = class extends MessageType {
  static {
    __name(this, "zb");
  }
  constructor() {
    super("socket.room.TransferPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 2,
        name: "auth_token",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var Yb = new zb();
var Qb = class extends MessageType {
  static {
    __name(this, "Qb");
  }
  constructor() {
    super("socket.room.GetAllAddedParticipantsResponse", [
      { no: 1, name: "participants", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => ek, "T") }
    ]);
  }
};
var Xb = new Qb();
var Zb = class extends MessageType {
  static {
    __name(this, "Zb");
  }
  constructor() {
    super("socket.room.AddedParticipant", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var ek = new Zb();
var tk = class extends MessageType {
  static {
    __name(this, "tk");
  }
  constructor() {
    super("socket.room.RemoveParticipantsRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var yf = new tk();
var sk = class extends MessageType {
  static {
    __name(this, "sk");
  }
  constructor() {
    super("socket.room.BroadcastMessage", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 12
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 2
      },
      {
        no: 4,
        name: "ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      { no: 5, name: "broadcast_type", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.room.BroadcastType", Vu, "BROADCAST_TYPE_"], "T") }
    ]);
  }
};
var fo = new sk();
var rk = class extends MessageType {
  static {
    __name(this, "rk");
  }
  constructor() {
    super("socket.room.AcceptWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var ik = new rk();
var ak = class extends MessageType {
  static {
    __name(this, "ak");
  }
  constructor() {
    super("socket.room.DenyWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var nk = new ak();
var ok = class extends MessageType {
  static {
    __name(this, "ok");
  }
  constructor() {
    super("socket.room.WaitingRoomRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "preset_name",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var ck = new ok();
var dk = class extends MessageType {
  static {
    __name(this, "dk");
  }
  constructor() {
    super("socket.room.GetWaitingRoomRequests", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => ck, "T") }
    ]);
  }
};
var Zp = new dk();
var lk = class extends MessageType {
  static {
    __name(this, "lk");
  }
  constructor() {
    super("socket.room.GetRoomStageStateResponse", [
      {
        no: 1,
        name: "on_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "approved_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 3,
        name: "requested_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var eg = new lk();
var Lu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SKIP = 1] = "SKIP", s[s.ON_PRIVILEGED_USER_ENTRY = 2] = "ON_PRIVILEGED_USER_ENTRY", s[s.SKIP_ON_ACCEPT = 3] = "SKIP_ON_ACCEPT";
})(Lu || (Lu = {}));
var Qr;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.ALLOWED = 1] = "ALLOWED", s[s.NOT_ALLOWED = 2] = "NOT_ALLOWED", s[s.CAN_REQUEST = 3] = "CAN_REQUEST";
})(Qr || (Qr = {}));
var uk = class extends MessageType {
  static {
    __name(this, "uk");
  }
  constructor() {
    super("socket.preset.PollsPermissionUpdate", [
      {
        no: 1,
        name: "can_create",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 2,
        name: "can_vote",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 3,
        name: "can_view",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var hk = new uk();
var pk = class extends MessageType {
  static {
    __name(this, "pk");
  }
  constructor() {
    super("socket.preset.PluginsPermissionsUpdate", [
      {
        no: 1,
        name: "can_close",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 2,
        name: "can_start",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var gk = new pk();
var mk = class extends MessageType {
  static {
    __name(this, "mk");
  }
  constructor() {
    super("socket.preset.PublicChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 2,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 3,
        name: "files",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var fk = new mk();
var Sk = class extends MessageType {
  static {
    __name(this, "Sk");
  }
  constructor() {
    super("socket.preset.PrivateChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 2,
        name: "can_receive",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 3,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 4,
        name: "files",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var vk = new Sk();
var yk = class extends MessageType {
  static {
    __name(this, "yk");
  }
  constructor() {
    super("socket.preset.ChatPermissionUpdate", [
      { no: 1, name: "public", kind: "message", T: /* @__PURE__ */ __name(() => fk, "T") },
      { no: 2, name: "private", kind: "message", T: /* @__PURE__ */ __name(() => vk, "T") }
    ]);
  }
};
var Tk = new yk();
var Ek = class extends MessageType {
  static {
    __name(this, "Ek");
  }
  constructor() {
    super("socket.preset.ConnectedMeetingPermissionUpdate", [
      {
        no: 1,
        name: "can_alter_connected_meetings",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 2,
        name: "can_switch_to_parent_meeting",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 3,
        name: "can_switch_connected_meetings",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var _k = new Ek();
var Pk = class extends MessageType {
  static {
    __name(this, "Pk");
  }
  constructor() {
    super("socket.preset.StreamPermission", [
      { no: 1, name: "can_produce", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"], "T") },
      { no: 2, name: "can_consume", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"], "T") }
    ]);
  }
};
var hu = new Pk();
var Ck = class extends MessageType {
  static {
    __name(this, "Ck");
  }
  constructor() {
    super("socket.preset.MediaPermissionUpdate", [
      { no: 1, name: "video", kind: "message", T: /* @__PURE__ */ __name(() => hu, "T") },
      { no: 2, name: "audio", kind: "message", T: /* @__PURE__ */ __name(() => hu, "T") },
      { no: 3, name: "screenshare", kind: "message", T: /* @__PURE__ */ __name(() => hu, "T") }
    ]);
  }
};
var Rk = new Ck();
var wk = class extends MessageType {
  static {
    __name(this, "wk");
  }
  constructor() {
    super("socket.preset.PresetUpdates", [
      { no: 1, name: "polls", kind: "message", T: /* @__PURE__ */ __name(() => hk, "T") },
      { no: 2, name: "plugins", kind: "message", T: /* @__PURE__ */ __name(() => gk, "T") },
      { no: 3, name: "chat", kind: "message", T: /* @__PURE__ */ __name(() => Tk, "T") },
      {
        no: 4,
        name: "accept_waiting_requests",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 5,
        name: "can_accept_production_requests",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 6,
        name: "can_edit_display_name",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 7,
        name: "can_record",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 8,
        name: "can_livestream",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 9,
        name: "can_spotlight",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 10,
        name: "disable_participant_audio",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 11,
        name: "disable_participant_screensharing",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 12,
        name: "disable_participant_video",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 13,
        name: "kick_participant",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 14,
        name: "pin_participant",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 15,
        name: "transcription_enabled",
        kind: "scalar",
        opt: true,
        T: 8
      },
      { no: 16, name: "waiting_room_type", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.preset.WaitingRoomType", Lu, "WAITING_ROOM_TYPE_"], "T") },
      {
        no: 17,
        name: "is_recorder",
        kind: "scalar",
        opt: true,
        T: 8
      },
      { no: 18, name: "recorder_type", kind: "enum", opt: true, T: /* @__PURE__ */ __name(() => ["socket.room.RecorderType", Nu, "RECORDER_TYPE_"], "T") },
      {
        no: 19,
        name: "hidden_participant",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 20,
        name: "show_participant_list",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 21,
        name: "can_change_participant_permissions",
        kind: "scalar",
        opt: true,
        T: 8
      },
      { no: 22, name: "connected_meetings", kind: "message", T: /* @__PURE__ */ __name(() => _k, "T") },
      { no: 23, name: "media", kind: "message", T: /* @__PURE__ */ __name(() => Rk, "T") }
    ]);
  }
};
var Mh = new wk();
var bk = class extends MessageType {
  static {
    __name(this, "bk");
  }
  constructor() {
    super("socket.preset.ReadPeersPresetRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var kk = new bk();
var Ik = class extends MessageType {
  static {
    __name(this, "Ik");
  }
  constructor() {
    super("socket.preset.PeerPreset", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "preset",
        kind: "scalar",
        T: 12
      }
    ]);
  }
};
var Ak = new Ik();
var Mk = class extends MessageType {
  static {
    __name(this, "Mk");
  }
  constructor() {
    super("socket.preset.ReadPeersPresetResponse", [
      { no: 1, name: "peer_presets", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Ak, "T") }
    ]);
  }
};
var Dk = new Mk();
var Ok = class extends MessageType {
  static {
    __name(this, "Ok");
  }
  constructor() {
    super("socket.preset.UpdatePeerPreset", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        T: 9
      },
      { no: 2, name: "patch", kind: "message", T: /* @__PURE__ */ __name(() => Mh, "T") }
    ]);
  }
};
var Tf = new Ok();
var Nk = class extends MessageType {
  static {
    __name(this, "Nk");
  }
  constructor() {
    super("socket.preset.UpdatePeersPresetRequest", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Tf, "T") }
    ]);
  }
};
var Vk = new Nk();
var Lk = class extends MessageType {
  static {
    __name(this, "Lk");
  }
  constructor() {
    super("socket.preset.UpdatePeersPresetResponse", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Tf, "T") }
    ]);
  }
};
var tg = new Lk();
var xk = class extends MessageType {
  static {
    __name(this, "xk");
  }
  constructor() {
    super("socket.preset.PeerUserIDMap", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Uk = new xk();
var $k = class extends MessageType {
  static {
    __name(this, "$k");
  }
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetRequest", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Uk, "T") },
      { no: 2, name: "patch", kind: "message", T: /* @__PURE__ */ __name(() => Mh, "T") }
    ]);
  }
};
new $k();
var Fk = class extends MessageType {
  static {
    __name(this, "Fk");
  }
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetResponse", [
      { no: 2, name: "patch", kind: "message", T: /* @__PURE__ */ __name(() => Mh, "T") }
    ]);
  }
};
new Fk();
var Hk = class extends MessageType {
  static {
    __name(this, "Hk");
  }
  constructor() {
    super("socket.chat.ChatMessage", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "pinned",
        kind: "scalar",
        T: 8
      },
      {
        no: 6,
        name: "is_edited",
        kind: "scalar",
        T: 8
      },
      {
        no: 7,
        name: "payload_type",
        kind: "scalar",
        T: 5
      },
      {
        no: 8,
        name: "payload",
        kind: "scalar",
        T: 9
      },
      {
        no: 10,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
      },
      {
        no: 12,
        name: "created_at_ms",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
      },
      {
        no: 13,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 14,
        name: "channel_index",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var ya = new Hk();
var Bk = class extends MessageType {
  static {
    __name(this, "Bk");
  }
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var qk = new Bk();
var jk = class extends MessageType {
  static {
    __name(this, "jk");
  }
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => ya, "T") },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var Gk = new jk();
var Wk = class extends MessageType {
  static {
    __name(this, "Wk");
  }
  constructor() {
    super("socket.chat.GetChatMessagesResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => ya, "T") }
    ]);
  }
};
var Ef = new Wk();
var Jk = class extends MessageType {
  static {
    __name(this, "Jk");
  }
  constructor() {
    super("socket.chat.SendChatMessageToRoomRequest", [
      {
        no: 1,
        name: "payload_type",
        kind: "scalar",
        T: 5
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Kk = new Jk();
var zk = class extends MessageType {
  static {
    __name(this, "zk");
  }
  constructor() {
    super("socket.chat.SendChatMessageToRoomResponse", [
      { no: 1, name: "message", kind: "message", T: /* @__PURE__ */ __name(() => ya, "T") }
    ]);
  }
};
var pu = new zk();
var Yk = class extends MessageType {
  static {
    __name(this, "Yk");
  }
  constructor() {
    super("socket.chat.SendChatMessageToPeersRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var Qk = new Yk();
var Xk = class extends MessageType {
  static {
    __name(this, "Xk");
  }
  constructor() {
    super("socket.chat.SendChatMessageToPeersResponse", [
      { no: 1, name: "message", kind: "message", T: /* @__PURE__ */ __name(() => ya, "T") }
    ]);
  }
};
var gu = new Xk();
var Zk = class extends MessageType {
  static {
    __name(this, "Zk");
  }
  constructor() {
    super("socket.chat.SendChatMessageToChannelRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var eI = new Zk();
var tI = class extends MessageType {
  static {
    __name(this, "tI");
  }
  constructor() {
    super("socket.chat.SendChatMessageToChannelResponse", [
      { no: 1, name: "message", kind: "message", T: /* @__PURE__ */ __name(() => ya, "T") }
    ]);
  }
};
new tI();
var sI = class extends MessageType {
  static {
    __name(this, "sI");
  }
  constructor() {
    super("socket.chat.EditChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        opt: true,
        T: 5
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "pinned",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var rI = new sI();
var iI = class extends MessageType {
  static {
    __name(this, "iI");
  }
  constructor() {
    super("socket.chat.PinChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var aI = new iI();
var nI = class extends MessageType {
  static {
    __name(this, "nI");
  }
  constructor() {
    super("socket.chat.PinChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var ad = new nI();
var oI = class extends MessageType {
  static {
    __name(this, "oI");
  }
  constructor() {
    super("socket.chat.EditChatMessageResponse", [
      { no: 1, name: "message", kind: "message", T: /* @__PURE__ */ __name(() => ya, "T") }
    ]);
  }
};
var nd = new oI();
var cI = class extends MessageType {
  static {
    __name(this, "cI");
  }
  constructor() {
    super("socket.chat.DeleteChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var dI = new cI();
var lI = class extends MessageType {
  static {
    __name(this, "lI");
  }
  constructor() {
    super("socket.chat.DeleteChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var od = new lI();
var uI = class extends MessageType {
  static {
    __name(this, "uI");
  }
  constructor() {
    super("socket.chat.SearchChatMessagesRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "search_term",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var hI = new uI();
var pI = class extends MessageType {
  static {
    __name(this, "pI");
  }
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "channel_index",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var gI = new pI();
var mI = class extends MessageType {
  static {
    __name(this, "mI");
  }
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadResponse", [
      {
        no: 1,
        name: "channel_index",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var fI = new mI();
var SI = class extends MessageType {
  static {
    __name(this, "SI");
  }
  constructor() {
    super("socket.chat.CreateChatChannelRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var vI = new SI();
var yI = class extends MessageType {
  static {
    __name(this, "yI");
  }
  constructor() {
    super("socket.chat.UpdateChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 4,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "visibility",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "is_direct_message",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var TI = new yI();
var EI = class extends MessageType {
  static {
    __name(this, "EI");
  }
  constructor() {
    super("socket.chat.CreateChatChannelResponse", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
new EI();
var _I = class extends MessageType {
  static {
    __name(this, "_I");
  }
  constructor() {
    super("socket.chat.GetChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var PI = new _I();
var CI = class extends MessageType {
  static {
    __name(this, "CI");
  }
  constructor() {
    super("socket.chat.LatestMessageAndUnreadCount", [
      { no: 1, name: "message", kind: "message", T: /* @__PURE__ */ __name(() => ya, "T") },
      {
        no: 2,
        name: "unread_count",
        kind: "scalar",
        T: 4,
        L: 2
      }
    ]);
  }
};
var RI = new CI();
var wI = class extends MessageType {
  static {
    __name(this, "wI");
  }
  constructor() {
    super("socket.chat.ChatChannel", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
      },
      { no: 6, name: "latest_message_and_unread_count", kind: "message", T: /* @__PURE__ */ __name(() => RI, "T") },
      {
        no: 7,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var bI = new wI();
var kI = class extends MessageType {
  static {
    __name(this, "kI");
  }
  constructor() {
    super("socket.chat.GetChatChannelResponse", [
      { no: 1, name: "chat_channels", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => bI, "T") }
    ]);
  }
};
var Hs = new kI();
var II = class extends MessageType {
  static {
    __name(this, "II");
  }
  constructor() {
    super("socket.chat.ChannelMember", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var AI = new II();
var MI = class extends MessageType {
  static {
    __name(this, "MI");
  }
  constructor() {
    super("socket.chat.GetChatChannelMembersResponse", [
      { no: 1, name: "channel_members", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => AI, "T") }
    ]);
  }
};
var DI = new MI();
var OI = class extends MessageType {
  static {
    __name(this, "OI");
  }
  constructor() {
    super("socket.plugin.AddPluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var NI = new OI();
var VI = class extends MessageType {
  static {
    __name(this, "VI");
  }
  constructor() {
    super("socket.plugin.RemovePluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var LI = new VI();
var xI = class extends MessageType {
  static {
    __name(this, "xI");
  }
  constructor() {
    super("socket.plugin.EnablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var UI = new xI();
var $I = class extends MessageType {
  static {
    __name(this, "$I");
  }
  constructor() {
    super("socket.plugin.DisablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var FI = new $I();
var HI = class extends MessageType {
  static {
    __name(this, "HI");
  }
  constructor() {
    super("socket.plugin.EnablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var BI = new HI();
var qI = class extends MessageType {
  static {
    __name(this, "qI");
  }
  constructor() {
    super("socket.plugin.DisablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var jI = new qI();
var GI = class extends MessageType {
  static {
    __name(this, "GI");
  }
  constructor() {
    super("socket.plugin.PluginEventToRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
      }
    ]);
  }
};
var WI = new GI();
var JI = class extends MessageType {
  static {
    __name(this, "JI");
  }
  constructor() {
    super("socket.plugin.PluginEventToPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 3,
        name: "plugin_data",
        kind: "scalar",
        T: 12
      }
    ]);
  }
};
var KI = new JI();
var zI = class extends MessageType {
  static {
    __name(this, "zI");
  }
  constructor() {
    super("socket.plugin.StoreKeys", [
      {
        no: 1,
        name: "store_key",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 12
      }
    ]);
  }
};
var Dh = new zI();
var YI = class extends MessageType {
  static {
    __name(this, "YI");
  }
  constructor() {
    super("socket.plugin.PluginStoreInsertKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "insert_keys", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Dh, "T") }
    ]);
  }
};
var sg = new YI();
var QI = class extends MessageType {
  static {
    __name(this, "QI");
  }
  constructor() {
    super("socket.plugin.PluginStoreGetKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "get_keys", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Dh, "T") }
    ]);
  }
};
var XI = new QI();
var ZI = class extends MessageType {
  static {
    __name(this, "ZI");
  }
  constructor() {
    super("socket.plugin.PluginStoreDeleteKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "delete_keys", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Dh, "T") }
    ]);
  }
};
var eA = new ZI();
var tA = class extends MessageType {
  static {
    __name(this, "tA");
  }
  constructor() {
    super("socket.plugin.PluginStoreDeleteRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var sA = new tA();
var rA = class extends MessageType {
  static {
    __name(this, "rA");
  }
  constructor() {
    super("socket.plugin.EnablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "enabled_by",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var xu = new rA();
var iA = class extends MessageType {
  static {
    __name(this, "iA");
  }
  constructor() {
    super("socket.plugin.EnablePluginsResponse", [
      { no: 1, name: "plugins", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => xu, "T") }
    ]);
  }
};
var aA = new iA();
var nA = class extends MessageType {
  static {
    __name(this, "nA");
  }
  constructor() {
    super("socket.plugin.DisablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "disabled_by",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var rg = new nA();
var oA = class extends MessageType {
  static {
    __name(this, "oA");
  }
  constructor() {
    super("socket.plugin.PluginStoreItem", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "store_key",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "payload",
        kind: "scalar",
        T: 12
      }
    ]);
  }
};
var cA = new oA();
var dA = class extends MessageType {
  static {
    __name(this, "dA");
  }
  constructor() {
    super("socket.plugin.PluginStoreResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "store_items", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => cA, "T") }
    ]);
  }
};
var ig = new dA();
var lA = class extends MessageType {
  static {
    __name(this, "lA");
  }
  constructor() {
    super("socket.plugin.PluginEventResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
      }
    ]);
  }
};
var ag = new lA();
var uA = class extends MessageType {
  static {
    __name(this, "uA");
  }
  constructor() {
    super("socket.livestreaming.LiveStreamingEvent", [
      {
        no: 1,
        name: "livestream_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "playback_url",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "org_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 7,
        name: "room_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 8,
        name: "room_uuid",
        kind: "scalar",
        T: 9
      },
      {
        no: 9,
        name: "status",
        kind: "scalar",
        T: 9
      },
      {
        no: 10,
        name: "manual_ingest",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var ng = new uA();
var hA = class extends MessageType {
  static {
    __name(this, "hA");
  }
  constructor() {
    super("socket.livestreaming.GetStagePeersResponse", [
      {
        no: 1,
        name: "stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var og = new hA();
var pA = class extends MessageType {
  static {
    __name(this, "pA");
  }
  constructor() {
    super("socket.livestreaming.StageRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var gA = new pA();
var mA = class extends MessageType {
  static {
    __name(this, "mA");
  }
  constructor() {
    super("socket.livestreaming.GetStageRequestsResponse", [
      { no: 1, name: "stage_requests", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => gA, "T") }
    ]);
  }
};
var mu = new mA();
var fA = class extends MessageType {
  static {
    __name(this, "fA");
  }
  constructor() {
    super("socket.livestreaming.GrantStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var SA = new fA();
var vA = class extends MessageType {
  static {
    __name(this, "vA");
  }
  constructor() {
    super("socket.livestreaming.DenyStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var yA = new vA();
var TA = class extends MessageType {
  static {
    __name(this, "TA");
  }
  constructor() {
    super("socket.livestreaming.LeaveStageRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var cg = new TA();
var EA = class extends MessageType {
  static {
    __name(this, "EA");
  }
  constructor() {
    super("socket.polls.Poll", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "created_by",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "created_by_user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "question",
        kind: "scalar",
        T: 9
      },
      { no: 5, name: "options", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => PA, "T") },
      {
        no: 6,
        name: "hide_votes",
        kind: "scalar",
        T: 8
      },
      {
        no: 7,
        name: "anonymous",
        kind: "scalar",
        T: 8
      },
      {
        no: 8,
        name: "votes",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var _f = new EA();
var _A = class extends MessageType {
  static {
    __name(this, "_A");
  }
  constructor() {
    super("socket.polls.PollOption", [
      {
        no: 1,
        name: "text",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
      },
      { no: 3, name: "votes", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => RA, "T") }
    ]);
  }
};
var PA = new _A();
var CA = class extends MessageType {
  static {
    __name(this, "CA");
  }
  constructor() {
    super("socket.polls.PollVote", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var RA = new CA();
var wA = class extends MessageType {
  static {
    __name(this, "wA");
  }
  constructor() {
    super("socket.polls.NewPollRequest", [
      {
        no: 1,
        name: "question",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "options",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 3,
        name: "anonymous",
        kind: "scalar",
        T: 8
      },
      {
        no: 4,
        name: "hide_votes",
        kind: "scalar",
        T: 8
      },
      {
        no: 5,
        name: "created_by",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 6,
        name: "created_by_user_id",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
};
var bA = new wA();
var kA = class extends MessageType {
  static {
    __name(this, "kA");
  }
  constructor() {
    super("socket.polls.VotePollRequest", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "index",
        kind: "scalar",
        T: 4,
        L: 2
      }
    ]);
  }
};
var IA = new kA();
var AA = class extends MessageType {
  static {
    __name(this, "AA");
  }
  constructor() {
    super("socket.polls.UpdatePollResponse", [
      { no: 1, name: "poll", kind: "message", T: /* @__PURE__ */ __name(() => _f, "T") }
    ]);
  }
};
var fu = new AA();
var MA = class extends MessageType {
  static {
    __name(this, "MA");
  }
  constructor() {
    super("socket.polls.GetPollsResponse", [
      { no: 1, name: "polls", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => _f, "T") }
    ]);
  }
};
var DA = new MA();
var OA = class extends MessageType {
  static {
    __name(this, "OA");
  }
  constructor() {
    super("socket.recording.RecordingEvent", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
      },
      { no: 3, name: "recording_type", kind: "enum", T: /* @__PURE__ */ __name(() => ["common.RecordingType", la], "T") }
    ]);
  }
};
var dg = new OA();
var NA = class extends MessageType {
  static {
    __name(this, "NA");
  }
  constructor() {
    super("google.protobuf.Timestamp", [
      {
        no: 1,
        name: "seconds",
        kind: "scalar",
        T: 3,
        L: 0
      },
      {
        no: 2,
        name: "nanos",
        kind: "scalar",
        T: 5
      }
    ]);
  }
  now() {
    const t = this.create(), e = Date.now();
    return t.seconds = PbLong.from(Math.floor(e / 1e3)).toBigInt(), t.nanos = e % 1e3 * 1e6, t;
  }
  toDate(t) {
    return new Date(PbLong.from(t.seconds).toNumber() * 1e3 + Math.ceil(t.nanos / 1e6));
  }
  fromDate(t) {
    const e = this.create(), r = t.getTime();
    return e.seconds = PbLong.from(Math.floor(r / 1e3)).toBigInt(), e.nanos = r % 1e3 * 1e6, e;
  }
  internalJsonWrite(t, e) {
    let r = PbLong.from(t.seconds).toNumber() * 1e3;
    if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (t.nanos < 0)
      throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
    let i = "Z";
    if (t.nanos > 0) {
      let n = (t.nanos + 1e9).toString().substring(1);
      n.substring(3) === "000000" ? i = "." + n.substring(0, 3) + "Z" : n.substring(6) === "000" ? i = "." + n.substring(0, 6) + "Z" : i = "." + n + "Z";
    }
    return new Date(r).toISOString().replace(".000Z", i);
  }
  internalJsonRead(t, e, r) {
    if (typeof t != "string")
      throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(t) + ".");
    let i = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!i)
      throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
    let n = Date.parse(i[1] + "-" + i[2] + "-" + i[3] + "T" + i[4] + ":" + i[5] + ":" + i[6] + (i[8] ? i[8] : "Z"));
    if (Number.isNaN(n))
      throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
    if (n < Date.parse("0001-01-01T00:00:00Z") || n > Date.parse("9999-12-31T23:59:59Z"))
      throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    return r || (r = this.create()), r.seconds = PbLong.from(n / 1e3).toBigInt(), r.nanos = 0, i[7] && (r.nanos = parseInt("1" + i[7] + "0".repeat(9 - i[7].length)) - 1e9), r;
  }
};
new NA();
var VA = class extends MessageType {
  static {
    __name(this, "VA");
  }
  constructor() {
    super("common.BaseHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 8
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 9,
        name: "room_object_id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 10,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 11,
        name: "use_start_session",
        kind: "scalar",
        opt: true,
        T: 8
      }
    ]);
  }
};
var Uu = new VA();
var LA = class extends MessageType {
  static {
    __name(this, "LA");
  }
  constructor() {
    super("common.BulkedHubMessage", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Uu, "T") }
    ]);
  }
};
new LA();
var xA = class extends MessageType {
  static {
    __name(this, "xA");
  }
  constructor() {
    super("common.CFWorkersResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Uu, "T") },
      { no: 2, name: "broadcast_responses", kind: "message", repeat: 1, T: /* @__PURE__ */ __name(() => Uu, "T") }
    ]);
  }
};
new xA();
var UA = 0;
var $A = 1;
var FA = 2;
var HA = 3;
var BA = 4;
var qA = 5;
var jA = {
  getPeerInfo: 0,
  updatePeerInfo: 1,
  getRoomPeersInfo: 2,
  joinRoom: 3,
  leaveRoom: 4,
  getRoomInfo: 5,
  updateRoomInfo: 6,
  closeRoom: 7,
  startedLivestream: 8,
  stoppedLivestream: 9,
  erroredLivestream: 10,
  getStagePeers: 11,
  getStageRequests: 12,
  requestStageAccess: 13,
  cancelStageRequest: 14,
  grantStageAccess: 15,
  denyStageAccess: 16,
  roomPeerCount: 17,
  joinStage: 18,
  leaveStage: 19,
  getConnectedRoomsDump: 20,
  createConnectedRooms: 21,
  deleteConnectedRooms: 22,
  movePeers: 23,
  transferPeer: 24,
  movedPeer: 25,
  connectedRoomsUpdated: 26,
  connectedRoomsDeleted: 27,
  getAllAddedParticipants: 28,
  broadcastMessage: 29,
  kick: 30,
  kickAll: 31,
  transcript: 32,
  getWaitingRoomRequests: 33,
  acceptWaitingRoomRequests: 34,
  waitingRoomRequestAccepted: 35,
  denyWaitingRoomRequests: 36,
  waitingRoomRequestDenied: 37,
  peerStageStatusUpdate: 38,
  broadcastToEntity: 39,
  recordingStarted: 40,
  recordingStopped: 41,
  recordingPaused: 42,
  getRoomStageState: 43,
  livestreamingInvoked: 44
};
var GA = {
  getMessages: 0,
  sendMessageToRoom: 1,
  sendMessageToPeers: 2,
  editMessage: 3,
  deleteMessage: 4,
  getPaginatedMessages: 5,
  sendMessageToChannel: 6,
  searchChannelMessages: 7,
  getAllChatChannels: 8,
  markChannelIndexAsRead: 9,
  pinMessage: 10
};
var WA = {
  getPlugins: 0,
  addPlugin: 1,
  enablePluginForRoom: 2,
  disablePluginForPeers: 3,
  enablePluginForPeers: 4,
  disablePluginForRoom: 5,
  removePlugin: 6,
  customPluginEventToRoom: 7,
  customPluginEventToPeers: 8,
  storeInsertKeys: 9,
  storeGetKeys: 10,
  storeDeleteKeys: 11,
  storeDelete: 12
};
var JA = {
  createPoll: 0,
  getPolls: 1,
  votePoll: 2,
  updatePoll: 3
};
var Pf = {
  unknown: 0,
  createWebRTCTransport: 1,
  produce: 2,
  consume: 3,
  toggleProducer: 4,
  toggleConsumer: 5,
  closeProducer: 6,
  closeConsumer: 7,
  updateConsumersSimulcastConfig: 8,
  joinRoom: 16,
  leaveRoom: 17,
  selectedPeer: 18,
  globalPinPeer: 19,
  selfJoinComplete: 20,
  peerJoinedBroadcast: 25,
  peerLeaveBroadcast: 26,
  peerProducerCreateBroadcast: 27,
  peerProducerToggleBroadcast: 28,
  peerProducerCloseBroadcast: 29,
  globalPeerPinBroadcast: 30,
  recordingStartedBroadcast: 31,
  recordingStoppedBroadcast: 32,
  peerDisplayNameEditBroadcast: 33,
  mediaRoomTerminationBroadcastResponse: 36,
  selectedPeerDiff: 40,
  renegotiateSessionDescription: 50,
  errorResponse: 60,
  kickPeer: 90,
  kickAll: 91,
  changeDisplayName: 92,
  hostControlPeer: 93,
  hostControlAllPeers: 94,
  audioActivity: 100
};
var KA = {
  createChatChannel: 0,
  getChatChannel: 1,
  deprecatedGetAllChatChannels: 2,
  getChannelMembers: 3,
  updateChatChannel: 4
};
var zA = {
  getUserPresets: 0,
  updateUserPreset: 1
};
function Kn(s, t) {
  return Object.keys(t).reduce((e, r) => (e[r] = (s << 16) + t[r], e), {});
}
__name(Kn, "Kn");
function Cf(s, t) {
  return Object.keys(s).reduce((e, r) => (e[r] = t | s[r], e), {});
}
__name(Cf, "Cf");
var x = Kn(UA, jA);
var Re = Kn($A, GA);
var W = Kn(
  FA,
  WA
);
var qs = Kn(HA, JA);
var pi = Kn(
  BA,
  KA
);
var is = Cf(Pf, 16777216);
var Ts = Cf(Pf, 50331648);
var fd = Kn(
  qA,
  zA
);
var YA = Object.defineProperty;
var QA = Object.getOwnPropertyDescriptor;
var Oh = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? QA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && YA(t, e, i), i;
}, "Oh");
var Mr;
var qa;
var bg;
var $u = (bg = class {
  static {
    __name(this, "bg");
  }
  constructor(s, t) {
    g(this, Mr, void 0);
    g(this, qa, void 0);
    m(this, Mr, t), m(this, qa, s);
  }
  get telemetry() {
    return a(this, qa).getValue("telemetry");
  }
  get logger() {
    return a(this, qa).getValue("logger");
  }
  createChannel(s, t, e, r = "public", i = false) {
    return u(this, null, function* () {
      const n = {
        displayName: s,
        targetUserIds: t,
        displayPictureUrl: e,
        visibility: r,
        isDirectMessage: i
      };
      i && (n.visibility = "private");
      const o = yield a(this, Mr).sendMessagePromise(
        pi.createChatChannel,
        vI.toBinary(n)
      ), c = Hs.fromBinary(
        o.payload
      ).chatChannels;
      return $u.formatChannel(c[0]);
    });
  }
  updateChannel(s, t) {
    return u(this, null, function* () {
      const e = yield a(this, Mr).sendMessagePromise(
        pi.updateChatChannel,
        TI.toBinary({
          chatChannelId: s,
          targetUserIds: t.memberIds,
          displayName: t.displayName,
          displayPictureUrl: t.displayPictureUrl,
          visibility: t.visibility
        })
      ), r = Hs.fromBinary(
        e.payload
      ).chatChannels;
      return $u.formatChannel(r[0]);
    });
  }
  static formatChannel(s) {
    var r;
    const { latestMessageAndUnreadCount: t } = s, e = B(D({}, s), {
      id: s.chatChannelId,
      memberIds: s.targetUserIds,
      unreadCount: (r = t == null ? void 0 : t.unreadCount) != null ? r : 0
    });
    return t != null && t.message && (e.latestMessage = Es.formatSocketServiceMessage(
      t.message
    )), delete e.chatChannelId, delete e.targetUserIds, delete e.latestMessageAndUnreadCount, e;
  }
  getChannelMembers(s) {
    return u(this, null, function* () {
      try {
        const t = yield a(this, Mr).sendMessagePromise(
          pi.getChannelMembers,
          PI.toBinary({ chatChannelId: s })
        );
        return DI.fromBinary(t.payload).channelMembers.map((i) => {
          var n = i, { id: e } = n, r = ho(n, ["id"]);
          return B(D({}, r), { userId: e });
        });
      } catch (t) {
        return [];
      }
    });
  }
  on(s, t) {
    let e, r;
    switch (s) {
      case pi.createChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
      case pi.updateChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
    }
    if (!e) {
      this.logger.warn(
        `ChatChannelSocketHandler::Event ${s} is not recognized`
      );
      return;
    }
    a(this, Mr).on(s, ({ payload: i }) => {
      let n = r;
      try {
        n = e(i);
      } catch (o) {
        this.logger.error("ChatChannelSocketHandler::on::binary_decode_error", {
          error: o
        });
      }
      return t(n);
    });
  }
}, Mr = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), bg);
var pa = $u;
Oh([
  E.trace("ChatChannelHandler.createChannel")
], pa.prototype, "createChannel", 1);
Oh([
  E.trace("ChatChannelHandler.updateChannel")
], pa.prototype, "updateChannel", 1);
Oh([
  E.trace("ChatChannelHandler.getChannelMembers")
], pa.prototype, "getChannelMembers", 1);
var XA = Object.defineProperty;
var ZA = Object.getOwnPropertyDescriptor;
var ws = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? ZA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && XA(t, e, i), i;
}, "ws");
var _t = /* @__PURE__ */ ((s) => (s[s.TEXT = 0] = "TEXT", s[s.IMAGE = 1] = "IMAGE", s[s.FILE = 2] = "FILE", s[s.CUSTOM = 3] = "CUSTOM", s))(_t || {});
var it;
var ja;
var as = class {
  static {
    __name(this, "as");
  }
  constructor(t, e) {
    g(this, it, void 0);
    g(this, ja, void 0);
    m(this, it, e), m(this, ja, t);
  }
  get telemetry() {
    return a(this, ja).getValue("telemetry");
  }
  get logger() {
    return a(this, ja).getValue("logger");
  }
  getChatMessages() {
    return a(this, it).sendMessagePromise(Re.getMessages);
  }
  getChatMessagesPaginated(t, e, r, i = 0, n = "") {
    return u(this, null, function* () {
      const o = {
        timeStamp: t,
        size: e,
        from: i,
        reversed: r,
        channelId: n
      }, c = yield a(this, it).sendMessagePromise(
        Re.getPaginatedMessages,
        qk.toBinary(o)
      );
      return c.payload ? Gk.fromBinary(
        c.payload
      ) : {
        messages: [],
        next: false
      };
    });
  }
  sendMessageToRoom(t, e) {
    const r = {
      payloadType: e,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToRoom,
      Kk.toBinary(r)
    );
  }
  sendMessageToPeers(t, e, r) {
    const i = {
      payloadType: e,
      peerIds: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToPeers,
      Qk.toBinary(i)
    );
  }
  sendMessageToChannel(t, e, r) {
    const i = {
      payloadType: e,
      channelId: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToChannel,
      eI.toBinary(i)
    );
  }
  sendMessage(t, e, r, i) {
    if (i && this.sendMessageToChannel(t, e, i), r && r.length > 0) {
      this.sendMessageToPeers(t, e, r);
      return;
    }
    this.sendMessageToRoom(t, e);
  }
  editMessage(t, e, r, i, n) {
    return u(this, null, function* () {
      const o = {
        chatId: t,
        payloadType: r,
        payload: e
      };
      i && (o.channelId = i), n !== void 0 && (o.pinned = n);
      const c = yield a(this, it).sendMessagePromise(
        Re.editMessage,
        rI.toBinary(o)
      );
      return nd.fromBinary(c.payload).message;
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t
      };
      e && (r.channelId = e);
      const i = yield a(this, it).sendMessagePromise(
        Re.deleteMessage,
        dI.toBinary(r)
      ), n = od.fromBinary(i.payload);
      return D({
        id: n.chatId
      }, n.channelId ? { channelId: n.channelId } : {});
    });
  }
  searchMessages(t, e) {
    return u(this, null, function* () {
      var i, n, o;
      const r = {
        searchTerm: t,
        timeStamp: (i = e.timestamp) != null ? i : Date.now(),
        size: (n = e.size) != null ? n : 75,
        from: 0,
        reversed: (o = e.reversed) != null ? o : true
      };
      e.channelId && (r.channelId = e.channelId);
      try {
        const c = yield a(this, it).sendMessagePromise(
          Re.searchChannelMessages,
          hI.toBinary(r)
        );
        return Ef.fromBinary(c.payload).messages;
      } catch (c) {
        return [];
      }
    });
  }
  getAllChannels() {
    return u(this, null, function* () {
      try {
        const t = yield a(this, it).sendMessagePromise(
          Re.getAllChatChannels
        );
        return Hs.fromBinary(t.payload).chatChannels.map(pa.formatChannel);
      } catch (t) {
        return [];
      }
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      const r = yield a(this, it).sendMessagePromise(
        Re.markChannelIndexAsRead,
        gI.toBinary({
          channelId: t,
          userId: e.userId,
          channelIndex: e.channelIndex
        })
      );
      return fI.fromBinary(r.payload).channelIndex;
    });
  }
  setPinState(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t.id,
        pinned: e,
        channelId: t.channelId
      }, i = yield a(this, it).sendMessagePromise(
        Re.pinMessage,
        aI.toBinary(r)
      );
      return ad.fromBinary(i.payload);
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case Re.sendMessageToRoom: {
        r = pu.fromBinary.bind(
          pu
        ), i = pu.create();
        break;
      }
      case Re.sendMessageToPeers: {
        r = gu.fromBinary.bind(
          gu
        ), i = gu.create();
        break;
      }
      case Re.editMessage: {
        r = nd.fromBinary.bind(
          nd
        ), i = nd.create();
        break;
      }
      case Re.pinMessage: {
        r = ad.fromBinary.bind(
          ad
        ), i = ad.create();
        break;
      }
      case Re.deleteMessage: {
        r = od.fromBinary.bind(
          od
        ), i = od.create();
        break;
      }
    }
    if (!r) {
      this.logger.warn(`ChatSocketHandler::Event ${t} is not recognized`);
      return;
    }
    a(this, it).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
};
it = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap();
ws([
  E.trace("SocketService.getChatMessages")
], as.prototype, "getChatMessages", 1);
ws([
  E.trace("SocketService.getChatMessagesPaginated")
], as.prototype, "getChatMessagesPaginated", 1);
ws([
  E.trace("SocketService.sendMessageToRoom")
], as.prototype, "sendMessageToRoom", 1);
ws([
  E.trace("SocketService.sendMessageToPeers")
], as.prototype, "sendMessageToPeers", 1);
ws([
  E.trace("SocketService.sendMessageToChannel")
], as.prototype, "sendMessageToChannel", 1);
ws([
  E.trace("SocketService.sendMessage")
], as.prototype, "sendMessage", 1);
ws([
  E.trace("SocketService.editMessage")
], as.prototype, "editMessage", 1);
ws([
  E.trace("SocketService.deleteMessage")
], as.prototype, "deleteMessage", 1);
ws([
  E.trace("SocketService.searchMessages")
], as.prototype, "searchMessages", 1);
ws([
  E.trace("SocketService.getAllChannels")
], as.prototype, "getAllChannels", 1);
ws([
  E.trace("SocketService.markLastReadMessage")
], as.prototype, "markLastReadMessage", 1);
function eM(s) {
  return s.replace(
    /([-_]\w)/g,
    (t) => t[1].toUpperCase()
  );
}
__name(eM, "eM");
function _s(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => _s(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = validate(e) ? e : eM(e);
    t[r] = _s(s[e]);
  }), t;
}
__name(_s, "_s");
function tM(s) {
  return s.replace(
    /[A-Z]/g,
    (t) => `_${t.toLowerCase()}`
  );
}
__name(tM, "tM");
function Rf(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => Rf(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = validate(e) ? e : tM(e);
    t[r] = s[e];
  }), t;
}
__name(Rf, "Rf");
function Vd(s, t = {}) {
  return s == null ? {} : (Object.getOwnPropertyNames(s).forEach((e) => {
    if (typeof s[e] != "function") {
      if (typeof s[e] == "object") {
        Vd(s[e], t[e] = {});
        return;
      }
      t[e] = s[e];
    }
  }), t);
}
__name(Vd, "Vd");
var lg = class {
  static {
    __name(this, "lg");
  }
  constructor(t) {
    h(this, "defaults");
    this.defaults = {
      baseURL: t.baseURL,
      headers: { common: {} },
      timeout: t.timeout,
      retry: t.retry,
      retryDelay: t.retryDelay
    };
  }
  buildURL(t, e) {
    const { baseURL: r } = this.defaults, i = t.startsWith("http") ? t : `${r}${t.startsWith("/") ? t : `/${t}`}`;
    if (e) {
      const n = new URLSearchParams();
      return Object.entries(e).forEach(([o, c]) => {
        n.append(o, c);
      }), `${i}${i.includes("?") ? "&" : "?"}${n.toString()}`;
    }
    return i;
  }
  request(t) {
    return u(this, null, function* () {
      var f;
      const e = ((f = t.method) == null ? void 0 : f.toUpperCase()) || "GET", r = this.buildURL(t.url || "", t.params), i = D(D({}, this.defaults.headers.common), t.headers);
      e !== "GET" && e !== "HEAD" && t.data && !i["Content-Type"] && (i["Content-Type"] = "application/json");
      const o = i["Content-Type"] === "application/json" ? JSON.stringify(t.data) : t.data, c = {
        method: e,
        headers: i,
        body: e !== "GET" && e !== "HEAD" && t.data ? o : void 0
      }, d = t.timeout || this.defaults.timeout, l = t.retry !== void 0 ? t.retry : this.defaults.retry, p = t.retryDelay || this.defaults.retryDelay;
      try {
        const S = new AbortController(), T = setTimeout(() => S.abort(), d);
        c.signal = S.signal;
        const _ = yield fetch(r, c);
        clearTimeout(T);
        let P = null;
        const w = _.headers.get("content-type");
        w && w.includes("application/json") ? P = yield _.json() : P = yield _.text();
        const A = {};
        _.headers.forEach((H, $) => {
          A[$] = H;
        });
        const N = {
          data: P,
          status: _.status,
          statusText: _.statusText,
          headers: A,
          config: t
        };
        if (!_.ok)
          throw N;
        return N;
      } catch (S) {
        if (S instanceof Error && l > 0)
          return yield new Promise((T) => setTimeout(T, p)), this.defaults.baseURL === "https://api.dyte.io" ? this.defaults.baseURL = "https://api.cluster.dyte.in" : this.defaults.baseURL === "https://api.cluster.dyte.in" && (this.defaults.baseURL = "https://api.dyte.io"), this.request(B(D({}, t), {
            retry: l - 1
          }));
        throw S;
      }
    });
  }
  get(r) {
    return u(this, arguments, function* (t, e = {}) {
      return this.request(B(D({}, e), {
        method: "GET",
        url: t
      }));
    });
  }
  post(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "POST",
        url: t,
        data: e
      }));
    });
  }
  put(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "PUT",
        url: t,
        data: e
      }));
    });
  }
};
var sM = 3;
var rM = 30;
var iM = 8e3;
var aM = class {
  static {
    __name(this, "aM");
  }
  constructor(t, e) {
    h(this, "ipInfo");
    h(this, "fetchClient");
    h(this, "requests");
    h(this, "roomName");
    h(this, "roomUUID");
    h(this, "authToken");
    h(this, "organizationId");
    h(this, "iceServers");
    h(this, "pluginInformation");
    h(this, "userDetails");
    h(this, "roomDetails");
    h(this, "context");
    this.context = t;
    const {
      timeout: r = iM,
      retry: i = sM,
      retryDelay: n = rM,
      baseURL: o = "https://api.dyte.io",
      authToken: c,
      cachedUserDetails: d
    } = e || {};
    this.iceServers = d == null ? void 0 : d.iceServers, this.pluginInformation = d == null ? void 0 : d.pluginInformation, this.userDetails = d == null ? void 0 : d.userDetails, this.roomDetails = d == null ? void 0 : d.roomDetails, this.requests = new lg({
      baseURL: o,
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.fetchClient = new lg({
      baseURL: "",
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.setAuthToken(c, { bearer: true });
    const l = this.requests.request.bind(this.requests);
    this.requests.request = (p) => u(this, null, function* () {
      var S, T, _, P, w;
      const f = t.getValue("telemetry");
      try {
        f.injectContext(this.requests.defaults.headers.common);
        const A = yield l(p);
        return p.url !== f.logsEndpoint && this.logger.debug("xhr::fetch", {
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: p.baseURL || this.requests.defaults.baseURL,
            url: p.url,
            method: p.method
          }
        }), A;
      } catch (A) {
        throw A ? (((S = A.config) == null ? void 0 : S.url) !== f.logsEndpoint && this.logger.error("xhr::fetch", {
          error: A,
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: ((T = A.config) == null ? void 0 : T.baseURL) || this.requests.defaults.baseURL,
            url: (_ = A.config) == null ? void 0 : _.url,
            retries: (P = A.config) == null ? void 0 : P.retry,
            method: (w = A.config) == null ? void 0 : w.method,
            isOnline: navigator.onLine ? "online" : "offline"
          }
        }), new R(A.message || "Network request failed", "0011")) : new R("Unknown network error occurred", "0011");
      }
    });
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  setAuthToken(t, e) {
    const { bearer: r } = e || {};
    this.authToken = t, this.requests.defaults.headers.common.Authorization = r ? `Bearer ${t}` : t;
  }
  setHeader(t, e) {
    this.requests.defaults.headers.common[t] = e;
  }
  setRoomName(t) {
    this.roomName = t;
  }
  setRoomUUID(t) {
    this.roomUUID = t;
  }
  setOrganizationId(t) {
    this.organizationId = t;
  }
};
var nM = Object.defineProperty;
var oM = Object.getOwnPropertyDescriptor;
var ns = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? oM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && nM(t, e, i), i;
}, "ns");
var jt = class extends aM {
  static {
    __name(this, "jt");
  }
  constructor(e, r) {
    super(e, r);
    h(this, "telemetry");
    this.telemetry = e.getValue("telemetry"), this.setHeader("x-dyte-web-core-version", e.getValue("sdkVersion"));
  }
  getIPDetails() {
    return u(this, null, function* () {
      var r;
      const { peerId: e } = this;
      try {
        const i = yield yh.getIPDetails({
          peerId: e,
          apiHostnames: cf(this.context),
          logger: ef
        });
        if (this.logger.log("ipInfo", { ipInfo: i }), ((r = i == null ? void 0 : i.loc) == null ? void 0 : r.length) > 5)
          return i;
        throw Error("Insufficient data");
      } catch (i) {
        this.logger.warn(
          "ApiClient.getRoomNodeLinkAndTitleV1 Failed to get ip details",
          { error: { name: i.name, message: i.message } }
        );
        return;
      }
    });
  }
  getICEServers() {
    return u(this, null, function* () {
      if (this.iceServers)
        return this.iceServers;
      const { success: e, iceServers: r } = (yield this.requests.get("/iceservers")).data;
      if (e)
        return (r == null ? void 0 : r.length) > 0 && (this.iceServers = r), r;
    });
  }
  getPlugins() {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f;
      if (this.pluginInformation)
        return this.pluginInformation;
      const { plugins: e } = (yield this.requests.get("/v2/plugins/user")).data.data, r = ((o = (n = this.context.getValue("flagsmith").getValue(X.V1_PLUGINS)) == null ? void 0 : n.toString()) == null ? void 0 : o.split(",")) || [], i = e.reduce(
        (S, T) => (S[r.includes(T.id) ? "v1" : "v2"].push(B(D({}, T), { name: T.name.replace("v2", "") })), S),
        { v1: [], v2: [] }
      );
      return (l = (d = (c = this.context.getValue("modules")) == null ? void 0 : c.devTools) == null ? void 0 : d.plugins) != null && l.length && ((f = (p = this.context.getValue("modules")) == null ? void 0 : p.devTools) == null || f.plugins.forEach((S) => {
        var _, P, w;
        const T = B(D({}, mo), {
          tags: [...mo.tags],
          baseUrl: `http://localhost:${S.port}`,
          name: S.name,
          picture: (_ = S.picture) != null ? _ : mo.picture,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          id: S.id,
          organizationId: this.organizationId,
          description: (P = S.description) != null ? P : mo.description,
          staggered: (w = S.staggered) != null ? w : mo.staggered
        });
        i.v2.push(T);
      })), i.v2;
    });
  }
  getPluginDetails(e) {
    return u(this, null, function* () {
      const { plugin: r } = (yield this.requests.get(`/v2/plugins/view/${e}`)).data.data;
      return r;
    });
  }
  getPluginConfig(e) {
    return u(this, null, function* () {
      return (yield this.fetchClient.get(`${e}/dyte-config.json`)).data;
    });
  }
  authorizePlugin(e) {
    return u(this, null, function* () {
      const r = {
        peerId: this.peerId
      }, { token: i } = (yield this.requests.post(`/v2/plugins/authorize/${e}`, r)).data.data;
      return i;
    });
  }
  getPresignedUrls(e, r) {
    return u(this, null, function* () {
      const i = Gn(this.context, "chat_upload_expiry"), n = {
        roomUUID: this.roomUUID,
        filename: e,
        expiry: typeof i == "number" ? i : void 0
      };
      this.context.getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK) && (n.viewType = r);
      const { getLocation: o, putLocation: c } = (yield this.requests.post("/v1/meetings/genPreSignedUploadUrl", n)).data.data;
      return {
        getLocation: o,
        putLocation: c
      };
    });
  }
  uploadFile(e, r) {
    return u(this, null, function* () {
      if (navigator.isReactNative && "uri" in e)
        try {
          yield fetch(r, {
            method: "PUT",
            headers: {
              "Content-Type": "application/octet-stream"
            },
            body: {
              uri: e.uri,
              name: e.name
            }
          });
        } catch (i) {
          this.logger.error(`sendFileMessage::${i}`);
        }
      else
        yield this.fetchClient.put(r, e, {
          headers: {
            "Content-Type": e.type
          }
        });
    });
  }
  startLivestreaming(r) {
    return u(this, arguments, function* ({
      manualIngestion: e
    }) {
      const i = _s(
        yield this.requests.post(
          `/v2/meetings/${this.context.getValue("meetingId")}/livestreams`,
          {
            manual_ingest: !!e
          }
        )
      ).data.data;
      return {
        playbackUrl: i.playbackUrl,
        status: i.status,
        manualIngest: i.manualIngest,
        ingestionCredentials: i.streamKey ? {
          ingestionServer: i.ingestServer,
          streamKey: i.streamKey
        } : null
      };
    });
  }
  stopLivestreaming() {
    return u(this, null, function* () {
      return this.requests.post(
        `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream/stop`
      );
    });
  }
  getActiveLivestream() {
    return u(this, null, function* () {
      const e = _s(
        (yield this.requests.get(
          `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream`
        )).data.data
      );
      return {
        playbackUrl: e.playbackUrl,
        status: e.status,
        manualIngest: e.manualIngest,
        ingestionCredentials: e.streamKey ? {
          ingestionServer: e.ingestServer,
          streamKey: e.streamKey
        } : null
      };
    });
  }
  getUserDetails() {
    return u(this, null, function* () {
      if (this.userDetails)
        return this.userDetails;
      const e = (yield this.requests.get("v2/internals/participant-details")).data.data;
      return _s(e);
    });
  }
  startRecording(e, r) {
    return u(this, null, function* () {
      return (yield this.requests.post("/v2/recordings", B(D({}, Rf(e)), {
        meeting_id: this.context.getValue("meetingId"),
        allow_multiple_recordings: !!r
      }))).data.data.id;
    });
  }
  updateRecording(e, r) {
    return u(this, null, function* () {
      return this.requests.put(`v2/recordings/${e}`, {
        action: r
      });
    });
  }
  getActiveRecording() {
    return u(this, null, function* () {
      const { status: e, id: r } = (yield this.requests.get(
        `v2/recordings/active-recording/${this.context.getValue("meetingId")}`
      )).data.data;
      return { status: e, id: r };
    });
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      const { transcript_download_url: e } = (yield this.requests.get(
        `v2/meetings/${this.context.getValue("meetingId")}/active-transcript`
      )).data.data;
      try {
        return { transcript: (yield this.fetchClient.get(e)).data };
      } catch (r) {
        throw new R("Cant fetch transcript s3 url", "1801");
      }
    });
  }
  getRoomNodeData() {
    return u(this, null, function* () {
      const e = yield this.getIPDetails();
      if (this.ipInfo = e, this.roomDetails)
        return this.roomDetails;
      const {
        roomNodeLink: r,
        title: i,
        useHiveMedia: n,
        sfu: o
      } = _s(
        (yield this.requests.post("v2/internals/rooms", {
          ip_information: e
        })).data.data
      );
      return {
        roomNodeUrl: r,
        meetingTitle: i,
        useHiveMedia: n != null ? n : false,
        sfu: o
      };
    });
  }
};
ns([
  E.trace("APIClient.getIPDetails")
], jt.prototype, "getIPDetails", 1);
ns([
  E.trace("APIClient.getICEServers")
], jt.prototype, "getICEServers", 1);
ns([
  E.trace("APIClient.getPlugins")
], jt.prototype, "getPlugins", 1);
ns([
  E.trace("APIClient.startLivestreaming")
], jt.prototype, "startLivestreaming", 1);
ns([
  E.trace("APIClient.stopLivestreaming")
], jt.prototype, "stopLivestreaming", 1);
ns([
  E.trace("APIClient.getActiveLivestream")
], jt.prototype, "getActiveLivestream", 1);
ns([
  E.trace("APIClient.getUserDetails")
], jt.prototype, "getUserDetails", 1);
ns([
  E.trace("APIClient.startRecording")
], jt.prototype, "startRecording", 1);
ns([
  E.trace("APIClient.stopRecording")
], jt.prototype, "updateRecording", 1);
ns([
  E.trace("APIClient.getActiveRecording")
], jt.prototype, "getActiveRecording", 1);
ns([
  E.trace("APIClient.getActiveTranscript")
], jt.prototype, "getActiveTranscript", 1);
ns([
  E.trace("APIClient.getRoomNodeData")
], jt.prototype, "getRoomNodeData", 1);
var Fu;
function cM(s, t) {
  return Fu = new jt(s, t), Fu;
}
__name(cM, "cM");
function lt() {
  return Fu;
}
__name(lt, "lt");
function dM(s, t) {
  return `<blockquote>${t.replace(/<blockquote>[.\s\S]*<\/blockquote>\n\n/m, "")}</blockquote>

${s}`;
}
__name(dM, "dM");
var zn = {
  maxInvocations: 5,
  period: 1
};
function Dt(s, t) {
  return function(e, r, i) {
    const n = i.value;
    let o = 0, c = Date.now();
    return i.value = function(...d) {
      const l = Date.now(), p = t ? this[t] : s;
      if (l - c > p.period * 1e3 && (c = l, o = 0), o >= p.maxInvocations)
        throw new R(`Method rate limit ${p.maxInvocations} invocations/${p.period}sec exceeded`, "0013");
      return o += 1, n.apply(this, d);
    }, i;
  };
}
__name(Dt, "Dt");
var lM = Object.defineProperty;
var uM = Object.getOwnPropertyDescriptor;
var pt = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? uM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && lM(t, e, i), i;
}, "pt");
var hM = ["text", "image", "file", "custom", "poll"];
var Sd = { maxInvocations: 180, period: 60 };
var ee;
var vi;
var Fe;
var yi;
var Ti;
var jd;
var wf;
var Fo;
var Hu;
var kg;
var Qe = (kg = class extends qt {
  static {
    __name(this, "kg");
  }
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    g(this, jd);
    g(this, Fo);
    h(this, "messages");
    h(this, "channels", []);
    g(this, ee, void 0);
    g(this, vi, void 0);
    g(this, Fe, void 0);
    g(this, yi, void 0);
    g(this, Ti, void 0);
    h(this, "maxTextLimit", 2e3);
    m(this, Ti, t), m(this, Fe, e), m(this, yi, r), m(this, ee, i), m(this, vi, n), this.messages = [];
  }
  get telemetry() {
    return a(this, Ti).getValue("telemetry");
  }
  setMaxTextLimit(t) {
    this.maxTextLimit = t;
  }
  sendMessageInternal(n, o, c) {
    return u(this, arguments, function* (t, e, r, i = {}) {
      switch (t.type) {
        case "text": {
          const d = i.replyTo && i.replyTo.type === "text" ? dM(t.message, i.replyTo.message) : t.message;
          yield this.sendTextMessageInternal(d, e, r);
          break;
        }
        case "image":
          yield this.sendImageMessageInternal(t.image, e, r);
          break;
        case "file":
          yield this.sendFileMessageInternal(t.file, e, r);
          break;
        default:
          this.logger.error("sendMessage::message_type_not_supported", {
            dyteChat: { messageType: t.type }
          });
          break;
      }
    });
  }
  sendTextMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (t.length > this.maxTextLimit)
        throw new R("Max character limit breached", "0503");
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.text))
          throw this.logger.error("sendTextMessage::private_chat_permission_denied"), new R("Could not send message to private chat.", "0501");
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.text))
        throw this.logger.error("sendTextMessage::public_chat_permission_denied"), new R("Could not send message to public chat.", "0501");
      if (!t)
        throw this.logger.error("sendTextMessage::message_can_not_be_empty"), new R("Message can not be empty.", "0502");
      if (r) {
        a(this, Fe).sendMessageToChannel(t, _t.TEXT, r);
        return;
      }
      let i = [];
      e && e.length > 0 && (e.push(a(this, ee).id), i = a(this, vi).joined.toArray().filter((f) => e.includes(f.id)).map((f) => f.userId), i.push(a(this, ee).userId)), a(this, Fe).sendMessage(
        t,
        _t.TEXT,
        e
      );
    });
  }
  sendImageMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files)) {
          this.logger.error("sendImageMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.files)) {
        this.logger.error("sendImageMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(t.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", { dyteChat: { imageType: t.type } });
        return;
      }
      try {
        const f = lt(), { getLocation: S, putLocation: T } = yield f.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield f.uploadFile(t, T), r) {
          a(this, Fe).sendMessageToChannel(
            S,
            _t.IMAGE,
            r
          );
          return;
        }
        let _ = [];
        e && e.length > 0 && (e.push(a(this, ee).id), _ = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), _.push(a(this, ee).userId)), a(this, Fe).sendMessage(
          S,
          _t.IMAGE,
          e
        );
      } catch (f) {
        throw new R("Error sending image message.", "0500", this.logger);
      }
    });
  }
  sendFileMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (e && e.length > 0) {
        if (!((i = a(this, ee).permissions) != null && i.chatPrivate.canSend) || !((n = a(this, ee).permissions) != null && n.chatPrivate.files)) {
          this.logger.error("sendFileMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const p = lt(), { getLocation: f, putLocation: S } = yield p.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield p.uploadFile(t, S), r) {
          a(this, Fe).sendMessageToChannel(
            JSON.stringify({
              link: f,
              name: t.name,
              size: "size" in t ? t.size : 0
            }),
            _t.FILE,
            r
          );
          return;
        }
        let T = [];
        e && e.length > 0 && (e.push(a(this, ee).id), T = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), T.push(a(this, ee).userId));
        const _ = JSON.stringify({
          link: f,
          name: t.name,
          size: "size" in t ? t.size : 0
        });
        a(this, Fe).sendMessage(
          _,
          _t.FILE,
          e
        );
      } catch (p) {
        throw new R("Error sending file message.", "0500", this.logger);
      }
    });
  }
  get rateLimits() {
    return Sd;
  }
  updateRateLimits(t, e) {
    Sd.maxInvocations = t, Sd.period = e;
  }
  sendTextMessage(t, e) {
    return u(this, null, function* () {
      return this.sendTextMessageInternal(t, e);
    });
  }
  sendCustomMessage(t, e) {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f, S, T, _, P, w, A, N, H;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files) || !((c = a(this, ee).permissions) != null && c.chatPrivate.text)) {
          this.logger.error("sendCustomMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.canSend) || !((f = (p = a(this, ee).permissions) == null ? void 0 : p.chatPublic) != null && f.files) || !((T = (S = a(this, ee).permissions) == null ? void 0 : S.chatPublic) != null && T.text)) {
        this.logger.error("sendCustomMessage::permission_denied");
        return;
      }
      const r = /* @__PURE__ */ __name(($) => u(this, null, function* () {
        try {
          if (typeof $ == "string")
            return { link: $ };
          const F = lt(), { getLocation: K, putLocation: re } = yield F.getPresignedUrls(
            $.name,
            a(this, ee).config.viewType
          );
          return yield F.uploadFile($, re), {
            link: K,
            type: $.type,
            name: $.name,
            size: $.size
          };
        } catch (F) {
          throw new R("Error sending image message.", "0500", this.logger);
        }
      }), "r"), i = B(D({}, t), {
        files: yield Promise.all((P = (_ = t.files) != null ? _ : []) == null ? void 0 : P.map(($) => u(this, null, function* () {
          return r($);
        }))),
        images: yield Promise.all((A = (w = t.images) != null ? w : []) == null ? void 0 : A.map(($) => u(this, null, function* () {
          return r($);
        }))),
        videos: yield Promise.all((H = (N = t.videos) != null ? N : []) == null ? void 0 : H.map(($) => u(this, null, function* () {
          return r($);
        })))
      });
      a(this, Fe).sendMessage(
        JSON.stringify(i),
        _t.CUSTOM,
        e
      );
    });
  }
  sendImageMessage(t, e) {
    return u(this, null, function* () {
      return this.sendImageMessageInternal(t, e);
    });
  }
  sendFileMessage(t, e) {
    return u(this, null, function* () {
      return this.sendFileMessageInternal(t, e);
    });
  }
  sendMessage(t, e) {
    return u(this, null, function* () {
      return this.sendMessageInternal(t, e);
    });
  }
  editTextMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatMessage) == null ? void 0 : n.canEdit) === "NONE")
        throw new R("Not permitted to edit messages", "0501");
      if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.text)) {
        this.logger.error("editTextMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editTextMessage::message_can_not_be_empty");
        return;
      }
      a(this, Fe).editMessage(
        t,
        e,
        _t.TEXT,
        r
      );
    });
  }
  editImageMessage(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d;
      if (!((o = (n = a(this, ee).permissions) == null ? void 0 : n.chatPublic) != null && o.canSend) || !((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.files)) {
        this.logger.error("editImageMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(e.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", {
          dyteChat: { imageType: e.type }
        });
        return;
      }
      try {
        const l = lt(), { getLocation: p, putLocation: f } = yield l.getPresignedUrls(e.name, a(this, ee).config.viewType);
        yield l.uploadFile(e, f), a(this, Fe).editMessage(
          t,
          p,
          _t.IMAGE,
          r
        );
      } catch (l) {
        throw new R("Error editing image message.", "0500", this.logger);
      }
    });
  }
  editFileMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c;
      if (!((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatPublic) != null && n.canSend) || !((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const d = lt(), { getLocation: l, putLocation: p } = yield d.getPresignedUrls(
          e.name,
          a(this, ee).config.viewType
        );
        yield d.uploadFile(e, p), a(this, Fe).editMessage(
          t,
          JSON.stringify({
            link: l,
            name: e.name,
            size: "size" in e ? e.size : 0
          }),
          _t.FILE,
          r
        );
      } catch (d) {
        throw new R("Error editing file message.", "0500", this.logger);
      }
    });
  }
  editMessage(t, e, r) {
    return u(this, null, function* () {
      switch (e.type) {
        case "text": {
          this.editTextMessage(t, e.message, r);
          break;
        }
        case "image": {
          this.editImageMessage(t, e.image, r);
          break;
        }
        case "file": {
          this.editFileMessage(t, e.file, r);
          break;
        }
        default: {
          this.logger.error("editMessage::message_type_not_supported", {
            dyteChat: { messageType: e.type }
          });
          break;
        }
      }
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      var r, i;
      if (((i = (r = a(this, ee).permissions) == null ? void 0 : r.chatMessage) == null ? void 0 : i.canDelete) === "NONE")
        throw new R("Not permitted to delete messages", "0501");
      a(this, Fe).deleteMessage(t, e);
    });
  }
  getMessagesByUser(t) {
    return this.messages.filter((e) => e.userId === t);
  }
  getMessagesByType(t) {
    return this.messages.filter((e) => e.type === t);
  }
  pin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t pin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to pin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, true);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  unpin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t unpin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to unpin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, false);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  getMessages(t, e, r, i = 0, n = void 0) {
    return u(this, null, function* () {
      const o = yield a(this, Fe).getChatMessagesPaginated(t, e, r, i, n);
      return {
        messages: o.messages.map(
          (c) => Es.formatSocketServiceMessage(c)
        ),
        next: o.next
      };
    });
  }
  createChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      var l;
      const o = (l = a(this, ee).permissions) == null ? void 0 : l.chatChannel;
      if (o) {
        if (o.canCreate === "NONE")
          throw new R("Not permitted to create channels", "0501");
        if (r.visibility === "public" && !(o.canCreate === "PUBLIC" || o.canCreate === "ALL"))
          throw new R("Not permitted to create public channels", "0501");
        if (r.visibility === "private" && !(o.canCreate === "PRIVATE" || o.canCreate === "ALL"))
          throw new R("Not permitted to create private channels", "0501");
      }
      if (!t || t.trim().length === 0)
        throw new R("channel name cannot be empty.", "0510");
      const c = [.../* @__PURE__ */ new Set([...e, a(this, ee).userId])];
      return yield a(this, yi).createChannel(
        t.trim(),
        c,
        r.displayPictureUrl,
        r.visibility,
        r.isDirectMessage
      );
    });
  }
  updateChannel(t, e) {
    var o, c, d, l, p;
    const r = this.channels.find((f) => f.id === t), i = (o = a(this, ee).permissions) == null ? void 0 : o.chatChannel;
    if (i) {
      if (i.canUpdate === "NONE")
        throw new R("Not permitted to update channels", "0501");
      if (r.visibility === "public" && !(i.canUpdate === "PUBLIC" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update public channels", "0501");
      if (r.visibility === "private" && !(i.canUpdate === "PRIVATE" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update private channels", "0501");
    }
    const n = {
      memberIds: (c = e.memberIds) != null ? c : r.memberIds,
      displayName: (d = e.displayName) != null ? d : r.displayName,
      displayPictureUrl: (l = e.displayPictureUrl) != null ? l : r.displayPictureUrl,
      visibility: (p = e.visibility) != null ? p : r.visibility
    };
    return a(this, yi).updateChannel(t, n);
  }
  sendMessageToChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.sendMessageInternal(t, null, e, r);
    });
  }
  getChannelMembers(t) {
    return u(this, null, function* () {
      return a(this, yi).getChannelMembers(t);
    });
  }
  searchMessages(r) {
    return u(this, arguments, function* (t, e = {}) {
      if (!a(this, Ti).getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK_SEARCH))
        throw new R("searchMessages is temporarily disabled!", "0506");
      return (yield a(this, Fe).searchMessages(t, e)).map(Es.formatSocketServiceMessage);
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      yield a(this, Fe).markLastReadMessage(t, e);
      const r = this.channels.find((i) => i.id === t);
      if (r) {
        const i = B(D({}, r), { unreadCount: 0 });
        this.channels = this.channels.map((n) => n.id === t ? i : n), this.emit("channelMessageUpdate", i);
      }
    });
  }
  get pinned() {
    return this.messages.filter((t) => t.pinned);
  }
}, ee = /* @__PURE__ */ new WeakMap(), vi = /* @__PURE__ */ new WeakMap(), Fe = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ new WeakMap(), Ti = /* @__PURE__ */ new WeakMap(), jd = /* @__PURE__ */ new WeakSet(), wf = /* @__PURE__ */ __name(function() {
  return a(this, Ti).getValue("connectionHandler");
}, "wf"), Fo = /* @__PURE__ */ new WeakSet(), Hu = /* @__PURE__ */ __name(function() {
  return a(this, jd, wf).socketJoined === true;
}, "Hu"), kg);
pt([
  E.trace("DyteChat.sendTextMessage"),
  Dt(Sd)
], Qe.prototype, "sendTextMessage", 1);
pt([
  E.trace("DyteChat.sendImageMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendImageMessage", 1);
pt([
  E.trace("DyteChat.sendFileMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendFileMessage", 1);
pt([
  E.trace("DyteChat.sendMessage"),
  Dt({ maxInvocations: 180, period: 60 })
], Qe.prototype, "sendMessage", 1);
pt([
  E.trace("DyteChat.editTextMessage")
], Qe.prototype, "editTextMessage", 1);
pt([
  E.trace("DyteChat.editImageMessage")
], Qe.prototype, "editImageMessage", 1);
pt([
  E.trace("DyteChat.editFileMessage")
], Qe.prototype, "editFileMessage", 1);
pt([
  E.trace("DyteChat.editMessage")
], Qe.prototype, "editMessage", 1);
pt([
  E.trace("DyteChat.deleteMessage")
], Qe.prototype, "deleteMessage", 1);
pt([
  E.trace("DyteChat.createChannel")
], Qe.prototype, "createChannel", 1);
pt([
  E.trace("DyteChat.updateChannel")
], Qe.prototype, "updateChannel", 1);
pt([
  E.trace("DyteChat.sendMessageToChannel")
], Qe.prototype, "sendMessageToChannel", 1);
pt([
  E.trace("DyteChat.getChannelMembers")
], Qe.prototype, "getChannelMembers", 1);
pt([
  E.trace("DyteChat.searchMessages")
], Qe.prototype, "searchMessages", 1);
pt([
  E.trace("DyteChat.markLastReadMessage")
], Qe.prototype, "markLastReadMessage", 1);
Qe = pt([
  ht("0500")
], Qe);
var pM = Object.defineProperty;
var gM = Object.getOwnPropertyDescriptor;
var mM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? gM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && pM(t, e, i), i;
}, "mM");
var Dr;
var Ig;
var ci = (Ig = class {
  static {
    __name(this, "Ig");
  }
  constructor(s, t, e, r, i) {
    h(this, "chat");
    h(this, "chatSocketHandler");
    h(this, "chatChannelSocketHandler");
    h(this, "self");
    g(this, Dr, void 0);
    m(this, Dr, s), this.chatSocketHandler = t, this.chatChannelSocketHandler = e, this.chat = new Qe(
      s,
      t,
      e,
      r,
      i
    ), this.self = r, this.setupEvents();
  }
  get telemetry() {
    return a(this, Dr).getValue("telemetry");
  }
  get logger() {
    return a(this, Dr).getValue("logger");
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      return new ci(
        s,
        t,
        e,
        r,
        i
      );
    });
  }
  static formatMessage(s) {
    return B(D({}, s), {
      time: new Date(s.time),
      type: hM[s.type]
    });
  }
  static formatSocketServiceMessage(s) {
    const t = s.createdAt * 1e3, e = {
      displayName: s.displayName,
      id: s.chatId,
      time: t,
      timeMs: s.createdAtMs,
      type: s.payloadType,
      isEdited: s.isEdited,
      userId: s.userId,
      targetUserIds: s.targetUserIds,
      channelId: s.channelId,
      channelIndex: s.channelIndex,
      message: "",
      link: "",
      name: "",
      html: "",
      images: [],
      videos: [],
      files: [],
      size: 0,
      pinned: s.pinned
    };
    switch (e.type) {
      case _t.TEXT: {
        e.message = s.payload;
        break;
      }
      case _t.IMAGE: {
        e.link = s.payload;
        break;
      }
      case _t.FILE: {
        const { link: r, name: i, size: n } = JSON.parse(s.payload);
        e.link = r, e.name = i, e.size = n;
        break;
      }
      case _t.CUSTOM: {
        const {
          html: r,
          images: i,
          message: n,
          videos: o,
          files: c
        } = JSON.parse(s.payload);
        e.message = n, e.html = r, e.images = i, e.videos = o, e.files = c;
        break;
      }
    }
    return ci.formatMessage(e);
  }
  getChatMessages() {
    return u(this, null, function* () {
      if (this.self.config.viewType === "LIVESTREAM" || this.self.config.viewType === "CHAT" || a(this, Dr).getValue("flagsmith").hasFeature(X.FEAT_PAGINATED_CHAT))
        return;
      const s = yield this.chatSocketHandler.getChatMessages();
      if (!(s != null && s.payload))
        return;
      const t = Ef.fromBinary(
        s.payload
      ).messages;
      this.chat.messages = t.map(
        (e) => ci.formatSocketServiceMessage(e)
      );
    });
  }
  setupEvents() {
    a(this, Dr).getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => u(this, null, function* () {
        this.getChatMessages();
      })
    ), this.chatSocketHandler.on(
      Re.sendMessageToRoom,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (!t.channelId)
          this.chat.messages = [...this.chat.messages, t];
        else {
          const e = this.chat.channels.find((r) => r.id === t.channelId);
          e && (e.latestMessage = t, e.unreadCount += 1, this.chat.emit("channelMessageUpdate", e));
        }
        this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.sendMessageToPeers,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        this.chat.messages = [...this.chat.messages, t], this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.editMessage,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (t.channelId) {
          this.chat.emit("chatUpdate", {
            action: "edit",
            message: t,
            messages: this.chat.messages
          });
          return;
        }
        const e = this.chat.messages.findIndex((r) => r.id === t.id);
        e !== -1 && (this.chat.messages[e] = t, this.chat.emit("chatUpdate", {
          action: "edit",
          message: t,
          messages: this.chat.messages
        }));
      }
    ), this.chatSocketHandler.on(
      Re.deleteMessage,
      (s) => {
        if (s.channelId) {
          this.chat.emit("chatUpdate", {
            action: "delete",
            message: { id: s.chatId, channelId: s.channelId },
            messages: this.chat.messages
          });
          return;
        }
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const [e] = this.chat.messages.splice(t, 1);
        this.chat.emit("chatUpdate", {
          action: "delete",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.createChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels.push(e), this.chat.emit("channelCreate", e);
      }
    ), this.chatSocketHandler.on(
      Re.pinMessage,
      (s) => {
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const e = this.chat.messages[t];
        e.pinned = s.pinned, this.chat.messages[t] = e, this.chat.emit("chatUpdate", {
          action: "edit",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.updateChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels = this.chat.channels.map((r) => r.id === e.id ? e : r), this.chat.emit("channelUpdate", e);
      }
    );
  }
}, Dr = /* @__PURE__ */ new WeakMap(), Ig);
var Es = ci;
mM([
  E.trace("ChatController.setupEvents")
], Es.prototype, "setupEvents", 1);
var fM = Object.defineProperty;
var SM = Object.getOwnPropertyDescriptor;
var vM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? SM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && fM(t, e, i), i;
}, "vM");
var Gd;
var bf;
var Wd;
var kf;
var Ga;
var Wa;
var Ho;
var Ag;
var Bu = (Ag = class extends qt {
  static {
    __name(this, "Ag");
  }
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    g(this, Gd);
    g(this, Wd);
    h(this, "items");
    g(this, Ga, void 0);
    g(this, Wa, void 0);
    g(this, Ho, void 0);
    m(this, Ho, t), m(this, Ga, e), m(this, Wa, r), this.items = [];
  }
  create(t, e, r = false, i = false) {
    return u(this, null, function* () {
      if (!a(this, Wd, kf))
        throw new R("Can't create polls without joining room", "0705");
      if (!a(this, Ga).permissions.polls.canCreate) {
        this.logger.error("DytePolls::create::permission_denied");
        return;
      }
      if (!t || !e) {
        this.logger.error("DytePolls::question_and_options_can_not_be_empty", {
          dytePolls: {
            hasQuestion: !!t,
            optionsLength: e == null ? void 0 : e.length
          }
        });
        return;
      }
      if (e.length < 2) {
        this.logger.error("DytePolls::there_must_be_at_least_two_options", {
          dytePolls: { hasQuestion: !!t, optionsLength: e.length }
        });
        return;
      }
      yield a(this, Wa).createPoll(
        t,
        e,
        r,
        i
      );
    });
  }
  vote(t, e) {
    return u(this, null, function* () {
      if (!a(this, Ga).permissions.polls.canVote) {
        this.logger.error("DytePolls::vote::permission_denied");
        return;
      }
      yield a(this, Wa).votePoll(t, e);
    });
  }
}, Gd = /* @__PURE__ */ new WeakSet(), bf = /* @__PURE__ */ __name(function() {
  return a(this, Ho).getValue("connectionHandler");
}, "bf"), Wd = /* @__PURE__ */ new WeakSet(), kf = /* @__PURE__ */ __name(function() {
  var t;
  return ((t = a(this, Gd, bf)) == null ? void 0 : t.socketJoined) === true;
}, "kf"), Ga = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), Ho = /* @__PURE__ */ new WeakMap(), Ag);
Bu = vM([
  ht("0700")
], Bu);
var yM = Object.defineProperty;
var TM = Object.getOwnPropertyDescriptor;
var EM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yM(t, e, i), i;
}, "EM");
var Or;
var Ja;
var Ei;
var Mg;
var Ra = (Mg = class {
  static {
    __name(this, "Mg");
  }
  constructor(s, t, e) {
    h(this, "polls");
    g(this, Or, void 0);
    g(this, Ja, void 0);
    g(this, Ei, void 0);
    this.polls = new Bu(s, t, e), m(this, Ja, t), m(this, Or, s), m(this, Ei, e), this.setupEvents();
  }
  get telemetry() {
    return a(this, Or).getValue("telemetry");
  }
  get logger() {
    return a(this, Or).getValue("logger");
  }
  static init(s, t, e) {
    return u(this, null, function* () {
      return new Ra(s, t, e);
    });
  }
  canViewPolls() {
    return a(this, Ja).permissions.polls.canView;
  }
  setupEvents() {
    const s = {
      [qs.createPoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.updatePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.votePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      }
    }, t = /* @__PURE__ */ __name(() => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).on(r, s[r]);
      });
    }, "t"), e = /* @__PURE__ */ __name(() => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).removeListeners(r);
      });
    }, "e");
    a(this, Ja).permissions.on("permissionsUpdate", (r) => u(this, null, function* () {
      var i;
      r != null && r.polls && ((i = r == null ? void 0 : r.polls) != null && i.canView ? (yield this.getPolls(), t()) : (this.polls.items = [], e()));
    })), this.canViewPolls() && t();
  }
  updatePoll(s) {
    if (!this.canViewPolls())
      return;
    const t = this.polls.items.findIndex((e) => e.id === s.id);
    if (t > -1) {
      const e = JSON.stringify(this.polls.items[t]);
      this.polls.items[t] = s, e !== JSON.stringify(s) && this.polls.emit("pollsUpdate", {
        polls: this.polls.items,
        newPoll: false
      });
      return;
    }
    this.polls.items = [...this.polls.items, s], this.polls.emit("pollsUpdate", { polls: this.polls.items, newPoll: true });
  }
  getPolls() {
    return u(this, null, function* () {
      const s = yield a(this, Ei).getPolls();
      if (!(s != null && s.payload))
        return;
      const { polls: t } = DA.fromBinary(s.payload);
      this.polls.items = t.map(
        (e) => Ra.formatSocketServicePoll(e)
      );
    });
  }
  static formatSocketServicePoll(s) {
    const t = s.options.map((e) => ({
      count: e.count,
      text: e.text,
      votes: e.votes.map((r) => ({
        id: r.userId,
        name: r.name
      }))
    }));
    return {
      anonymous: s.anonymous,
      createdBy: s.createdBy,
      createdByUserId: s.createdByUserId,
      hideVotes: s.hideVotes,
      id: s.pollId,
      options: t,
      question: s.question,
      voted: s.votes
    };
  }
}, Or = /* @__PURE__ */ new WeakMap(), Ja = /* @__PURE__ */ new WeakMap(), Ei = /* @__PURE__ */ new WeakMap(), Mg);
var If = Ra;
EM([
  E.trace("PollController.setupEvents")
], If.prototype, "setupEvents", 1);
var _M = Object.defineProperty;
var PM = Object.getOwnPropertyDescriptor;
var CM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? PM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && _M(t, e, i), i;
}, "CM");
var Af = /* @__PURE__ */ ((s) => (s[s.User = 0] = "User", s[s.Meeting = 1] = "Meeting", s))(Af || {});
var Ka;
var Bo;
var ju;
var _i;
var qo;
var Dg;
var qu = (Dg = class extends qt {
  static {
    __name(this, "Dg");
  }
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    g(this, Bo);
    h(this, "selfActiveTab");
    h(this, "broadcastTabChanges");
    g(this, Ka, void 0);
    g(this, _i, void 0);
    g(this, qo, void 0);
    h(this, "viewType");
    h(this, "meetingStartedTimestamp");
    h(this, "meetingTitle");
    h(this, "sessionId");
    m(this, Ka, t), m(this, _i, e), this.viewType = r, m(this, qo, i), this.meetingTitle = n, this.broadcastTabChanges = e.permissions.canSpotlight;
  }
  get socketState() {
    return a(this, Bo, ju).socketState;
  }
  get mediaState() {
    return a(this, Bo, ju).mediaState;
  }
  get meetingId() {
    return a(this, Ka).getValue("meetingId");
  }
  setBroadcastTabChanges(t) {
    if (!a(this, _i).permissions.canSpotlight)
      throw this.logger.error("DyteSpotlight::setSpotlighted::permission_denied"), new R("User does not have permission to toggle spotlight", "0801");
    this.broadcastTabChanges = t, this.emit("broadcastTabChangesUpdate", this.broadcastTabChanges), this.broadcastTabChanges && this.assertActiveTabToRoom();
  }
  setSelfActiveTab(t, e) {
    var r;
    this.logger.info("DyteSpotlight::setActiveTab", {
      spotlight: {
        currentTab: {
          id: t.id,
          type: t.type
        }
      }
    }), this.selfActiveTab = t, e === 0 && this.emit("selfTabUpdate", t), (r = a(this, _i).permissions) != null && r.canSpotlight && this.broadcastTabChanges && e === 0 && this.assertActiveTabToRoom();
  }
  assertActiveTabToRoom() {
    a(this, qo).broadcastMessage("spotlight", {
      userId: a(this, _i).userId,
      currentTab: this.selfActiveTab
    });
  }
}, Ka = /* @__PURE__ */ new WeakMap(), Bo = /* @__PURE__ */ new WeakSet(), ju = /* @__PURE__ */ __name(function() {
  return a(this, Ka).getValue("connectionHandler");
}, "ju"), _i = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(), Dg);
qu = CM([
  ht("0800")
], qu);
function RM(s) {
  let t = "", e = [""];
  const r = [e];
  let i = 0, n = 0, o = true, c;
  for (c of s)
    c === '"' ? (o && c === t && (e[i] += c), o = !o) : c === "," && o ? c = e[++i] = "" : c === `
` && o ? (t === "\r" && (e[i] = e[i].slice(0, -1)), e = r[++n] = [c = ""], i = 0) : e[i] += c, t = c;
  return r;
}
__name(RM, "RM");
var wM = Object.defineProperty;
var bM = Object.getOwnPropertyDescriptor;
var Mf = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? bM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && wM(t, e, i), i;
}, "Mf");
var jo;
var Og;
var ei = (Og = class extends qt {
  static {
    __name(this, "Og");
  }
  constructor(t) {
    const e = t.getValue("logger");
    super(e);
    h(this, "transcripts");
    g(this, jo, void 0);
    m(this, jo, t), this.transcripts = [];
  }
  get telemetry() {
    return a(this, jo).getValue("telemetry");
  }
  static init(t, e) {
    return u(this, null, function* () {
      const r = new ei(t), i = t.getValue("logger");
      try {
        e && r.getActiveTranscript();
      } catch (n) {
        i.error("Error fetching active transcriptions ", n);
      }
      return r;
    });
  }
  static parseTranscript(t, e = false) {
    if (!t)
      return;
    const [[
      r,
      i,
      n,
      o,
      c,
      d
    ]] = RM(t);
    return {
      id: v4(),
      name: c,
      peerId: i,
      userId: n,
      customParticipantId: o,
      transcript: d,
      isPartialTranscript: e,
      date: new Date(parseInt(r, 10) * 1e3)
    };
  }
  static parseTranscripts(t) {
    return t ? t.split(`
`).map((e) => ei.parseTranscript(e, false)).filter(Boolean) : [];
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      try {
        const t = lt(), { transcript: e } = yield t.getActiveTranscript();
        this.transcripts = ei.parseTranscripts(e);
      } catch (t) {
      }
    });
  }
  onTranscript(t) {
    return u(this, null, function* () {
      var r;
      const e = this.transcripts.filter(({ peerId: i }) => i === t.peerId);
      if ((r = e == null ? void 0 : e.at(-1)) != null && r.isPartialTranscript) {
        const i = e.at(-1);
        i.transcript = t.transcript, i.isPartialTranscript = t.isPartialTranscript, this.emit("transcript", i);
        return;
      }
      this.transcripts = [...this.transcripts, t], this.emit("transcript", t);
    });
  }
}, jo = /* @__PURE__ */ new WeakMap(), Og);
Mf([
  E.trace("DyteAi.getActiveTranscript")
], ei.prototype, "getActiveTranscript", 1);
ei = Mf([
  ht("0000")
], ei);
var kM = Object.defineProperty;
var IM = Object.getOwnPropertyDescriptor;
var AM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? IM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && kM(t, e, i), i;
}, "AM");
var Nr;
var za;
var xt;
var Ng;
var Df = (Ng = class {
  static {
    __name(this, "Ng");
  }
  constructor(s, t, e, r, i, n) {
    h(this, "meta");
    h(this, "ai");
    g(this, Nr, void 0);
    g(this, za, void 0);
    h(this, "aiSocketHandler");
    g(this, xt, void 0);
    m(this, xt, s), this.meta = new qu(
      s,
      t,
      t.config.viewType,
      e,
      n
    ), this.ai = r, m(this, Nr, t), m(this, za, e), this.aiSocketHandler = i, t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  get telemetry() {
    return a(this, xt).getValue("telemetry");
  }
  get logger() {
    return a(this, xt).getValue("logger");
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = yield ei.init(s, t.permissions.transcriptionEnabled);
      return new Df(
        s,
        t,
        e,
        n,
        r,
        i
      );
    });
  }
  conditionallySetActiveTab(s) {
    var t;
    s != null && s.currentTab && ((t = this.meta.selfActiveTab) == null ? void 0 : t.id) !== s.currentTab.id && (this.meta.setSelfActiveTab(
      s.currentTab,
      Af.Meeting
    ), this.meta.emit(
      "activeTabUpdate",
      s.currentTab
    ));
  }
  setupEvents() {
    a(this, xt).getValue("peerSessionStore").on(
      k.TRANSPORT_STATE_UPDATE,
      (s) => {
        this.meta.emit("mediaConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.SOCKET_STATE_UPDATE,
      (s) => {
        this.meta.emit("socketConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(k.ROOM_STATE, ({ createdAt: s, roomUuid: t }) => {
      const e = this.meta.meetingStartedTimestamp;
      if (t && (this.meta.sessionId = t), s && !e) {
        const r = new Date(s * 1e3);
        this.meta.meetingStartedTimestamp = r, this.meta.emit("meetingStartTimeUpdate", {
          meetingStartedTimestamp: this.meta.meetingStartedTimestamp
        });
      }
    }), a(this, xt).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({ score: s }) => {
        s < 5 && this.meta.emit("poorConnection", { score: s });
      }
    ), a(this, Nr).permissions.canSpotlight && (this.logger.info("DyteMetaController::Asserting Spotlight"), this.meta.selfActiveTab && a(this, za).broadcastMessage("spotlight", {
      userId: a(this, Nr).userId,
      currentTab: this.meta.selfActiveTab
    })), a(this, xt).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (s) => u(this, null, function* () {
        a(this, Nr).permissions.canSpotlight && this.meta.selfActiveTab && a(this, za).broadcastToPeers("spotlight", [s.id], {
          userId: a(this, Nr).userId,
          currentTab: this.meta.selfActiveTab
        });
      })
    ), a(this, xt).getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), this.aiSocketHandler.on(x.transcript, (s) => {
      const {
        meetingId: t,
        transcript: e,
        isPartial: r
      } = s;
      let i;
      try {
        i = ei.parseTranscript(e, r);
      } catch (d) {
        this.logger.error(`Failed to parse transcript: ${e}`, d);
      }
      if (!i) {
        this.logger.warn("Received empty transcript data");
        return;
      }
      this.ai.onTranscript(i), this.meta.emit("transcript", i);
      const { peerId: n, name: o, transcript: c } = i;
      this.logger.debug(`${t} Received transcript for peer ${n} - ${o}: ${c}`);
    });
  }
}, Nr = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), xt = /* @__PURE__ */ new WeakMap(), Ng);
var Of = Df;
AM([
  E.trace("MetaController.setupEvents")
], Of.prototype, "setupEvents", 1);
var So = {};
var Er = {
  executeWithLock({
    methodName: s,
    lockName: t,
    timeout: e
  }) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var _, P;
        const l = (P = (this == null ? void 0 : this.peerId) || ((_ = d[0]) == null ? void 0 : _.authToken)) != null ? P : "", p = `${t}-${l}`, f = this == null ? void 0 : this.logger;
        if (So[p]) {
          const w = new Error(
            `Unsupported concurrent calls on Dyte method: ${s}.`
          );
          throw w.name = "UnsupportedConcurrentMethodExecution", f == null || f.error("DyteLocker::UnsupportedConcurrentMethodExecution", {
            error: {
              stack: w.stack
            },
            dyteLocker: {
              methodName: s,
              lockName: p
            }
          }), w;
        }
        So[p] = true;
        const S = setTimeout(
          () => delete So[p],
          e
        ), T = o.apply(this, d);
        return Promise.resolve(T).then(() => {
          delete So[p], clearTimeout(S);
        }).catch(() => {
          delete So[p], clearTimeout(S);
        }), T;
      }, n;
    };
  }
};
var MM = Object.defineProperty;
var DM = Object.getOwnPropertyDescriptor;
var Ta = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? DM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && MM(t, e, i), i;
}, "Ta");
var Yt;
var Jd;
var ae;
var Go;
var Is;
var Ke;
var Wo;
var Gu;
var Ya;
var vd;
var ii = class extends qt {
  static {
    __name(this, "ii");
  }
  constructor(e, r, i, n, o) {
    const c = e.getValue("logger");
    super(c);
    g(this, Wo);
    g(this, Ya);
    g(this, Yt, void 0);
    g(this, Jd, void 0);
    g(this, ae, void 0);
    g(this, Go, void 0);
    g(this, Is, void 0);
    g(this, Ke, void 0);
    m(this, Ke, e), m(this, Yt, n), m(this, Jd, o), m(this, ae, r), m(this, Go, i), m(this, Is, []), this.setupEvents();
  }
  get telemetry() {
    return a(this, Ke).getValue("telemetry");
  }
  get status() {
    return a(this, Ke).getValue("stageStatus");
  }
  setupEvents() {
    const e = {
      [k.GET_STAGE_REQUESTS]: (n) => u(this, null, function* () {
        m(this, Is, n);
      }),
      [k.UPDATE_STAGE_REQUESTS]: (o) => u(this, [o], function* ({ add: n }) {
        const c = a(this, Is).length, { stageRequests: d } = this.getAccessRequests();
        (n || d.length > c) && this.emit("newStageRequest", { count: d.length }), this.emit("stageAccessRequestUpdate", d);
      })
    }, r = /* @__PURE__ */ __name(() => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").onAsync(
          n,
          o
        );
      });
    }, "r"), i = /* @__PURE__ */ __name(() => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").removeListener(
          n,
          o
        );
      });
    }, "i");
    a(this, ae).permissions.on("permissionsUpdate", (n) => {
      const { canAcceptProductionRequests: o } = n;
      o !== void 0 && (a(this, ae).permissions.acceptStageRequests ? (r(), a(this, Yt).getStageRequests()) : (i(), m(this, Is, []), this.emit("stageAccessRequestUpdate", a(this, Is))));
    }), a(this, ae).permissions.acceptStageRequests && r();
  }
  getAccessRequests() {
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::get_access_request::permission_denied"), new R("You do not have permission to perform this action", "2001");
    const e = a(this, Go).joined.toArray().filter(
      (r) => r.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((r) => ({
      displayName: r.name,
      userId: r.userId,
      peerId: r.id
    }));
    return m(this, Is, e), { stageRequests: a(this, Is) };
  }
  requestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (this.status !== "OFF_STAGE")
        throw new R(
          `Unable to request access you are currently ${this.status}`,
          "2006"
        );
      if (a(this, ae).permissions.stageAccess === j.Allowed) {
        L(this, Ya, vd).call(this, "ACCEPTED_TO_JOIN_STAGE");
        return;
      }
      a(this, Yt).requestAccess(), L(this, Ya, vd).call(this, "REQUESTED_TO_JOIN_STAGE");
    });
  }
  cancelRequestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      a(this, Yt).cancelRequestAccess(), L(this, Ya, vd).call(this, "OFF_STAGE");
    });
  }
  grantAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t grant for participant without joining room"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::grant_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).grantAccess(e);
  }
  denyAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t rejectRequestToJoinStage for participant without joining room",
        "2005"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::deny_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).denyAccess(e);
  }
  get peerId() {
    return a(this, Ke).getValue("peerId");
  }
  join() {
    return u(this, null, function* () {
      const e = a(this, Ke).getValue("viewType");
      if (this.status === "ON_STAGE")
        throw new R("You are already on stage.", "2006");
      if (this.status !== "ACCEPTED_TO_JOIN_STAGE" || a(this, ae).permissions.stageAccess === j.NotAllowed)
        throw new R(`Unable to join stage you are currently ${this.status}`, "2006");
      if (a(this, Ke).setValue("stageStatus", "ON_STAGE", false), yield a(this, Yt).joinStage(), e === Mt.Livestream) {
        yield a(this, Ke).getValue("selfController").joinRoom();
        return;
      }
      a(this, Ke).notify("stageStatus"), a(this, ae).audioEnabled && a(this, Wo, Gu).shareMic(a(this, ae).audioTrack), a(this, ae).videoEnabled && a(this, Wo, Gu).shareWebcam(a(this, ae).videoTrack);
    });
  }
  leave() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!(this.status === "ON_STAGE" || this.status === "ACCEPTED_TO_JOIN_STAGE"))
        throw new R(`Unable to leave stage you are currently ${this.status}`, "2006");
      a(this, ae).setIsPinned(false), a(this, Ke).setValue("stageStatus", "OFF_STAGE", false), yield a(this, Yt).leaveStage(a(this, ae).userId);
      try {
        yield a(this, Ke).getValue("peerSessionStore").emitAsync(k.LEAVE_MEDIA_ROOM, "stageLeft");
      } catch (e) {
        this.logger.error("DyteStage::leave::emitAsync::failed", { error: e });
      }
      a(this, Ke).notify("stageStatus");
    });
  }
  kick(e) {
    return u(this, null, function* () {
      if (!a(this, ae).roomJoined)
        throw new R(
          "Can`t kick participant without joining room",
          "2005"
        );
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!a(this, ae).permissions.acceptStageRequests)
        throw this.logger.error("DyteStage::kick::permission_denied"), new R("You do not have permissions for kick", "2001");
      return a(this, Yt).kick(e);
    });
  }
};
Yt = /* @__PURE__ */ new WeakMap(), Jd = /* @__PURE__ */ new WeakMap(), ae = /* @__PURE__ */ new WeakMap(), Go = /* @__PURE__ */ new WeakMap(), Is = /* @__PURE__ */ new WeakMap(), Ke = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakSet(), Gu = /* @__PURE__ */ __name(function() {
  return a(this, Ke).getValue("roomNodeClient");
}, "Gu"), Ya = /* @__PURE__ */ new WeakSet(), vd = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    this.status !== e && a(this, Ke).setValue("stageStatus", e);
  });
}, "vd");
Ta([
  E.trace("DyteStage.getStageRequests")
], ii.prototype, "getAccessRequests", 1);
Ta([
  E.trace("DyteStage.requestAccess")
], ii.prototype, "requestAccess", 1);
Ta([
  E.trace("DyteStage.cancelRequestAccess")
], ii.prototype, "cancelRequestAccess", 1);
Ta([
  E.trace("DyteStage.grantAccess")
], ii.prototype, "grantAccess", 1);
Ta([
  E.trace("DyteStage.denyAccess")
], ii.prototype, "denyAccess", 1);
Ta([
  Er.executeWithLock({
    methodName: "joinStage",
    lockName: "DyteStage.join",
    timeout: 5e3
  }),
  E.trace("DyteStage.joinStage")
], ii.prototype, "join", 1);
Ta([
  E.trace("DyteStage.leaveStage")
], ii.prototype, "leave", 1);
function OM(s) {
  return !(s.viewType === "LIVESTREAM" || s.viewType === "CHAT");
}
__name(OM, "OM");
function Nh(s) {
  switch (s) {
    case pr.UNSPECIFIED:
      return "OFF_STAGE";
    case pr.REQUESTED_STAGE:
      return "REQUESTED_TO_JOIN_STAGE";
    case pr.APPROVED_STAGE:
      return "ACCEPTED_TO_JOIN_STAGE";
    case pr.OFF_STAGE:
      return "OFF_STAGE";
    case pr.ON_STAGE:
      return "ON_STAGE";
    default:
      return "OFF_STAGE";
  }
}
__name(Nh, "Nh");
var NM = Object.defineProperty;
var VM = Object.getOwnPropertyDescriptor;
var LM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? VM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && NM(t, e, i), i;
}, "LM");
var Vr;
var Pi;
var Lr;
var Jo;
var ft;
var Nf = class {
  static {
    __name(this, "Nf");
  }
  constructor(t, e, r, i, n) {
    h(this, "stage");
    g(this, Vr, void 0);
    g(this, Pi, void 0);
    g(this, Lr, void 0);
    g(this, Jo, 0);
    g(this, ft, void 0);
    m(this, ft, t), this.stage = new ii(
      t,
      i,
      n,
      e,
      r
    ), m(this, Lr, e), m(this, Vr, i), m(this, Pi, n), this.setupEvents();
  }
  get telemetry() {
    return a(this, ft).getValue("telemetry");
  }
  get logger() {
    return a(this, ft).getValue("logger");
  }
  setupEvents() {
    a(this, ft).subscribe("stageStatus", (t) => {
      this.stage.emit("stageStatusUpdate", t);
    }), a(this, Lr).on(x.grantStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestApproved"), this.setStageStatus("ACCEPTED_TO_JOIN_STAGE"));
    }), a(this, Lr).on(x.peerStageStatusUpdate, (t) => {
      t !== void 0 && (t.peerId === a(this, Vr).id ? this.selfStageStatusHandler(t) : this.peerStageStatusHandler(t));
    }), a(this, Lr).on(x.denyStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestRejected"), this.setStageStatus("OFF_STAGE"));
    }), a(this, Lr).on(
      x.getStageRequests,
      (t) => u(this, null, function* () {
        var r;
        if (a(this, Vr).permissions.stageAccess !== j.Allowed)
          return;
        const e = (r = t == null ? void 0 : t.stageRequests) != null ? r : [];
        yield a(this, ft).getValue("peerSessionStore").emitAsync(k.GET_STAGE_REQUESTS, e), a(this, Jo) < e.length && e.length > 0 && this.stage.emit("newStageRequest", { count: e.length }), m(this, Jo, e.length), this.stage.emit("stageAccessRequestUpdate", e);
      })
    );
  }
  getCurrentStageRequests() {
    return a(this, Pi).joined.toArray().filter(
      (e) => e.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((e) => ({
      displayName: e.name,
      userId: e.userId,
      peerId: e.id
    }));
  }
  setStageStatus(t) {
    return u(this, null, function* () {
      this.stage.status !== t && a(this, ft).setValue("stageStatus", t);
    });
  }
  selfStageStatusHandler(t) {
    const e = Nh(t.stageType), r = a(this, ft).getValue("stageStatus");
    if (r !== e)
      switch (t.stageType) {
        case 1:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.join();
          break;
        case 2:
        case 3:
          this.setStageStatus(r);
          break;
        case 0:
        case 4:
        default:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.leave();
          break;
      }
  }
  peerStageStatusHandler(t) {
    return u(this, null, function* () {
      const e = a(this, Pi).joined.get(t.peerId), r = a(this, Pi).viewMode === "ACTIVE_GRID";
      if (!e) {
        this.logger.warn("err::peerStageStatusUpdate: participant not found");
        return;
      }
      switch (t.stageType) {
        case 1:
          e.setStageStatus("ON_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
        case 2:
          e.setStageStatus("ACCEPTED_TO_JOIN_STAGE");
          break;
        case 3:
          e.setStageStatus("REQUESTED_TO_JOIN_STAGE");
          break;
        case 0:
        case 4:
        default:
          e.setStageStatus("OFF_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
      }
      a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_PEER_STAGE_STATUS, {
        id: e.id,
        status: e.stageStatus
      });
    });
  }
};
Vr = /* @__PURE__ */ new WeakMap(), Pi = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap();
LM([
  E.trace("DyteStage.setupEvents")
], Nf.prototype, "setupEvents", 1);
var xM = Object.defineProperty;
var UM = Object.getOwnPropertyDescriptor;
var Wl = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? UM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && xM(t, e, i), i;
}, "Wl");
var Ie = {
  getPeer: 14,
  getPeers: 15,
  chatMessage: 16,
  getRoomName: 17,
  getDisplayTitle: 18,
  getPluginInitiator: 19,
  customPluginEventToParent: 20,
  peerJoined: 22,
  peerLeft: 23,
  sendData: 24,
  stageStatusUpdate: 25,
  peerStageStatusUpdate: 26
};
var at;
var Ut;
var Qa;
var Xa;
var Ks;
var Za;
var xr;
var en;
var Vg;
var Wn = (Vg = class extends Jn {
  static {
    __name(this, "Vg");
  }
  constructor(t, {
    baseURL: e,
    createdAt: r,
    description: i,
    id: n,
    name: o,
    organizationId: c,
    picture: d,
    private: l,
    published: p,
    staggered: f,
    tags: S,
    type: T,
    updatedAt: _
  }, P, w, A, N, H) {
    const $ = t.getValue("logger");
    super($);
    g(this, at, void 0);
    h(this, "baseURL");
    h(this, "createdAt");
    h(this, "description");
    h(this, "id");
    h(this, "name");
    g(this, Ut, void 0);
    g(this, Qa, void 0);
    g(this, Xa, void 0);
    h(this, "organizationId");
    h(this, "picture");
    h(this, "private");
    h(this, "published");
    h(this, "staggered");
    h(this, "tags");
    h(this, "type");
    h(this, "updatedAt");
    g(this, Ks, void 0);
    h(this, "config");
    g(this, Za, void 0);
    h(this, "active");
    h(this, "iframes");
    h(this, "enabledBy");
    g(this, xr, void 0);
    g(this, en, void 0);
    m(this, xr, t), this.baseURL = e, this.createdAt = new Date(r), this.description = i, this.id = n, this.name = o, m(this, Ut, w), this.organizationId = c, this.picture = d, this.private = l, this.published = p, this.staggered = f, this.tags = S, this.type = T, this.updatedAt = new Date(_), this.active = false, this.iframes = /* @__PURE__ */ new Map(), m(this, at, P), m(this, Qa, A), m(this, Xa, N), this.enabledBy = "", m(this, en, H);
  }
  get telemetry() {
    return a(this, xr).getValue("telemetry");
  }
  sendIframeEvent(t) {
    this.iframes.size && this.iframes.forEach((e) => {
      const { iframe: r } = e;
      r && (navigator.isReactNative ? r.postMessage(JSON.stringify(t)) : r.contentWindow.postMessage(t, "*"));
    });
  }
  handleIframeMessage(t) {
    return u(this, null, function* () {
      var o;
      if (!this.active)
        return;
      const e = t, { payload: r, uuid: i, type: n } = e;
      switch (n) {
        case W.customPluginEventToRoom: {
          a(this, at).customPluginEventToRoom(
            this.id,
            r,
            i
          );
          break;
        }
        case W.customPluginEventToPeers: {
          a(this, at).customPluginEventToPeers(
            this.id,
            r.peerIds,
            r,
            i
          );
          break;
        }
        case W.enablePluginForRoom: {
          a(this, at).enablePluginForRoom(this.id, i);
          break;
        }
        case W.enablePluginForPeers: {
          a(this, at).enablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.disablePluginForRoom: {
          a(this, at).disablePluginForRoom(this.id, i);
          break;
        }
        case W.disablePluginForPeers: {
          a(this, at).disablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.storeInsertKeys: {
          a(this, at).storeInsertKeys(
            this.id,
            r.store,
            r.insertKeys,
            i
          );
          break;
        }
        case W.storeGetKeys: {
          a(this, at).storeGetKeys(
            this.id,
            r.store,
            r.getKeys,
            i
          );
          break;
        }
        case W.storeDeleteKeys: {
          a(this, at).storeDeleteKeys(
            this.id,
            r.store,
            r.deleteKeys,
            i
          );
          break;
        }
        case W.storeDelete: {
          a(this, at).storeDelete(this.id, r.store, i);
          break;
        }
        case Ie.chatMessage: {
          const {
            messagePayload: c,
            peerIds: d
          } = r;
          if (!a(this, Xa)) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { error: "Chat is disabled for this room." }
            });
            return;
          }
          try {
            yield a(this, Xa).sendMessage(c, d), this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { success: true }
            });
          } catch (l) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: {
                error: l
              }
            });
          }
          break;
        }
        case Ie.getPeer: {
          let c;
          const { peerId: d } = r, l = B(D({}, a(this, Ut)), {
            id: a(this, Ut).id,
            isRecorder: (o = a(this, Ut).permissions) == null ? void 0 : o.isRecorder,
            isHidden: a(this, Ut).permissions.hiddenParticipant,
            stageStatus: a(this, Ut).stageStatus
          });
          d ? (c = a(this, Qa).joined.get(r.peerId), a(this, Ut).id === d && (c = l)) : c = l, this.sendIframeEvent({
            type: Ie.getPeer,
            payload: { peer: c && Vd(c) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPeers: {
          const c = a(this, Qa).joined.toArray().map((d) => Vd(d));
          this.sendIframeEvent({
            type: Ie.getPeers,
            payload: { peers: c },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPluginInitiator: {
          this.sendIframeEvent({
            type: Ie.getPluginInitiator,
            payload: { enabledBy: this.enabledBy },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getDisplayTitle: {
          this.sendIframeEvent({
            type: Ie.getDisplayTitle,
            payload: { displayTitle: a(this, en) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getRoomName: {
          this.sendIframeEvent({
            type: Ie.getRoomName,
            payload: { roomName: a(this, xr).getValue("meetingId") },
            uuid: e.uuid
          });
          break;
        }
        case Ie.customPluginEventToParent: {
          this.emit(e.payload.eventName, e.payload.data);
          break;
        }
      }
    });
  }
  sendData(t) {
    this.active && (this.logger.info("DytePlugin::SendData", {
      plugin: {
        id: this.id,
        name: this.name,
        data: {
          eventName: t.eventName
        }
      }
    }), this.sendIframeEvent({
      type: Ie.sendData,
      uuid: "",
      payload: t
    }));
  }
  removePluginView(t = "default") {
    var i;
    const { iframe: e, listener: r } = (i = this.iframes.get(t)) != null ? i : {};
    (e || r) && (navigator.isReactNative ? e.props.onMessage = void 0 : window.removeEventListener("message", r), this.iframes.delete(t));
  }
  addPluginView(t, e = "default") {
    var o;
    if (!a(this, Za))
      throw this.logger.error(
        "DytePlugin::addPluginView::no_auth_token_set_for_plugin"
      ), new R("No auth token set for plugin.", "0602");
    if (!t)
      throw this.logger.error("DytePlugin::addPluginView::iframe_was_not_provided"), new R("Iframe was not provided.", "0603");
    this.removePluginView(e);
    const r = t, i = new URL(this.baseURL), n = {
      auth: a(this, Za),
      parent: navigator.isReactNative ? this.baseURL : window.location.origin,
      backend: a(this, xr).getValue("apiBase"),
      pluginId: this.id,
      roomName: (o = a(this, xr).getValue("meetingId")) != null ? o : "",
      displayTitle: a(this, en)
    };
    if (Object.keys(n).forEach((c) => {
      i.searchParams.set(c, n[c]);
    }), r.src = i.href, r.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", r.title = e, navigator.isReactNative)
      r.props.onMessage = (c) => {
        this.handleIframeMessage(JSON.parse(c.nativeEvent.data));
      }, this.iframes.set(e, { iframe: r });
    else {
      const c = /* @__PURE__ */ __name((d) => u(this, null, function* () {
        d.source === t.contentWindow && (yield this.handleIframeMessage(d.data));
      }), "c");
      window.addEventListener("message", c), this.iframes.set(e, { iframe: r, listener: c });
    }
  }
  setActive(t) {
    var e, r;
    if (this.active = t, t) {
      this.emit("stateUpdate", {
        active: this.active,
        pluginId: this.id,
        bind: this.addPluginView.bind(this),
        views: (e = this.config) == null ? void 0 : e.views
      });
      return;
    }
    this.active = false, this.emit("stateUpdate", {
      active: this.active,
      pluginId: this.id,
      views: (r = this.config) == null ? void 0 : r.views
    });
  }
  activateForSelf() {
    return u(this, null, function* () {
      const t = lt(), e = yield t.authorizePlugin(this.id);
      m(this, Za, e), m(this, Ks, /* @__PURE__ */ new Date());
      try {
        const r = yield t.getPluginConfig(this.baseURL);
        this.config = r;
      } catch (r) {
        this.logger.error("DytePlugin::activateForSelf", { error: r });
      }
      this.setActive(true), this.emit("enabled");
    });
  }
  deactivateForSelf() {
    Array.from(this.iframes.keys()).forEach((t) => {
      this.removePluginView(t);
    }), m(this, Ks, void 0), this.iframes.clear(), this.setActive(false), this.emit("closed");
  }
  enable() {
    return u(this, null, function* () {
      return this.activateForSelf();
    });
  }
  disable() {
    return this.deactivateForSelf();
  }
  activate() {
    return u(this, null, function* () {
      var t, e;
      this.active || (e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canStart && (a(this, at).addPlugin(this.id, this.staggered), m(this, Ks, /* @__PURE__ */ new Date()), this.logger.info("plugin::activated", {
        plugin: {
          id: this.id,
          enabledBy: this.enabledBy,
          name: this.name
        }
      }));
    });
  }
  deactivate() {
    return u(this, null, function* () {
      var t, e;
      this.active && (!((e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canClose) && this.enabledBy !== a(this, Ut).id || (a(this, at).removePlugin(this.id), this.logger.info("plugin::deactivated", {
        plugin: {
          id: this.id,
          name: this.name,
          duration: a(this, Ks) ? (/* @__PURE__ */ new Date()).getTime() - a(this, Ks).getTime() : 0
        }
      }), m(this, Ks, void 0)));
    });
  }
}, at = /* @__PURE__ */ new WeakMap(), Ut = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new WeakMap(), Vg);
Wl([
  Dt({ maxInvocations: 5, period: 1 })
], Wn.prototype, "sendData", 1);
Wl([
  E.trace("DytePlugin.activatePlugin")
], Wn.prototype, "activate", 1);
Wl([
  E.trace("DytePlugin.deactivatePlugin")
], Wn.prototype, "deactivate", 1);
Wn = Wl([
  ht("0600")
], Wn);
var Ne;
var Ci;
var Vf = class extends Map {
  static {
    __name(this, "Vf");
  }
  constructor(e, r = void 0) {
    const {
      onAddEvent: i,
      onDeleteEvent: n,
      onClearEvent: o
    } = e;
    super();
    g(this, Ne, void 0);
    g(this, Ci, void 0);
    h(this, "onAddEvent");
    h(this, "onDeleteEvent");
    h(this, "onClearEvent");
    m(this, Ne, new Jn(r)), this.onAddEvent = i, this.onDeleteEvent = n, this.onClearEvent = o, m(this, Ci, /* @__PURE__ */ new Map());
  }
  emit(e, ...r) {
    return a(this, Ne).emit(e, ...r);
  }
  on(e, r) {
    return a(this, Ne).on(e, r);
  }
  addListener(e, r) {
    return a(this, Ne).addListener(e, r);
  }
  off(e, r) {
    return a(this, Ne).off(e, r);
  }
  once(e, r) {
    return a(this, Ne).once(e, r);
  }
  prependListener(e, r) {
    return a(this, Ne).prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return a(this, Ne).prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return a(this, Ne).removeListener(e, r);
  }
  removeAllListeners(e) {
    return a(this, Ne).removeAllListeners(e);
  }
  listeners(e) {
    return a(this, Ne).listeners(e);
  }
  listenerCount(e) {
    return a(this, Ne).listenerCount(e);
  }
  getMaxListeners() {
    return a(this, Ne).getMaxListeners();
  }
  setMaxListeners(e) {
    return a(this, Ne).setMaxListeners(e);
  }
  eventNames() {
    return a(this, Ne).eventNames();
  }
  add(e, r = true) {
    return this.set(e.id, e, r);
  }
  set(e, r, i = true) {
    const n = super.set(e, r), o = /* @__PURE__ */ __name((c, ...d) => {
      this.emit(c, r, ...d);
    }, "o");
    return a(this, Ci).set(e, o), r.on("*", o), i && a(this, Ne).emit(this.onAddEvent, r), n;
  }
  delete(e, r = true, i = false) {
    const n = this.get(e);
    if (!n)
      return false;
    n.removeListener("*", a(this, Ci).get(e));
    const o = super.delete(e);
    return i && n.removeAllListeners(), r && a(this, Ne).emit(this.onDeleteEvent, n), o;
  }
  clear(e = true, r = false) {
    this.forEach((n) => {
      n.removeListener("*", a(this, Ci).get(n.id)), r && n.removeAllListeners();
    });
    const i = super.clear();
    return e && a(this, Ne).emit(this.onClearEvent), i;
  }
  toArray() {
    return Array.from(this.values());
  }
};
Ne = /* @__PURE__ */ new WeakMap(), Ci = /* @__PURE__ */ new WeakMap();
var ug = class extends Vf {
  static {
    __name(this, "ug");
  }
  constructor(t) {
    super({
      onAddEvent: "pluginAdded",
      onDeleteEvent: "pluginDeleted"
    }, t);
  }
  add(t, e = true) {
    return super.add(t, e);
  }
  delete(t, e = true, r = false) {
    return super.delete(t, e, r);
  }
};
var $M = Object.defineProperty;
var FM = Object.getOwnPropertyDescriptor;
var HM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? FM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && $M(t, e, i), i;
}, "HM");
var Wu = class {
  static {
    __name(this, "Wu");
  }
  constructor(s) {
    h(this, "all");
    h(this, "active");
    this.all = new ug(s), this.active = new ug(s);
  }
};
Wu = HM([
  ht("0600")
], Wu);
var BM = Object.defineProperty;
var qM = Object.getOwnPropertyDescriptor;
var Jl = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? qM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && BM(t, e, i), i;
}, "Jl");
var Qt;
var tn;
var ls;
var Lg;
var Lf = (Lg = class {
  static {
    __name(this, "Lg");
  }
  constructor(s, t, e, r) {
    h(this, "plugins");
    g(this, Qt, void 0);
    g(this, tn, void 0);
    g(this, ls, void 0);
    m(this, Qt, t), m(this, tn, e), m(this, ls, s), this.plugins = r, this.setupEvents();
  }
  get telemetry() {
    return a(this, ls).getValue("telemetry");
  }
  get logger() {
    return a(this, ls).getValue("logger");
  }
  static init(s, t, e, r, i, n, o, c) {
    return u(this, null, function* () {
      const d = s.getValue("logger"), l = new Wu(d);
      return t.forEach((p) => {
        const f = new Wn(
          s,
          p,
          e,
          n,
          o,
          i,
          c
        );
        l.all.add(f);
      }), new Lf(
        s,
        e,
        r,
        l
      );
    });
  }
  getRoomPlugins() {
    return u(this, null, function* () {
      var t;
      const { plugins: s } = yield a(this, Qt).getActivePlugins();
      (t = this.plugins.active) == null || t.toArray().forEach((e) => {
        this.disablePlugin({ id: e.id });
      }), yield Promise.all(
        s.map(
          (e) => this.enablePlugin({
            id: e.pluginId,
            enabledBy: e.enabledBy
          })
        )
      );
    });
  }
  enablePlugin(e) {
    return u(this, arguments, function* ({
      id: s,
      enabledBy: t
    }) {
      const r = this.plugins.all.get(s);
      r && (yield r.activateForSelf(), r.enabledBy = t);
    });
  }
  disablePlugin(t) {
    return u(this, arguments, function* ({ id: s }) {
      const e = this.plugins.all.get(s);
      e && e.deactivateForSelf();
    });
  }
  sendIframeEvent(s, t, e, r) {
    const i = this.plugins.all.get(t);
    i && i.sendIframeEvent({ type: s, uuid: e, payload: r });
  }
  broadcastIframeEvent(s, t) {
    this.plugins.active.forEach((e) => {
      this.sendIframeEvent(s, e.id, "", t);
    });
  }
  setupEvents() {
    this.plugins.all.on(
      "stateUpdate",
      ({ active: s, id: t }) => {
        if (s) {
          this.plugins.active.add(this.plugins.all.get(t));
          return;
        }
        this.plugins.active.delete(t);
      }
    ), a(this, ls).getValue("peerSessionStore").onAsync(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      yield this.getRoomPlugins(), this.logger.debug("[SOCKET_SERVICE_ROOM_JOINED] resolved request to fetch plugins.");
    })), a(this, Qt).on(
      W.addPlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active || (yield this.enablePlugin({ id: t, enabledBy: s.enabledBy }));
      })
    ), a(this, Qt).on(
      W.removePlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active && (yield this.disablePlugin({ id: t }));
      })
    ), [
      W.enablePluginForPeers,
      W.enablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            enabledBy: t.enabledBy
          });
        })
      );
    }), [
      W.disablePluginForPeers,
      W.disablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            disabledBy: t.disabledBy
          });
        })
      );
    }), [
      W.customPluginEventToPeers,
      W.customPluginEventToRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            data: JSON.parse(
              new TextDecoder().decode(t.pluginData)
            )
          });
        })
      );
    }), [
      W.storeInsertKeys,
      W.storeGetKeys,
      W.storeDeleteKeys
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          var i;
          const r = (i = t.storeItems) == null ? void 0 : i.map((n) => {
            var o;
            return {
              timestamp: n.timestamp,
              peerId: n.peerId,
              payload: JSON.parse(
                (o = n.payload) != null && o.length ? new TextDecoder().decode(n.payload) : "{}"
              ),
              key: n.storeKey
            };
          });
          this.sendIframeEvent(s, t.pluginId, e, {
            storeName: t.storeName,
            storeItems: r
          });
        })
      );
    }), a(this, Qt).on(
      W.storeDelete,
      (s, t) => u(this, null, function* () {
        this.sendIframeEvent(W.storeDelete, s.pluginId, t, {
          storeName: s.storeName
        });
      })
    ), a(this, tn).on(
      Re.sendMessageToPeers,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, tn).on(
      Re.sendMessageToRoom,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, ls).getValue("peerSessionStore").on(k.PEER_JOINED_INTERNAL, (s) => {
      const t = Vd(s);
      this.broadcastIframeEvent(Ie.peerJoined, t);
    }), a(this, ls).getValue("peerSessionStore").on(k.PEER_CLOSED, (s) => {
      this.broadcastIframeEvent(Ie.peerLeft, s);
    }), a(this, ls).getValue("peerSessionStore").on(k.UPDATE_PEER_STAGE_STATUS, (s) => {
      this.broadcastIframeEvent(Ie.peerStageStatusUpdate, s);
    }), a(this, ls).subscribe("stageStatus", (s) => {
      this.broadcastIframeEvent(Ie.stageStatusUpdate, s);
    });
  }
}, Qt = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), Lg);
var Kc = Lf;
Jl([
  E.trace("PluginController.getRoomPlugins")
], Kc.prototype, "getRoomPlugins", 1);
Jl([
  E.trace("PluginController.enableForSelf")
], Kc.prototype, "enablePlugin", 1);
Jl([
  E.trace("PluginController.disableForSelf")
], Kc.prototype, "disablePlugin", 1);
Jl([
  E.trace("PluginController.setupEvents")
], Kc.prototype, "setupEvents", 1);
var Ko;
var jM = class {
  static {
    __name(this, "jM");
  }
  constructor(t) {
    h(this, "mediaJoined");
    h(this, "socketJoined");
    h(this, "socketJoinAttempted");
    h(this, "mediaJoinAttempted");
    h(this, "socketState");
    h(this, "mediaState");
    g(this, Ko, void 0);
    this.mediaJoined = false, this.socketJoined = false, this.socketJoinAttempted = false, this.mediaJoinAttempted = false, this.socketState = {
      state: void 0,
      reconnected: false,
      reconnectionAttempt: void 0
    }, this.mediaState = {
      recv: void 0,
      send: void 0
    }, m(this, Ko, t);
  }
  get joinAttempted() {
    return this.mediaJoinAttempted || this.socketJoinAttempted;
  }
  get roomJoined() {
    return this.mediaJoined && this.socketJoined;
  }
  updateSocketConnectionState(t, e) {
    let r;
    const { reconnected: i } = this.socketState;
    switch (t) {
      case "connected":
        r = {
          state: "connected",
          reconnected: i,
          reconnectionAttempt: void 0
        };
        break;
      case "disconnected":
        r = {
          state: "disconnected",
          reconnected: false,
          reconnectionAttempt: 0
        }, this.socketJoined = false;
        break;
      case "reconnected":
        r = {
          state: "connected",
          reconnected: true,
          reconnectionAttempt: void 0
        };
        break;
      case "reconnecting":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: 0
        };
        break;
      case "reconnectAttempt":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: e
        };
        break;
      case "failed":
        r = {
          state: "failed",
          reconnected: i,
          reconnectionAttempt: void 0
        }, this.socketJoined = false;
        break;
    }
    r && (a(this, Ko).getValue("peerSessionStore").emit(k.SOCKET_STATE_UPDATE, r), this.socketState = r);
  }
};
Ko = /* @__PURE__ */ new WeakMap();
var GM = Object.defineProperty;
var WM = Object.getOwnPropertyDescriptor;
var zc = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? WM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && GM(t, e, i), i;
}, "zc");
var sn;
var rn;
var an;
var yd;
var xg;
var ga = (xg = class extends qt {
  static {
    __name(this, "xg");
  }
  constructor(t, e) {
    const r = t.getValue("logger");
    super(r);
    g(this, an);
    g(this, sn, void 0);
    g(this, rn, void 0);
    h(this, "recordingPeerIds", []);
    h(this, "recordings", []);
    m(this, rn, t), m(this, sn, e);
  }
  get recordingState() {
    return this.recordings.some((t) => t.state === "RECORDING") ? "RECORDING" : this.recordings.some((t) => t.state === "PAUSED") ? "PAUSED" : this.recordings.some((t) => t.state === "STARTING") ? "STARTING" : this.recordings.some((t) => t.state === "STOPPING") ? "STOPPING" : "IDLE";
  }
  get telemetry() {
    return a(this, rn).getValue("telemetry");
  }
  updateRecordings(t) {
    this.recordings = t, this.emit("recordingUpdate", this.recordingState);
  }
  start(t) {
    return u(this, null, function* () {
      if (!a(this, sn).permissions.canRecord)
        throw this.logger.error("DyteRecording::start::permission_denied"), new R("User does not have permission to start recording", "1001");
      if ((t == null ? void 0 : t.allowMultiple) !== true && (this.recordingState === "STARTING" || this.recordingState === "RECORDING" || this.recordingState === "STOPPING"))
        throw this.logger.error("DyteRecording::start::recording_in_progress", {
          recording: {
            state: this.recordingState
          }
        }), new R(
          `Cant start recording, recordingState irregular: ${this.recordingState}`,
          "1005"
        );
      try {
        const e = lt(), { recording: r = {} } = a(this, rn).getValue("defaults"), i = yield e.startRecording(r, t == null ? void 0 : t.allowMultiple);
        this.updateRecordings([...this.recordings, {
          id: i,
          state: "STARTING",
          type: "BROWSER"
        }]);
      } catch (e) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_start", {
          error: e
        }), new R("Error while starting recording", "1000", this.logger);
      }
    });
  }
  stop(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "stop", ["RECORDING", "PAUSED"], t);
    });
  }
  pause(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "pause", ["RECORDING"], t);
    });
  }
  resume(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "resume", ["PAUSED"], t);
    });
  }
}, sn = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakSet(), yd = /* @__PURE__ */ __name(function(t, e, r) {
  return u(this, null, function* () {
    if (!a(this, sn).permissions.canRecord)
      throw this.logger.error("DyteRecording::stop::permission_denied"), new R("User does not have permission to stop recording", "1001");
    let i = [];
    if (r !== void 0) {
      const n = this.recordings.find((o) => o.id === r);
      if (n === void 0)
        throw new R("Could not find the specified recording", "1004");
      if (e.includes(n.state)) {
        this.logger.error("DyteRecording::stop::recording_not_in_expected_state", {
          recording: {
            state: n.state
          }
        });
        return;
      }
      i.push(n);
    } else
      i = this.recordings.filter((n) => e.includes(n.state));
    i.forEach((n) => u(this, null, function* () {
      const o = n.state;
      t === "stop" && (n.state = "STOPPING", this.emit("recordingUpdate", "STOPPING"));
      try {
        yield lt().updateRecording(n.id, t);
      } catch (c) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_stop", {
          error: c
        }), n.state !== o && (n.state = o, this.emit("recordingUpdate", o)), new R("Error while stopping recording", "1000", this.logger);
      }
    }));
  });
}, "yd"), xg);
zc([
  E.trace("DyteRecording.start")
], ga.prototype, "start", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "stop", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "pause", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "resume", 1);
ga = zc([
  ht("1000")
], ga);
var JM = Object.defineProperty;
var KM = Object.getOwnPropertyDescriptor;
var zM = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JM(t, e, i), i;
}, "zM");
var Ri;
var xf = class {
  static {
    __name(this, "xf");
  }
  constructor(t, e, r) {
    h(this, "recording");
    h(this, "room");
    g(this, Ri, void 0);
    m(this, Ri, t), this.recording = new ga(t, e), this.room = r, this.setupEvents();
  }
  get telemetry() {
    return a(this, Ri).getValue("telemetry");
  }
  get logger() {
    return a(this, Ri).getValue("logger");
  }
  getRecordingTypeFromProtoType(t) {
    let e;
    switch (t) {
      case la.BROWSER:
        e = "BROWSER";
        break;
      case la.COMPOSITE:
        e = "COMPOSITE";
        break;
      case la.TRACK:
        e = "TRACK";
        break;
      default:
        e = "BROWSER";
    }
    return e;
  }
  setupEvents() {
    a(this, Ri).getValue("peerSessionStore").on(k.ROOM_STATE, (t) => {
      t.activeRecordings.length !== 0 ? this.recording.updateRecordings(
        t.activeRecordings.map((e) => {
          const r = this.getRecordingTypeFromProtoType(e.recordingType);
          return { id: e.recordingId, state: e.recordingStatus, type: r };
        })
      ) : this.recording.recordings.length && this.recording.updateRecordings([]);
    }), this.room.on(x.recordingStarted, (t) => {
      let e = false;
      const r = [...this.recording.recordings];
      if (r.forEach((i) => {
        i.id === t.recordingId && (e = true, i.state = "RECORDING");
      }), e === false) {
        const i = this.getRecordingTypeFromProtoType(t.recordingType);
        r.push({
          id: t.recordingId,
          state: "RECORDING",
          type: i
        });
      }
      this.recording.updateRecordings(r);
    }), this.room.on(x.recordingPaused, (t) => {
      const e = [...this.recording.recordings];
      e.forEach((r) => {
        r.id === t.recordingId && (r.state = "PAUSED");
      }), this.recording.updateRecordings(e);
    }), this.room.on(x.recordingStopped, (t) => {
      const e = [...this.recording.recordings.filter((r) => r.id !== t.recordingId)];
      this.recording.updateRecordings(e);
    });
  }
};
Ri = /* @__PURE__ */ new WeakMap();
zM([
  E.trace("RecordingController.setupEvents")
], xf.prototype, "setupEvents", 1);
var wi;
var YM = class {
  static {
    __name(this, "YM");
  }
  constructor(t) {
    g(this, wi, void 0);
    m(this, wi, t);
  }
  hasFeature(t) {
    var e;
    return (e = a(this, wi).getValue("flagsmith").hasFeature(t)) != null ? e : false;
  }
  getFeatureValue(t) {
    return a(this, wi).getValue("flagsmith").getValue(t);
  }
  getAllFeatures() {
    return a(this, wi).getValue("flagsmith").getAllFlags();
  }
};
wi = /* @__PURE__ */ new WeakMap();
var Vh = class _Vh {
  static {
    __name(this, "Vh");
  }
  constructor(t, e, r) {
    h(this, "logger");
    h(this, "features");
    h(this, "browserSpecs");
    h(this, "callStats");
    this.logger = t, this.features = e, this.browserSpecs = Te, this.callStats = r;
  }
  static init(t) {
    return new _Vh(t.getValue("logger"), new YM(t), t.getValue("callstats"));
  }
};
var Lh = class _Lh {
  static {
    __name(this, "Lh");
  }
  constructor(t) {
    h(this, "internals");
    this.internals = t;
  }
  static init(t) {
    return u(this, null, function* () {
      const e = Vh.init(t);
      return new _Lh(e);
    });
  }
};
var QM = Object.defineProperty;
var XM = Object.getOwnPropertyDescriptor;
var Gt = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QM(t, e, i), i;
}, "Gt");
var qe;
var ve;
var ge;
var zs;
var Xt;
var zo;
var ke;
var Ot = class extends Jn {
  static {
    __name(this, "Ot");
  }
  constructor(e, r, i = Ju, n = true) {
    const o = e.getValue("logger");
    super(o);
    g(this, qe, void 0);
    g(this, ve, void 0);
    g(this, ge, void 0);
    g(this, zs, void 0);
    g(this, Xt, void 0);
    g(this, zo, void 0);
    g(this, ke, void 0);
    h(this, "audioUpdateInProgress");
    h(this, "videoUpdateInProgress");
    m(this, ke, e), this.audioUpdateInProgress = false, this.videoUpdateInProgress = false, m(this, qe, new Uf(e, r)), m(this, ve, new T0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, ge, new b0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, Xt, new C0(
      a(this, ke),
      a(this, qe)
    )), m(this, zs, new _0(
      a(this, qe)
    )), m(this, zo, n), a(this, ve).on("trackMuted", this.onAudioTrackMuted.bind(this)), a(this, ve).on(
      "trackChanged",
      this.onAudioTrackChanged.bind(this)
    ), a(this, ge).on(
      "trackChanged",
      this.onVideoTrackChanged.bind(this)
    ), a(this, ge).on("trackEnded", this.onVideoTrackEnded.bind(this)), a(this, Xt).on(
      "trackEnded",
      this.onScreenShareEnded.bind(this)
    ), this.onVisibilityChange = this.onVisibilityChange.bind(this), document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  get telemetry() {
    return a(this, ke).getValue("telemetry");
  }
  set context(e) {
    m(this, ke, e);
  }
  onVisibilityChange() {
    return u(this, null, function* () {
      a(this, ke).getValue("callstats").tabChanged(document.visibilityState === "visible"), document.visibilityState !== "visible" ? a(this, ke).getValue("callstats").browserBackgrounded() : (a(this, ke).getValue("callstats").browserForegrounded(), yield this.setupSpeaker());
    });
  }
  repopulateAvailableDevices() {
    return u(this, null, function* () {
      return true;
    });
  }
  setupStreams(i) {
    return u(this, arguments, function* ({
      audio: e,
      video: r
    }) {
      var c;
      e ? a(this, ke).getValue("callstats").audioOn() : a(this, ke).getValue("callstats").audioOff(), r ? a(this, ke).getValue("callstats").videoOn() : a(this, ke).getValue("callstats").videoOff();
      let n, o;
      if (e && r)
        try {
          const d = yield a(this, qe).getAudioAndVideoTrack(
            a(this, ve).userSelectedDevice,
            a(this, ge).userSelectedDevice
          );
          n = d.audioTrack, o = d.videoTrack;
        } catch (d) {
          this.logger.error(
            "LocalMediaHandler::init::Failed to get audio video tracks",
            {
              error: d
            }
          );
        }
      if (!n && e)
        try {
          n = yield a(this, qe).getAudioTrack(
            false,
            a(this, ve).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get audio track", {
            error: d
          });
        }
      if (!o && r)
        try {
          o = yield a(this, qe).getVideoTrack(
            a(this, ge).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get video track", {
            error: d
          });
        }
      e && !n && a(this, ke).getValue("callstats").audioOff(), r && !o && a(this, ke).getValue("callstats").videoOff(), yield a(this, ve).setMediaTrack(n), yield a(this, ge).setMediaTrack(o);
      try {
        this.setupSpeaker();
      } catch (d) {
      }
      if (o) {
        const d = yield this.getDeviceById(o.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("VIDEO", d);
      }
      if (n) {
        const d = yield this.getDeviceById(n.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("AUDIO", d);
      }
      (c = a(this, zs).currentDevice) != null && c.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", a(this, zs).currentDevice), a(this, qe).onDeviceChange((d, l, p) => {
        this.onDeviceChange(l, p);
      });
    });
  }
  getCurrentDevices() {
    return {
      audio: a(this, ve).currentDevice,
      video: a(this, ge).currentDevice,
      speaker: a(this, zs).currentDevice
    };
  }
  get permissions() {
    return a(this, qe).permissions;
  }
  getAllDevices() {
    return a(this, qe).getAvailableDevices();
  }
  getDeviceById(e, r) {
    return a(this, qe).getDevice(e);
  }
  onAudioTrackMuted() {
    this.emit("AUDIO_TRACK_SILENT");
  }
  onAudioTrackChanged() {
    this.emit("AUDIO_TRACK_CHANGE");
  }
  get rawAudioTrack() {
    return a(this, ve).mediaTrack;
  }
  get audioTrack() {
    return a(this, ve).transformedMediaTrack;
  }
  get audioEnabled() {
    return a(this, ve).trackEnabled;
  }
  enableAudio(e) {
    return u(this, null, function* () {
      if (!this.audioUpdateInProgress) {
        this.audioUpdateInProgress = true;
        try {
          e ? yield a(this, ve).enableTrack(false, e) : yield a(this, ve).unmuteTrack();
        } catch (r) {
        } finally {
          this.audioUpdateInProgress = false;
        }
      }
    });
  }
  disableAudio() {
    a(this, ve).mediaTrack && !a(this, ve).isCustomTrack ? a(this, ve).muteTrack() : a(this, ve).disableTrack();
  }
  getAudioDevices(e) {
    return a(this, qe).getAudioInputDevices(e);
  }
  setAudioDevice(e) {
    return u(this, null, function* () {
      yield a(this, ve).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("AUDIO", e), this.emit("AUDIO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  setupSpeaker() {
    return u(this, null, function* () {
      const { speaker: e } = this.getCurrentDevices();
      yield a(this, zs).setupSpeaker();
      const { speaker: r } = this.getCurrentDevices();
      (e == null ? void 0 : e.deviceId) !== (r == null ? void 0 : r.deviceId) && r && this.emit("DEVICE_CHANGE", { device: r });
    });
  }
  setSpeakerDevice(e) {
    return u(this, null, function* () {
      yield a(this, zs).setupSpeaker(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", e), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  onVideoTrackChanged() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  onVideoTrackEnded() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  get rawVideoTrack() {
    return a(this, ge).mediaTrack;
  }
  get videoTrack() {
    return a(this, ge).transformedMediaTrack;
  }
  get videoEnabled() {
    return a(this, ge).trackEnabled;
  }
  enableVideo(e) {
    return u(this, null, function* () {
      if (!this.videoUpdateInProgress) {
        this.videoUpdateInProgress = true;
        try {
          e ? yield a(this, ge).enableTrack(false, e) : yield a(this, ge).unmuteTrack();
        } catch (r) {
        } finally {
          this.videoUpdateInProgress = false;
        }
      }
    });
  }
  disableVideo() {
    a(this, ge).disableTrack();
  }
  getVideoDevices(e) {
    return a(this, qe).getVideoInputDevices(e);
  }
  setVideoDevice(e) {
    return u(this, null, function* () {
      yield a(this, ge).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("VIDEO", e), this.emit("VIDEO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  updateVideoConstraints(e) {
    return u(this, null, function* () {
      yield a(this, ge).updateConstraints(e);
    });
  }
  onScreenShareEnded() {
    this.emit("SCREENSHARE_ENDED");
  }
  get screenShareTracks() {
    return {
      audio: a(this, Xt).audioMediaTrack,
      video: a(this, Xt).videoMediaTrack
    };
  }
  get screenShareEnabled() {
    return a(this, Xt).trackEnabled;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield a(this, Xt).enableScreenShare();
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      a(this, Xt).disableScreenShare();
    });
  }
  updateScreenshareConstraints(e) {
    return u(this, null, function* () {
      yield a(this, Xt).updateConstraints(e);
    });
  }
  getSpeakerDevices(e) {
    return a(this, qe).getAudioOutputDevices(e);
  }
  addAudioMiddleware(e) {
    return a(this, ve).addMiddleware(e);
  }
  removeAudioMiddleware(e) {
    return a(this, ve).removeMiddleware(e);
  }
  removeAllAudioMiddlewares() {
    return a(this, ve).removeAllMiddlewares();
  }
  addVideoMiddleware(e) {
    return a(this, ge).addMiddleware(e);
  }
  removeVideoMiddleware(e) {
    return a(this, ge).removeMiddleware(e);
  }
  removeAllVideoMiddlewares() {
    return a(this, ge).removeAllMiddlewares();
  }
  setVideoMiddlewareGlobalConfig(e) {
    return a(this, ge).setVideoMiddlewareGlobalConfig(e);
  }
  destruct() {
    a(this, ve).disableTrack(), a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker(), a(this, Xt).disableScreenShare(), a(this, qe).destruct();
  }
  onDeviceChange(e, r) {
    return u(this, null, function* () {
      var i, n;
      this.emit("DEVICE_LIST_UPDATED", e), !(r || !a(this, zo)) && ((i = e == null ? void 0 : e.added) == null || i.forEach((o) => u(this, null, function* () {
        var c;
        o && !Ju(o) && (o.kind === "audioinput" && ((c = this.audioTrack) == null ? void 0 : c.enabled) === true ? yield this.setAudioDevice(o) : o.kind === "audiooutput" && (yield this.setSpeakerDevice(o)));
      })), (n = e == null ? void 0 : e.removed) == null || n.forEach((o) => u(this, null, function* () {
        var c;
        if (o.kind === "audiooutput" && ((c = this.getCurrentDevices().speaker) == null ? void 0 : c.deviceId) === o.deviceId) {
          const d = (yield this.getSpeakerDevices()).find((l) => l.deviceId !== o.deviceId);
          d && (yield this.setSpeakerDevice(d));
        }
      })));
    });
  }
  removeAllTracks() {
    this.destruct();
  }
  removeAudioTrack() {
    a(this, ve).disableTrack();
  }
  removeVideoTrack() {
    a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker();
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      document.removeEventListener("visibilitychange", this.onVisibilityChange);
    });
  }
};
qe = /* @__PURE__ */ new WeakMap(), ve = /* @__PURE__ */ new WeakMap(), ge = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakMap(), zo = /* @__PURE__ */ new WeakMap(), ke = /* @__PURE__ */ new WeakMap();
Gt([
  E.trace("MediaHandler.setupStreams")
], Ot.prototype, "setupStreams", 1);
Gt([
  E.trace("MediaHandler.enableAudio")
], Ot.prototype, "enableAudio", 1);
Gt([
  E.trace("MediaHandler.disableAudio")
], Ot.prototype, "disableAudio", 1);
Gt([
  E.trace("MediaHandler.setAudioDevice")
], Ot.prototype, "setAudioDevice", 1);
Gt([
  E.trace("MediaHandler.enableVideo")
], Ot.prototype, "enableVideo", 1);
Gt([
  E.trace("MediaHandler.disableVideo")
], Ot.prototype, "disableVideo", 1);
Gt([
  E.trace("MediaHandler.setVideoDevice")
], Ot.prototype, "setVideoDevice", 1);
Gt([
  E.trace("MediaHandler.updateVideoConstraints")
], Ot.prototype, "updateVideoConstraints", 1);
Gt([
  E.trace("MediaHandler.enableScreenShare")
], Ot.prototype, "enableScreenShare", 1);
Gt([
  E.trace("MediaHandler.disableScreenShare")
], Ot.prototype, "disableScreenShare", 1);
Gt([
  E.trace("MediaHandler.updateScreenshareConstraints")
], Ot.prototype, "updateScreenshareConstraints", 1);
Gt([
  E.trace("MediaHandler.destruct")
], Ot.prototype, "destruct", 1);
Gt([
  E.trace("MediaHandler.onDeviceChange")
], Ot.prototype, "onDeviceChange", 1);
function cd(s, t, e) {
  switch (true) {
    case Te.isChromiumBased():
      switch (t) {
        case "NotAllowedError":
          return e.includes("by system") ? "SYSTEM_DENIED" : s === "screenshare" ? "CANCELED" : "DENIED";
        case "NotReadableError":
        default:
          return "COULD_NOT_START";
      }
    case Te.isSafari():
      switch (t) {
        case "NotAllowedError":
          return "DENIED";
        default:
          return "COULD_NOT_START";
      }
    case Te.isFirefox():
      switch (t) {
        case "NotFoundError":
        case "NotReadableError":
          return "SYSTEM_DENIED";
        case "NotAllowedError":
          return "DENIED";
        case "AbortError":
        default:
          return "COULD_NOT_START";
      }
    default:
      return "COULD_NOT_START";
  }
}
__name(cd, "cd");
var ZM = [
  "virtual",
  "emulator",
  "krisp",
  "solstice conference",
  "teams",
  "loom",
  "zoom",
  "manycam",
  "blackhole",
  "displayport",
  "xsplit",
  "wirecast",
  "vMix",
  "elgato",
  "epiphan",
  "voice changer",
  "voicemod",
  "morphvoxx"
];
function Ju(s) {
  var e, r;
  const t = (e = s.label) == null ? void 0 : e.toLowerCase();
  return ((r = Te._bowser) == null ? void 0 : r.getOSName()) === "macOS" && t.includes("iphone") ? true : ZM.some(
    (i) => t == null ? void 0 : t.includes(i)
  );
}
__name(Ju, "Ju");
function e0(s, t, e) {
  return u(this, null, function* () {
    if (!(t != null && t.length))
      return e;
    const r = s.getValue("logger"), i = new AudioContext(), n = yield Promise.all(
      t == null ? void 0 : t.map((d) => d(i))
    ), o = i.createMediaStreamSource(
      new MediaStream([e])
    ), c = i.createMediaStreamDestination();
    try {
      let d = o;
      for (let l = 0; l < n.length; l += 1)
        d.connect(n[l]), d = n[l];
      d.connect(c);
    } catch (d) {
      return r.error("getTransformedAudioTrack::middleware_execution_failed", {
        error: d
      }), e;
    }
    return c.stream.getAudioTracks()[0];
  });
}
__name(e0, "e0");
var bi;
var Yo;
var t0 = class {
  static {
    __name(this, "t0");
  }
  constructor(t) {
    g(this, bi, void 0);
    g(this, Yo, void 0);
    m(this, Yo, t);
  }
  get logger() {
    return a(this, Yo).getValue("logger");
  }
  terminateMiddlewareWebWorker() {
    if (a(this, bi))
      try {
        clearInterval$1(a(this, bi)), m(this, bi, void 0);
      } catch (t) {
        this.logger.debug("WorkerTimers::terminateMiddlewareWebWorker::failed");
      }
  }
  getTransformedVideoTrack(t, e, r) {
    return u(this, null, function* () {
      if (!(t != null && t.length))
        return e;
      const i = document.createElement("canvas"), n = yield Promise.all(
        t == null ? void 0 : t.map((S) => S({
          canvas: i,
          WorkerTimers: ud
        }))
      );
      if (r.disablePerFrameCanvasRendering) {
        const T = i.captureStream().getVideoTracks()[0];
        return Object.defineProperty(T, "originalSettings", {
          value: e.getSettings()
        }), T;
      }
      const o = document.createElement("video"), c = new MediaStream();
      c.addTrack(e);
      const d = i.getContext("2d");
      o.srcObject = c, o.autoplay = true, this.terminateMiddlewareWebWorker();
      const l = /* @__PURE__ */ __name(() => u(this, null, function* () {
        if (e.enabled === false || e.readyState === "ended") {
          this.terminateMiddlewareWebWorker(), o.remove(), i.remove();
          return;
        }
        try {
          d.drawImage(o, 0, 0);
          for (let S = 0; S < n.length; S += 1)
            typeof n[S] == "function" && (yield n[S](
              i,
              d
            ));
        } catch (S) {
          this.logger.error(
            "getTransformedVideoTrack::middleware_execution_failed",
            { error: S }
          );
        }
      }), "l");
      try {
        o.play();
      } catch (S) {
      }
      o.addEventListener(
        "play",
        () => {
          i.width = o.width || e.getSettings().width, i.height = o.width || e.getSettings().height, m(this, bi, setInterval$1(
            l,
            50
          ));
        },
        false
      );
      const f = i.captureStream().getVideoTracks()[0];
      return Object.defineProperty(f, "originalSettings", {
        value: e.getSettings()
      }), f;
    });
  }
};
bi = /* @__PURE__ */ new WeakMap(), Yo = /* @__PURE__ */ new WeakMap();
var hg = {
  gross: { width: { ideal: 192 }, height: { ideal: 144 } },
  qvga: { width: { ideal: 384 }, height: { ideal: 288 } },
  pvga: { width: { ideal: 480 }, height: { ideal: 360 } },
  vga: { width: { ideal: 640 }, height: { ideal: 480 } },
  hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
  hd_cropped: { width: { ideal: 900 }, height: { ideal: 720 } },
  fhd: { width: { ideal: 1920 }, height: { ideal: 1080 } }
};
var s0 = [
  [320, [
    {
      rid: "q",
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    }
  ]],
  [640, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 7e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1280, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 5e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 13e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1920, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 9e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 15e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]]
];
var r0 = /* @__PURE__ */ __name((s, t) => {
  var c;
  const e = "getSettings" in t && t.getSettings().width || "getConstraints" in t && t.getConstraints().width || "originalSettings" in t && ((c = t.originalSettings) == null ? void 0 : c.width);
  let r = s0;
  s.getValue("flagsmith").hasFeature(X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC) && (r = JSON.parse(s.getValue("flagsmith").getValue(
    X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC
  )));
  const i = r.map(([d]) => d).sort((d, l) => d - l);
  let n = Number.MAX_VALUE, o = 0;
  return i.forEach((d, l) => {
    Math.abs(d - e) < n && (n = Math.abs(d - e), o = l);
  }), r[o][1];
}, "r0");
var pe = /* @__PURE__ */ ((s) => (s.WEBCAM = "webcam", s.WEBCAM_BACKUP = "webcam_backup", s.MIC = "mic", s.SCREENSHARE_VIDEO = "screenshare_video", s.SCREENSHARE_AUDIO = "screenshare_audio", s))(pe || {});
var i0 = Y_();
var Pa = _s(
  i0.config.media
);
function a0(s) {
  var e, r;
  const t = {};
  return s.audio && (t.audio = {
    enableStereo: (e = s.audio.enableStereo) != null ? e : false,
    enableHighBitrate: (r = s.audio.enableHighBitrate) != null ? r : false
  }), t.video = s.video.quality, t;
}
__name(a0, "a0");
var ki;
var As;
var n0 = class {
  static {
    __name(this, "n0");
  }
  constructor(t, e) {
    g(this, ki, void 0);
    g(this, As, void 0);
    h(this, "getScreenShareConstraints", () => {
      var l, p, f, S, T, _, P, w, A, N, H;
      const t2 = (l = a(this, ki)) == null ? void 0 : l.screenshare, e2 = (f = (p = t2 == null ? void 0 : t2.width) == null ? void 0 : p.max) != null ? f : 1920, r = (T = (S = t2 == null ? void 0 : t2.height) == null ? void 0 : S.max) != null ? T : 1080, i = (P = (_ = t2 == null ? void 0 : t2.frameRate) == null ? void 0 : _.max) != null ? P : 5;
      let n = (A = (w = t2 == null ? void 0 : t2.frameRate) == null ? void 0 : w.ideal) != null ? A : 5;
      const o = t2 == null ? void 0 : t2.displaySurface, c = t2 == null ? void 0 : t2.selfBrowserSurface;
      a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE) && (n = parseInt(
        (N = a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE)) == null ? void 0 : N.toString(),
        10
      ));
      let d = {
        width: { max: e2 },
        height: { max: r },
        frameRate: {
          ideal: n,
          max: i
        }
      };
      if (a(this, As).getValue("flagsmith").hasFeature(X.SCREENSHARE_CONSTRAINTS)) {
        const $ = (H = a(this, As).getValue("flagsmith").getValue(
          X.SCREENSHARE_CONSTRAINTS
        )) == null ? void 0 : H.toString();
        d = JSON.parse($);
      }
      return o !== void 0 && ["monitor", "browser", "window"].includes(o) && (d = B(D({}, d), { displaySurface: o })), c !== void 0 && (d = B(D({}, d), { selfBrowserSurface: c })), {
        audio: true,
        video: d
      };
    });
    h(this, "getAudioConstraints", (t2) => {
      var n, o, c, d, l, p, f;
      const e2 = {}, r = (n = a(this, ki)) == null ? void 0 : n.audio, i = r != null && r.enableStereo ? 2 : 1;
      return Te.isFirefox() || Te.isWebKitBased() ? (e2.audio = {
        deviceId: t2,
        autoGainControl: (o = r == null ? void 0 : r.autoGainControl) != null ? o : true,
        echoCancellation: (c = r == null ? void 0 : r.echoCancellation) != null ? c : true,
        noiseSuppression: (d = r == null ? void 0 : r.noiseSupression) != null ? d : true,
        channelCount: i
      }, e2) : (e2.audio = {
        autoGainControl: (l = r == null ? void 0 : r.autoGainControl) != null ? l : true,
        echoCancellation: (p = r == null ? void 0 : r.echoCancellation) != null ? p : true,
        noiseSuppression: (f = r == null ? void 0 : r.noiseSupression) != null ? f : true,
        channelCount: i
      }, t2 && t2 !== "default" && (e2.audio.deviceId = { exact: t2 }), e2);
    });
    h(this, "getVideoConstraints", (t2) => {
      var n, o, c, d;
      const e2 = {}, r = (n = a(this, ki)) == null ? void 0 : n.video;
      let i = hg.vga;
      if (typeof r == "string" ? i = hg[r] : r !== void 0 && (i.height.ideal = r.height.ideal, i.width.ideal = r.width.ideal), i.frameRate = {
        ideal: (c = (o = i.frameRate) == null ? void 0 : o.ideal) != null ? c : 24
      }, Te.isChromiumBased() && (i.frameRate.max = 30), a(this, As).getValue("flagsmith").hasFeature(X.VIDEO_CONSTRAINTS)) {
        const l = (d = a(this, As).getValue("flagsmith").getValue(
          X.VIDEO_CONSTRAINTS
        )) == null ? void 0 : d.toString();
        i = JSON.parse(l);
      }
      return e2.video = i, typeof e2.video == "boolean" || (t2 ? e2.video.deviceId = { exact: t2 } : e2.video.facingMode = "user"), e2;
    });
    m(this, As, t), m(this, ki, e);
  }
  getUpdatedVideoConstraints(t) {
    return t;
  }
};
ki = /* @__PURE__ */ new WeakMap(), As = /* @__PURE__ */ new WeakMap();
var Su = class extends Error {
  static {
    __name(this, "Su");
  }
  constructor(e, r, i) {
    super(r);
    h(this, "constraints");
    h(this, "name");
    this.name = e, this.constraints = i;
  }
};
var o0 = class {
  static {
    __name(this, "o0");
  }
  constructor() {
    h(this, "permissions");
    this.permissions = {
      audio: "NOT_REQUESTED",
      video: "NOT_REQUESTED",
      screenshare: "NOT_REQUESTED"
    };
  }
  getAudioInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audioinput");
    });
  }
  getVideoInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "videoinput");
    });
  }
  getAudioOutputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audiooutput");
    });
  }
};
var c0 = Object.defineProperty;
var d0 = Object.getOwnPropertyDescriptor;
var bs = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? d0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && c0(t, e, i), i;
}, "bs");
var nn;
var Zt;
var Ve;
var Ug;
var Bt = (Ug = class extends o0 {
  static {
    __name(this, "Ug");
  }
  constructor(t, e) {
    super();
    h(this, "availableDevices");
    g(this, nn, void 0);
    g(this, Zt, void 0);
    g(this, Ve, void 0);
    m(this, Ve, t), m(this, Zt, new n0(t, e)), m(this, nn, new AbortController()), this.availableDevices = [], this.getAvailableDevices();
  }
  get telemetry() {
    return a(this, Ve).getValue("telemetry");
  }
  get logger() {
    return a(this, Ve).getValue("logger");
  }
  get constraintsBuilder() {
    return a(this, Zt);
  }
  destruct() {
    return u(this, null, function* () {
      var t;
      (t = a(this, nn)) == null || t.abort();
    });
  }
  handlePermissionErrors(t, e) {
    const r = cd(t, e.name, e.message);
    return this.permissions[t] = r, a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, {
      message: r,
      constraints: e.constraints,
      kind: t
    }), r;
  }
  getAudioAndVideoTrack(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: a(this, Zt).getAudioConstraints(t).audio,
        video: a(this, Zt).getVideoConstraints(e).video
      };
      try {
        this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
          constraints: JSON.stringify(r)
        });
        const i = yield navigator.mediaDevices.getUserMedia(
          r
        );
        this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
          constraints: JSON.stringify(r)
        });
        const n = i.getAudioTracks()[0];
        let o = i.getVideoTracks()[0];
        if (this.permissions.audio = "ACCEPTED", this.permissions.video = "ACCEPTED", a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY) && o.label.includes("OBS Virtual")) {
          const l = (yield this.getVideoInputDevices()).find((p) => p.label.includes("OBS Virtual"));
          o = yield this.getVideoTrack(l.deviceId);
        }
        return a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), { audioTrack: n, videoTrack: o };
      } catch (i) {
        throw this.logger.error("WebMediaInterface.getAudioAndVideoTrack", { error: i }), new R("Couldnt fetch audio and video track", "1605");
      }
    });
  }
  getAudioTrack(t, e) {
    return u(this, null, function* () {
      let r = yield this.getAudioInputDevices();
      if (r.length === 0)
        throw this.permissions.audio = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), new R("No audio devices available", "1606");
      const i = /* @__PURE__ */ __name((n) => u(this, null, function* () {
        let o;
        try {
          r = r.filter((d) => d.deviceId !== n), o = a(this, Zt).getAudioConstraints(n), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(o)
          });
          const [c] = (yield navigator.mediaDevices.getUserMedia(o)).getAudioTracks();
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(o)
          }), c;
        } catch (c) {
          const d = cd(
            "audio",
            c.name,
            c.message
          ), l = new Su(c.name, c.message, o);
          if (d === "COULD_NOT_START") {
            const p = r.shift();
            if (!p)
              throw l;
            this.logger.info("getAudioTrack::gum_failed", {
              constraints: JSON.stringify(o),
              error: c
            });
            const f = a(this, Zt).getAudioConstraints(
              p.deviceId
            );
            return this.logger.info("getAudioTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(f)
            }), i(p.deviceId);
          }
          throw l;
        }
      }), "i");
      try {
        const n = yield i(e);
        return n.enabled = !t, this.permissions.audio !== "ACCEPTED" && (this.permissions.audio = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        })), n;
      } catch (n) {
        throw n.constraints && this.handlePermissionErrors("audio", n), new R(n.message, "1601");
      }
    });
  }
  getVideoTrack(t) {
    return u(this, null, function* () {
      var c;
      const e = a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY), r = (c = yield this.getCurrentDeviceLabel(t)) == null ? void 0 : c.includes("OBS Virtual"), i = e && r, n = yield this.getVideoInputDevices();
      if (n.length === 0)
        throw this.permissions.video = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), new R("No video devices available", "1607");
      const o = /* @__PURE__ */ __name((d) => u(this, null, function* () {
        try {
          let l = d;
          const { video: p } = l;
          i && typeof p != "boolean" && (l = {
            video: { deviceId: p.deviceId }
          }), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(l)
          });
          const [f] = (yield navigator.mediaDevices.getUserMedia(l)).getVideoTracks();
          if (i && typeof p != "boolean" && typeof p.width == "object") {
            const { width: S, height: T } = f.getSettings(), { ideal: _ } = p.width;
            f.applyConstraints({
              width: { ideal: _ },
              height: { ideal: Math.floor(T * _ / S) },
              frameRate: p.frameRate
            });
          }
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(l)
          }), f;
        } catch (l) {
          const p = cd(
            "video",
            l.name,
            l.message
          ), f = new Su(l.name, l.message, d);
          if (p === "COULD_NOT_START") {
            const S = n.shift();
            if (!S)
              throw f;
            this.logger.info("getVideoTrack::gum_failed", {
              constraints: JSON.stringify(d),
              error: l
            });
            const T = a(this, Zt).getVideoConstraints(
              S.deviceId
            );
            return this.logger.info("getVideoTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(T)
            }), o({ video: T.video });
          }
          throw f;
        }
      }), "o");
      try {
        const d = a(this, Zt).getVideoConstraints(t), l = yield o(d);
        return this.permissions.video !== "ACCEPTED" && (this.permissions.video = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        })), l;
      } catch (d) {
        throw d.constraints && this.handlePermissionErrors("video", d), new R(d.message, "1602");
      }
    });
  }
  getScreenShareTracks() {
    return u(this, null, function* () {
      const t = /* @__PURE__ */ __name((e) => u(this, null, function* () {
        try {
          this.logger.info("getDisplayMediaWithoutTimeout::requesting_display_media", {
            constraints: JSON.stringify(e)
          }), a(this, Ve).getValue("callstats").screenShareRequested();
          const r = yield navigator.mediaDevices.getDisplayMedia(
            e
          );
          return this.logger.info("getDisplayMediaWithoutTimeout::received_display_media", {
            constraints: JSON.stringify(e)
          }), r;
        } catch (r) {
          const i = cd(
            "video",
            r.name,
            r.message
          ), n = new Su(r.name, r.message, e), o = { video: true };
          if (SC(e, o) || !a(this, Ve).getValue("flagsmith").hasFeature(X.SCREEENSHARE_CONSTRAINTS_RETRY))
            throw n;
          if (i === "COULD_NOT_START")
            return t(o);
          throw n;
        }
      }), "t");
      try {
        const e = a(this, Zt).getScreenShareConstraints(), r = yield t(e);
        return this.permissions.screenshare !== "ACCEPTED" && (this.permissions.screenshare = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.screenshare,
          kind: "screenshare"
        })), {
          audioTrack: r.getAudioTracks()[0],
          videoTrack: r.getVideoTracks()[0]
        };
      } catch (e) {
        throw e.constraints && this.handlePermissionErrors("screenshare", e), new R(e.message, "1612");
      }
    });
  }
  getCurrentDeviceLabel(t) {
    return u(this, null, function* () {
      const e = yield this.getDevice(t || "default");
      return e == null ? void 0 : e.label;
    });
  }
  getAvailableDevices() {
    return u(this, null, function* () {
      try {
        const t = yield navigator.mediaDevices.enumerateDevices();
        return this.availableDevices = t, t;
      } catch (t) {
        throw this.logger.error("enumerate_devices_failed", {
          error: t
        }), new R("Failed to get available devices", "1609");
      }
    });
  }
  getAvailableDevicesByKind(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter(
          ({ kind: e }) => t === e
        );
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get available devices by kind", "1609");
      }
    });
  }
  getDevice(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter((r) => r.deviceId === t)[0];
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get device", "1609");
      }
    });
  }
  onDeviceChange(t) {
    return u(this, null, function* () {
      Te.supportsDeviceChangeEvent() && navigator.mediaDevices.addEventListener(
        "devicechange",
        (e) => u(this, null, function* () {
          var l, p;
          const r = /* @__PURE__ */ __name((f) => `${f.kind}-${f.deviceId}-${f.groupId}`, "r"), i = this.availableDevices, n = new Set(
            i.map((f) => r(f))
          ), o = yield this.getAvailableDevices(), c = new Set(
            o.map((f) => r(f))
          ), d = {
            added: o.filter(
              (f) => !n.has(r(f))
            ),
            removed: i.filter(
              (f) => !c.has(r(f))
            ),
            devices: o
          };
          if ((l = d.added) != null && l.length || (p = d.removed) != null && p.length) {
            this.logger.info("repopulated_full_device_list", {
              devices: JSON.stringify(o)
            });
            const f = [...d.added, ...d.removed];
            f.some((S) => S.kind === "audioinput") && a(this, Ve).getValue("callstats").devices("AUDIO", o == null ? void 0 : o.filter((S) => S.kind === "audioinput")), f.some((S) => S.kind === "videoinput") && a(this, Ve).getValue("callstats").devices("VIDEO", o == null ? void 0 : o.filter((S) => S.kind === "videoinput")), f.some((S) => S.kind === "audiooutput") && a(this, Ve).getValue("callstats").devices("SPEAKER", o == null ? void 0 : o.filter((S) => S.kind === "audiooutput")), t(e, d, false);
          }
        }),
        { signal: a(this, nn).signal }
      );
    });
  }
}, nn = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), Ve = /* @__PURE__ */ new WeakMap(), Ug);
bs([
  E.trace("WebMediaInterface.destruct")
], Bt.prototype, "destruct", 1);
bs([
  E.trace("WebMediaInterface.handlePermissionErrors")
], Bt.prototype, "handlePermissionErrors", 1);
bs([
  E.trace("WebMediaInterface.getAudioAndVideoTrack")
], Bt.prototype, "getAudioAndVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getAudioTrack")
], Bt.prototype, "getAudioTrack", 1);
bs([
  E.trace("WebMediaInterface.getVideoTrack")
], Bt.prototype, "getVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getScreenShareTracks")
], Bt.prototype, "getScreenShareTracks", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevices")
], Bt.prototype, "getAvailableDevices", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevicesByKind")
], Bt.prototype, "getAvailableDevicesByKind", 1);
bs([
  E.trace("WebMediaInterface.getDevice")
], Bt.prototype, "getDevice", 1);
bs([
  E.trace("WebMediaInterface.onDeviceChange")
], Bt.prototype, "onDeviceChange", 1);
Bt = bs([
  ht("1600")
], Bt);
var Uf = Bt;
var Io = {
  setItem: /* @__PURE__ */ __name((s, t, e) => {
    try {
      localStorage.setItem(s, t);
    } catch (r) {
      e == null || e.error("LocalStorage::setItem::crashed", {
        error: r,
        localStorage: { key: s, value: t }
      });
    }
  }, "setItem"),
  getItem: /* @__PURE__ */ __name((s, t) => {
    try {
      return localStorage.getItem(s);
    } catch (e) {
      t == null || t.error("LocalStorage::getItem::crashed", {
        error: e,
        localStorage: { key: s }
      });
    }
    return null;
  }, "getItem")
};
var l0 = /* @__PURE__ */ __name((s = 0) => new Promise(
  (t) => setTimeout(t, s)
), "l0");
var u0 = /* @__PURE__ */ __name((s, t, e) => {
  const r = typeof e == "number" ? e : 250, i = s.createMediaStreamSource(t), n = s.createAnalyser();
  n.fftSize = 2048, i.connect(n);
  const o = new Uint8Array(n.fftSize);
  let c = false;
  setTimeout(() => {
    c = true;
  }, r);
  function d() {
    return c ? Promise.resolve(true) : (n.getByteTimeDomainData(o), o.some((l) => l !== 128 && l !== 0) ? Promise.resolve(false) : l0().then(d));
  }
  __name(d, "d");
  return d().then(
    (l) => (i.disconnect(), l),
    (l) => {
      throw i.disconnect(), l;
    }
  );
}, "u0");
var h0 = typeof AudioContext != "undefined" ? AudioContext : null;
var xh = class _xh {
  static {
    __name(this, "xh");
  }
  constructor(t) {
    h(this, "_AudioContext");
    h(this, "audioContext");
    h(this, "_audioContextRefContainers");
    const e = D({ AudioContext: h0 }, t);
    Object.defineProperties(this, {
      _AudioContext: {
        value: e.AudioContext
      },
      audioContext: {
        value: null,
        writable: true
      },
      _audioContextRefContainers: {
        value: /* @__PURE__ */ new Set()
      },
      AudioContextProvider: {
        enumerable: true,
        value: _xh
      }
    });
  }
  getOrCreate(t) {
    if (!this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.add(t), this._AudioContext && !this.audioContext))
      try {
        this.audioContext = new this._AudioContext();
      } catch (e) {
      }
    return this.audioContext;
  }
  release(t) {
    this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.delete(t), !this._audioContextRefContainers.size && this.audioContext && (this.audioContext.close(), this.audioContext = null));
  }
};
var pg = new xh();
var p0 = 3;
var g0 = 250;
function m0(s) {
  const t = {}, e = pg.getOrCreate(
    t
  );
  let r = p0;
  function i() {
    return r -= 1, u0(e, s.srcObject, g0).then((n) => n ? r > 0 ? i() : true : false).catch(() => true);
  }
  __name(i, "i");
  return i().finally(() => {
    pg.release(t);
  });
}
__name(m0, "m0");
function gg(s, t) {
  return u(this, null, function* () {
    const e = new Audio(), r = new MediaStream();
    r.addTrack(t), e.srcObject = r;
    let i = false;
    try {
      const n = e.play();
      n && (yield n), i = yield m0(e), i && s.info("checkIfAudioTrackIsSilent::silence_detected");
    } catch (n) {
      s.error("checkIfAudioTrackIsSilent::failed_to_detect_silence", {
        error: n
      });
    } finally {
      e.pause(), e.remove();
    }
    return i;
  });
}
__name(gg, "gg");
var f0 = Object.defineProperty;
var S0 = Object.getOwnPropertyDescriptor;
var $f = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? S0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && f0(t, e, i), i;
}, "$f");
var Ld = class extends Jn {
  static {
    __name(this, "Ld");
  }
  constructor(t, e, r, i) {
    var o;
    const n = t.getValue("logger");
    super(n);
    h(this, "constructorName", this.constructor.name);
    h(this, "userSelectedDevice");
    h(this, "mediaInterface");
    h(this, "isNonPreferredDevice");
    h(this, "_mediaTrack");
    h(this, "transformedMediaTrack");
    h(this, "middlewares", []);
    h(this, "currentDevice");
    h(this, "userPreferredDeviceKey", `Dyte::${this.constructorName}::UserDeviceID`);
    h(this, "setUserPreferredDevice", (t2) => Io.setItem(
      this.userPreferredDeviceKey,
      t2,
      this.logger
    ));
    h(this, "getUserPreferredDevice", () => Io.getItem(
      this.userPreferredDeviceKey,
      this.logger
    ));
    h(this, "isCustomTrack", false);
    h(this, "context");
    this.context = t, this.mediaInterface = e, r && this.setMediaTrack(r), this.userSelectedDevice = (o = this.getUserPreferredDevice()) != null ? o : void 0, this.isNonPreferredDevice = i, this.onTrackEnded = this.onTrackEnded.bind(this), this.onTrackMuted = this.onTrackMuted.bind(this);
  }
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  disableTrack() {
    var t, e;
    this.removeMediaTrackListeners(), this.isCustomTrack || (t = this._mediaTrack) == null || t.stop(), this._mediaTrack = void 0, (e = this.transformedMediaTrack) == null || e.stop(), this.transformedMediaTrack = void 0;
  }
  get mediaTrack() {
    return this._mediaTrack;
  }
  setMediaTrack(t, e = false) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ __name((i) => {
        this.logger.error(`${this.constructorName}.setMediaTrack.error`, {
          error: i
        });
      }, "r");
      try {
        this.disableTrack();
      } catch (i) {
        r(i);
      }
      this._mediaTrack = yield this.conditionallyChangeTrack(t, e), yield this.setTransformedTrack();
      try {
        this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        r(i);
      }
    });
  }
  get trackEnabled() {
    return !!this.mediaTrack && this.mediaTrack.readyState === "live" && this.mediaTrack.enabled;
  }
  muteTrack() {
    if (!this.mediaTrack) {
      this.logger.warn(
        "BaseMediaHandler.muteTrack Tried muting with no track present"
      );
      return;
    }
    this.transformedMediaTrack && (this.transformedMediaTrack.enabled = false), this.mediaTrack.enabled = false;
  }
  unmuteTrack() {
    return u(this, null, function* () {
      try {
        this.mediaTrack ? this.mediaTrack.enabled = true : yield this.enableTrack(false);
      } catch (t) {
        throw this.logger.error(`${this.constructorName}.unmuteTrack.error`, {
          error: t
        }), this.disableTrack(), new R("Failed to unmute track", "1611");
      }
    });
  }
  getCurrentDeviceId() {
    var e;
    const { kind: t } = this.mediaTrack;
    switch (t) {
      case "audio": {
        const { deviceId: r } = this.mediaTrack.getSettings();
        if (r)
          return r;
        const i = this.mediaTrack.getConstraints();
        return this.userSelectedDevice ? (i && typeof i.deviceId == "object" && "exact" in i.deviceId ? i.deviceId.exact : i.deviceId) || ((e = i == null ? void 0 : i.advanced) == null ? void 0 : e[0].deviceId) || "default" : this.mediaTrack.getSettings().deviceId;
      }
      default:
        return this.mediaTrack.getSettings().deviceId;
    }
  }
  setCurrentDevice() {
    return u(this, null, function* () {
      var e;
      if (!this.mediaTrack) {
        this.currentDevice = void 0;
        return;
      }
      const t = this.getCurrentDeviceId();
      ((e = this.currentDevice) == null ? void 0 : e.deviceId) !== t && (this.currentDevice = yield this.mediaInterface.getDevice(t));
    });
  }
  setDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn(`${this.constructorName}.setDevice No device received`), new R("No device received!", "1603");
      this.userSelectedDevice = t.deviceId, this.setUserPreferredDevice(t.deviceId), yield this.onSetDevice(t);
    });
  }
  addMiddleware(t) {
    return u(this, null, function* () {
      if (Te.isWebKitBased() && !$_.hasFeature(X.ALLOW_SAFARI_MEDIA_MIDDLEWARES))
        return {
          success: false,
          message: "Middlewares are not supported in this WebKit engine based browser."
        };
      if (this.middlewares.includes(t))
        return {
          success: false,
          message: "This middleware has been applied, already. Skipping."
        };
      try {
        return this.middlewares.push(t), this.trackEnabled && (yield this.setTransformedTrack()), { success: true, message: "Successfully added the middleware." };
      } catch (e) {
        return this.logger.error("While adding middleware", { error: e }), this.removeMiddleware(t), { success: false, message: e == null ? void 0 : e.message };
      }
    });
  }
  removeMiddleware(t) {
    return u(this, null, function* () {
      const e = this.middlewares.indexOf(t, 0);
      if (e > -1)
        try {
          return this.middlewares.splice(e, 1), yield this.setTransformedTrack(true), {
            success: true,
            message: "Successfully removed the middleware."
          };
        } catch (r) {
          return this.logger.error("While removing middleware", { error: r }), { success: false, message: r == null ? void 0 : r.message };
        }
      return {
        success: false,
        message: "No such middleware was found. Skipping."
      };
    });
  }
  removeAllMiddlewares() {
    return u(this, null, function* () {
      var t;
      if ((t = this.middlewares) != null && t.length)
        try {
          return this.middlewares = [], yield this.setTransformedTrack(true), {
            success: true,
            message: "Successfully removed all the middlewares."
          };
        } catch (e) {
          return this.logger.error("While removing all the middlewares", { error: e }), { success: false, message: e == null ? void 0 : e.message };
        }
      return {
        success: false,
        message: "No middlewares were found. Skipping."
      };
    });
  }
  addMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.addMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.mediaTrack.addEventListener("ended", this.onTrackEnded), this.mediaTrack.addEventListener("mute", this.onTrackMuted));
  }
  removeMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.removeMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.logger.info(`${this.constructorName}.removeMediaTrackListeners`), this.mediaTrack.removeEventListener("ended", this.onTrackEnded), this.mediaTrack.removeEventListener("mute", this.onTrackMuted));
  }
};
$f([
  E.trace("BaseMediaHandler.unmuteTrack")
], Ld.prototype, "unmuteTrack", 1);
Ld = $f([
  ht("1600")
], Ld);
var Ff = Ld;
var v0 = Object.defineProperty;
var y0 = Object.getOwnPropertyDescriptor;
var Uh = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? y0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && v0(t, e, i), i;
}, "Uh");
var vu = "[Dyte]nonSilentDeviceLabels";
var Kl = class extends Ff {
  static {
    __name(this, "Kl");
  }
  onSetDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn("AudioMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (t.kind !== "audioinput")
        throw this.logger.warn("AudioMediaHandler.setDevice Received non audio device"), new R(
          "Non audio device received while setting device!",
          "1603"
        );
      try {
        const e = this.trackEnabled;
        yield this.setMediaTrack(
          yield this.mediaInterface.getAudioTrack(
            !e,
            this.userSelectedDevice
          )
        );
      } catch (e) {
        throw this.logger.error("AudioMediaHandler.setDevice.error", {
          error: e
        }), this.disableTrack(), new R(e.message, "1604");
      }
    });
  }
  enableTrack(t, e) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("AudioMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (e) {
        this.isCustomTrack = true, yield this.setMediaTrack(e, true);
        return;
      }
      this.isCustomTrack = false;
      const r = yield this.mediaInterface.getAudioTrack(
        t,
        this.userSelectedDevice
      );
      yield this.setMediaTrack(r);
    });
  }
  setTransformedTrack(t) {
    return u(this, null, function* () {
      var e;
      if (!t && !((e = this.middlewares) != null && e.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield e0(
          this.context,
          this.middlewares,
          this.mediaTrack
        ), this.emit("trackChanged");
      } catch (r) {
        this.logger.error("AudioMediaHandler.setTransformedTrack", {
          error: r
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("AudioMediaHandler.TrackEnded"), this.emit("trackEnded");
      const t = this.mediaTrack.enabled;
      this.disableTrack(), yield this.enableTrack(!t), yield this.setTransformedTrack(), this.emit("trackChanged");
    });
  }
  onTrackMuted() {
    this.logger.info("AudioMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(t, e = false) {
    return u(this, null, function* () {
      var d;
      if (!t || this.userSelectedDevice || e)
        return t;
      let r = t;
      const i = yield this.mediaInterface.getAudioInputDevices(), n = this.isNonPreferredDevice ? i.filter((l) => l && !this.isNonPreferredDevice(l)) : i;
      if (!(n != null && n.length))
        return r;
      n.find(
        (l) => l.deviceId === t.getSettings().deviceId
      ) || (r.stop(), this.logger.info("localmediahandler::setupstreams::found_audio_non_preferred"), r = yield this.mediaInterface.getAudioTrack(
        false,
        n[0].deviceId
      ));
      const o = JSON.parse(
        Io.getItem(vu, this.logger)
      );
      if (o != null && o.devices.some(
        (l) => l.label === r.label
      ))
        return r;
      if (!(yield gg(this.logger, r))) {
        const l = (d = o == null ? void 0 : o.devices.concat({
          label: r.label
        })) != null ? d : [{ label: r.label }];
        return Io.setItem(vu, JSON.stringify({
          devices: l
        }), this.logger), r;
      }
      this.logger.info("AudioMediaHandler.conditionallyChangeTrack.DetectedSilentTrack");
      const c = r.getSettings().deviceId;
      return n.filter((l) => l.deviceId !== c).some((l) => u(this, null, function* () {
        if (r = yield this.mediaInterface.getAudioTrack(
          false,
          l.deviceId
        ), !(yield gg(this.logger, r))) {
          const p = o.devices.concat({
            label: r.label
          });
          return Io.setItem(vu, JSON.stringify({
            devices: p
          }), this.logger), this.logger.info("AudioMediaHandler.conditionallyChangeTrack.SuccesfullyChangedTrack"), true;
        }
        return this.logger.info("AudioMediaHandler.conditionallyChangeTrack.AnotherSilentTrackFound"), false;
      })), r;
    });
  }
};
Uh([
  E.trace("AudioMediaHandler.setTransformedTrack")
], Kl.prototype, "setTransformedTrack", 1);
Uh([
  E.trace("AudioMediaHandler.onTrackEnded")
], Kl.prototype, "onTrackEnded", 1);
Uh([
  E.trace("AudioMediaHandler.conditionallyChangeTrack")
], Kl.prototype, "conditionallyChangeTrack", 1);
var T0 = Kl;
var on;
var E0 = class {
  static {
    __name(this, "E0");
  }
  constructor(t) {
    g(this, on, void 0);
    h(this, "currentDevice");
    m(this, on, t);
  }
  setupSpeaker(t) {
    return u(this, null, function* () {
      var i, n;
      if (!(a(this, on) instanceof Uf))
        return;
      let e = t;
      if (t || ([e] = (yield a(this, on).getAvailableDevicesByKind(
        "audiooutput"
      )).filter((c) => !Ju(c))), !e)
        throw new R("No speaker found", "1608");
      if (((i = this.currentDevice) == null ? void 0 : i.deviceId) === e.deviceId)
        return;
      this.currentDevice = e;
      const r = document.querySelectorAll("audio");
      (n = r[0]) != null && n.setSinkId && r.forEach((o) => u(this, null, function* () {
        if (typeof o.sinkId != "undefined" && this.currentDevice.deviceId && o.sinkId !== this.currentDevice.deviceId)
          try {
            yield o.setSinkId(this.currentDevice.deviceId);
          } catch (c) {
          }
      }));
    });
  }
};
on = /* @__PURE__ */ new WeakMap();
var _0 = E0;
var Qo;
var P0 = class extends Jn {
  static {
    __name(this, "P0");
  }
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    h(this, "mediaInterface");
    h(this, "audioMediaTrack");
    h(this, "videoMediaTrack");
    g(this, Qo, void 0);
    m(this, Qo, e), this.mediaInterface = r;
  }
  get trackEnabled() {
    return !!this.videoMediaTrack;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      var e, r;
      try {
        const { audioTrack: i, videoTrack: n } = yield this.mediaInterface.getScreenShareTracks();
        if (this.audioMediaTrack = i, this.videoMediaTrack = n, this.addMediaTrackListeners(), ((r = (e = this.mediaInterface) == null ? void 0 : e.permissions) == null ? void 0 : r.screenshare) === "ACCEPTED")
          return;
        this.mediaInterface.permissions && (this.mediaInterface.permissions.screenshare = "ACCEPTED", a(this, Qo).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.mediaInterface.permissions.screenshare,
          kind: "screenshare"
        }));
      } catch (i) {
      }
    });
  }
  disableScreenShare() {
    var e, r;
    this.removeMediaTrackListeners(), (e = this.audioMediaTrack) == null || e.stop(), (r = this.videoMediaTrack) == null || r.stop(), this.videoMediaTrack = void 0, this.audioMediaTrack = void 0;
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this.videoMediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this.videoMediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), this.addMediaTrackListeners();
      } catch (i) {
        this.logger.error("ScreenShareHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  addMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.addEventListener(
      "ended",
      this.onTrackEnded.bind(this)
    ), Te.isWebKitBased() && ((r = this.videoMediaTrack) == null || r.addEventListener(
      "mute",
      this.onTrackEnded.bind(this)
    ));
  }
  removeMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.removeEventListener("ended", this.onTrackEnded), (r = this.videoMediaTrack) == null || r.removeEventListener("mute", this.onTrackEnded);
  }
  onTrackEnded() {
    this.emit("trackEnded");
  }
};
Qo = /* @__PURE__ */ new WeakMap();
var C0 = P0;
var R0 = Object.defineProperty;
var w0 = Object.getOwnPropertyDescriptor;
var zl = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? w0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && R0(t, e, i), i;
}, "zl");
var cn;
var Xo;
var Yc = class extends Ff {
  static {
    __name(this, "Yc");
  }
  constructor(e, r, i, n) {
    super(e, r, i, n);
    g(this, cn, void 0);
    g(this, Xo, {
      disablePerFrameCanvasRendering: false
    });
    m(this, cn, new t0(e));
  }
  onSetDevice(e) {
    return u(this, null, function* () {
      if (!e)
        throw this.logger.warn("VideoMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (e.kind !== "videoinput")
        throw this.logger.warn("VideoMediaHandler.setDevice Received non video device", {
          devices: [e]
        }), new R(
          "Non video device received while setting video device!",
          "1603"
        );
      if (!(this.mediaTrack && this.mediaTrack.enabled)) {
        this.logger.warn(
          "VideoMediaHandler.setDevice Tried switching device with video disabled",
          {
            devices: [e]
          }
        ), this.currentDevice = e;
        return;
      }
      try {
        yield this.setMediaTrack(
          yield this.mediaInterface.getVideoTrack(this.userSelectedDevice)
        );
      } catch (r) {
        throw this.logger.error("VideoMediaHandler.setDevice.error", {
          error: r
        }), this.disableTrack(), new R("Failed to change device", "1600", this.logger);
      }
    });
  }
  enableTrack(e, r) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("VideoMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (r) {
        this.isCustomTrack = true, yield this.setMediaTrack(r, true);
        return;
      }
      this.isCustomTrack = false;
      const i = yield this.mediaInterface.getVideoTrack(
        this.userSelectedDevice
      );
      yield this.setMediaTrack(i);
    });
  }
  setTransformedTrack(e) {
    return u(this, null, function* () {
      var r;
      if (!e && !((r = this.middlewares) != null && r.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield a(this, cn).getTransformedVideoTrack(
          this.middlewares,
          this.mediaTrack,
          a(this, Xo)
        ), this.emit("trackChanged");
      } catch (i) {
        this.logger.error("VideoMediaHandler.setTransformedTrack", {
          error: i
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  setVideoMiddlewareGlobalConfig(e) {
    return u(this, null, function* () {
      m(this, Xo, e);
    });
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this._mediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this._mediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), yield this.setTransformedTrack(), this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        this.logger.error("VideoMediaHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  terminateMiddlewareWebWorker() {
    a(this, cn).terminateMiddlewareWebWorker();
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("VideoMediaHandler.TrackEnded"), this.disableTrack(), this.emit("trackEnded");
    });
  }
  onTrackMuted() {
    this.logger.info("VideoMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(e, r = false) {
    return u(this, null, function* () {
      if (!e || this.userSelectedDevice || r)
        return e;
      let i = e;
      const n = yield this.mediaInterface.getVideoInputDevices(), o = this.isNonPreferredDevice ? n.filter((c) => !this.isNonPreferredDevice(
        c
      )) : n;
      return !(o != null && o.length) || window.FAST_DYTE || o.find(
        (c) => c.deviceId === e.getSettings().deviceId
      ) || (i.stop(), this.logger.info("localmediahandler::setupstreams::found_video_non_preferred"), i = yield this.mediaInterface.getVideoTrack(
        o[0].deviceId
      )), i;
    });
  }
};
cn = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakMap();
zl([
  E.trace("VideoMediaHandler.setTransformedTrack")
], Yc.prototype, "setTransformedTrack", 1);
zl([
  E.trace("VideoMediaHandler.setVideoMiddlewareGlobalConfig")
], Yc.prototype, "setVideoMiddlewareGlobalConfig", 1);
zl([
  E.trace("VideoMediaHandler.onTrackEnded")
], Yc.prototype, "onTrackEnded", 1);
zl([
  E.trace("VideoMediaHandler.conditionallyChangeTrack")
], Yc.prototype, "conditionallyChangeTrack", 1);
var b0 = Yc;
var mg = _s(
  kh()
);
var Rt;
var Ii;
var Zo;
var dn;
var Da = class {
  static {
    __name(this, "Da");
  }
  constructor(t) {
    g(this, Rt, void 0);
    g(this, Ii, void 0);
    g(this, Zo, void 0);
    g(this, dn, void 0);
    if (!t)
      throw new R("Could not load preset.", "0904");
    m(this, Rt, t.config), m(this, Zo, t.name), m(this, Ii, t.ui || _s(kh().ui)), m(this, dn, t.permissions.plugins.config);
  }
  static fromResponse(t) {
    return new Da(t);
  }
  static default() {
    return new Da(mg);
  }
  static init(t, e = true) {
    return !t || e ? new Da(mg) : new Da(t);
  }
  get setupScreen() {
    return {
      isEnabled: true
    };
  }
  get waitingRoom() {
    return {
      isEnabled: true
    };
  }
  get controlBar() {
    return {
      isEnabled: true,
      elements: {
        chat: true,
        fullscreen: true,
        invite: false,
        layout: false,
        participants: true,
        plugins: true,
        polls: true,
        reactions: false,
        screenshare: true
      }
    };
  }
  get header() {
    return {
      isEnabled: true,
      elements: {
        logo: a(this, Ii).designTokens.logo,
        timer: true,
        title: true,
        participantCount: true,
        changeLayout: false
      }
    };
  }
  get pipMode() {
    return true;
  }
  get viewType() {
    return a(this, Rt).viewType;
  }
  get livestreamViewerQualities() {
    return a(this, Rt).livestreamViewerQualities || [];
  }
  get maxVideoStreams() {
    return a(this, Rt).maxVideoStreams;
  }
  get maxScreenShareCount() {
    return a(this, Rt).maxScreenshareCount;
  }
  get plugins() {
    return [];
  }
  get disabledPlugins() {
    return Object.keys(a(this, dn)).filter((t) => a(this, dn)[t].disabled);
  }
  get designTokens() {
    return a(this, Ii).designTokens;
  }
  get configDiff() {
    return a(this, Ii).configDiff;
  }
  get mediaConstraints() {
    var t, e, r, i, n, o, c, d, l, p, f, S, T, _, P, w, A, N, H, $, F, K, re, Je;
    return {
      audio: {
        enableStereo: (i = (r = (e = (t = a(this, Rt)) == null ? void 0 : t.media) == null ? void 0 : e.audio) == null ? void 0 : r.enableStereo) != null ? i : Pa.audio.enableStereo,
        enableHighBitrate: (d = (c = (o = (n = a(this, Rt)) == null ? void 0 : n.media) == null ? void 0 : o.audio) == null ? void 0 : c.enableHighBitrate) != null ? d : Pa.audio.enableHighBitrate
      },
      video: {
        quality: (S = (f = (p = (l = a(this, Rt)) == null ? void 0 : l.media) == null ? void 0 : p.video) == null ? void 0 : f.quality) != null ? S : Pa.video.quality,
        frameRate: (w = (P = (_ = (T = a(this, Rt)) == null ? void 0 : T.media) == null ? void 0 : _.video) == null ? void 0 : P.frameRate) != null ? w : Pa.video.frameRate
      },
      screenshare: {
        quality: ($ = (H = (N = (A = a(this, Rt)) == null ? void 0 : A.media) == null ? void 0 : N.screenshare) == null ? void 0 : H.quality) != null ? $ : Pa.screenshare.quality,
        frameRate: (Je = (re = (K = (F = a(this, Rt)) == null ? void 0 : F.media) == null ? void 0 : K.screenshare) == null ? void 0 : re.frameRate) != null ? Je : Pa.screenshare.frameRate
      }
    };
  }
  get name() {
    return a(this, Zo);
  }
};
var Ku = Da;
Rt = /* @__PURE__ */ new WeakMap(), Ii = /* @__PURE__ */ new WeakMap(), Zo = /* @__PURE__ */ new WeakMap(), dn = /* @__PURE__ */ new WeakMap();
var k0 = Object.defineProperty;
var I0 = Object.getOwnPropertyDescriptor;
var Hf = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? I0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && k0(t, e, i), i;
}, "Hf");
var ln;
var ec;
var $h = class extends qt {
  static {
    __name(this, "$h");
  }
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    g(this, ln, void 0);
    h(this, "state", "IDLE");
    h(this, "playbackUrl");
    h(this, "ingestionCredentials");
    h(this, "viewerCount");
    g(this, ec, void 0);
    m(this, ln, r), m(this, ec, e), this.viewerCount = 0;
  }
  get telemetry() {
    return a(this, ec).getValue("telemetry");
  }
  setLivestreamState(e) {
    const r = this.state;
    this.state = e, r !== e && this.emitCurrentLivestreamState();
  }
  emitCurrentLivestreamState() {
    this.emit("livestreamUpdate", this.state);
  }
  start() {
    return u(this, arguments, function* (e = {
      manualIngestion: false
    }) {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::start::permission_denied"), new R(
          "User does not have permission to start livestreaming",
          "1901"
        );
      this.setLivestreamState("STARTING");
      try {
        const r = lt(), {
          playbackUrl: i,
          ingestionCredentials: n
        } = yield r.startLivestreaming(e);
        this.playbackUrl = i, this.ingestionCredentials = n, e != null && e.manualIngestion && this.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
      } catch (r) {
        throw this.logger.error("DyteRecording::stop::livestream_failed_to_start", {
          error: r
        }), this.setLivestreamState("IDLE"), new R("Error while starting livestream", "1900", this.logger);
      }
    });
  }
  stop() {
    return u(this, null, function* () {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::stop::permission_denied"), new R(
          "User does not have permission to stop livestreaming",
          "1901"
        );
      if (this.state !== "LIVESTREAMING" && this.state !== "WAITING_ON_MANUAL_INGESTION")
        throw this.logger.error("DyteLivestream::stop::inconsistent_state"), new R("Livestream not started yet", "1902");
      try {
        this.setLivestreamState("STOPPING"), yield lt().stopLivestreaming();
      } catch (e) {
        throw this.logger.error("DyteLivestream::stop::livestream_failed_to_stop", {
          error: e
        }), this.setLivestreamState("STOPPING"), new R("Error while stopping livestream", "1900", this.logger);
      }
    });
  }
};
ln = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap();
Hf([
  E.trace("livestream.start")
], $h.prototype, "start", 1);
Hf([
  E.trace("livestream.stop")
], $h.prototype, "stop", 1);
var A0 = Object.defineProperty;
var M0 = Object.getOwnPropertyDescriptor;
var D0 = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? M0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && A0(t, e, i), i;
}, "D0");
var un;
var hn;
var Ys;
var Ms;
var Bf = class {
  static {
    __name(this, "Bf");
  }
  constructor(t, e, r) {
    h(this, "livestream");
    g(this, un, void 0);
    g(this, hn, void 0);
    g(this, Ys, void 0);
    g(this, Ms, void 0);
    m(this, Ms, t), m(this, hn, e), this.livestream = new $h(t, e), m(this, Ys, r), this.setupEvents();
  }
  get logger() {
    return a(this, Ms).getValue("logger");
  }
  get telemetry() {
    return a(this, Ms).getValue("telemetry");
  }
  fetchInitialLivestreamingState() {
    return u(this, null, function* () {
      const t = lt(), {
        status: e,
        playbackUrl: r,
        manualIngest: i,
        ingestionCredentials: n
      } = yield t.getActiveLivestream();
      this.livestream.playbackUrl = r, this.livestream.ingestionCredentials = n, e === "LIVE" && this.livestream.setLivestreamState("LIVESTREAMING"), e === "INVOKED" && i && this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
    });
  }
  setupEvents() {
    a(this, Ys).on(
      x.startedLivestream,
      (t) => u(this, null, function* () {
        this.livestream.playbackUrl = t.playbackUrl, this.livestream.setLivestreamState("LIVESTREAMING");
        try {
          a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
        } catch (e) {
          this.logger.error("Error: LivestreamController.fetchLivestream during startedLivestream re-fetch");
        }
      })
    ), a(this, Ys).on(
      x.livestreamingInvoked,
      (t) => u(this, null, function* () {
        if (t.manualIngest) {
          this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
          try {
            a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
          } catch (e) {
            this.logger.error("Error: LivestreamController.fetchLivestream during livestreamingInvoked re-fetch");
          }
        }
      })
    ), a(this, Ys).on(x.stoppedLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0, this.livestream.ingestionCredentials = void 0;
    }), a(this, Ys).on(x.erroredLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0;
    }), a(this, Ys).on(
      x.roomPeerCount,
      (t) => {
        this.livestream.viewerCount = t.count, this.livestream.emit("viewerCountUpdate", t.count);
      }
    ), a(this, Ms).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (t) => u(this, null, function* () {
        var e;
        ((e = t.flags) == null ? void 0 : e.hiddenParticipant) === true && t.recorderType === "LIVESTREAMER" && (m(this, un, t.id), this.livestream.setLivestreamState("LIVESTREAMING"));
      })
    ), a(this, Ms).getValue("peerSessionStore").on(k.PEER_CLOSED, (t) => {
      t.id === a(this, un) && (m(this, un, void 0), this.livestream.setLivestreamState("IDLE"));
    }), a(this, Ms).getValue("peerSessionStore").onAsync(k.LEAVE_MEDIA_ROOM, () => u(this, null, function* () {
      if (!this.livestream.playbackUrl) {
        this.logger.info("Fetching livestreaming state on leave stage");
        try {
          yield this.fetchInitialLivestreamingState();
        } catch (t) {
          this.logger.error("Failed to fetch livestreaming state on leave stage", { error: t });
        }
      }
    })), a(this, Ms).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      try {
        yield this.fetchInitialLivestreamingState();
      } catch (t) {
        this.logger.error("Error: LivestreamController.fetchLivestream");
      }
    }));
  }
};
un = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakMap(), Ys = /* @__PURE__ */ new WeakMap(), Ms = /* @__PURE__ */ new WeakMap();
D0([
  E.trace("LivestreamController.setupEvents")
], Bf.prototype, "setupEvents", 1);
var O0 = Object.defineProperty;
var N0 = Object.getOwnPropertyDescriptor;
var Qc = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? N0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && O0(t, e, i), i;
}, "Qc");
var nt;
var Ur;
var $r;
var Kd;
var qf;
var Yn = class {
  static {
    __name(this, "Yn");
  }
  constructor({ name: t, socketHandler: e, meetingId: r }) {
    g(this, Kd);
    h(this, "name", "");
    g(this, nt, {});
    g(this, Ur, "");
    g(this, $r, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "bulkRateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "listeners", {});
    this.name = t, m(this, $r, e), m(this, Ur, r);
  }
  set(t, e, r = true, i = false) {
    return u(this, null, function* () {
      a(this, nt)[t] = e, r && this.remoteSet(t, e), i && (this.listeners[t] && this.listeners[t].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ), this.listeners["*"] && this.listeners["*"].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ));
    });
  }
  remoteSet(t, e) {
    a(this, $r).storeInsertKeys(a(this, Ur), this.name, [{ key: t, payload: e }]);
  }
  bulkSet(t) {
    return u(this, null, function* () {
      t.forEach(({ key: e, payload: r }) => {
        a(this, nt)[e] = r;
      }), a(this, $r).storeInsertKeys(a(this, Ur), this.name, t);
    });
  }
  update(t, e, r = true) {
    return u(this, null, function* () {
      L(this, Kd, qf).call(this, t, e, r);
    });
  }
  delete(t, e = true, r = false) {
    return u(this, null, function* () {
      if (a(this, nt)[t] && delete a(this, nt)[t], e)
        return a(this, $r).storeDeleteKeys(
          a(this, Ur),
          this.name,
          [{ key: t }]
        );
      r && (this.listeners[t] && (this.listeners[t].forEach((i) => i({ [t]: void 0 })), delete this.listeners[t]), this.listeners["*"] && this.listeners["*"].forEach((i) => i({ [t]: void 0 })));
    });
  }
  bulkDelete(t) {
    return u(this, null, function* () {
      return t.forEach(({ key: e }) => {
        a(this, nt)[e] && delete a(this, nt)[e];
      }), a(this, $r).storeDeleteKeys(
        a(this, Ur),
        this.name,
        t
      );
    });
  }
  get(t) {
    if (a(this, nt)[t])
      return a(this, nt)[t];
  }
  getAll() {
    return a(this, nt);
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  get bulkRateLimits() {
    return this.bulkRateLimitConfig;
  }
  updateBulkRateLimits(t, e) {
    this.bulkRateLimitConfig.maxInvocations = t, this.bulkRateLimitConfig.period = e;
  }
  subscribe(t, e) {
    if (this.listeners[t]) {
      this.listeners[t].push(e);
      return;
    }
    this.listeners[t] = [e];
  }
  unsubscribe(t, e) {
    var r;
    if (e) {
      this.listeners[t] = ((r = this.listeners[t]) == null ? void 0 : r.filter((i) => i !== e)) || [];
      return;
    }
    this.listeners[t] && delete this.listeners[t];
  }
  populate(t) {
    m(this, nt, t);
  }
};
nt = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), Kd = /* @__PURE__ */ new WeakSet(), qf = /* @__PURE__ */ __name(function(t, e, r = true) {
  let i;
  const n = a(this, nt)[t], o = Object.prototype.toString.call(e), c = Object.prototype.toString.call(n);
  if (o !== c) {
    this.set(t, e);
    return;
  }
  switch (c) {
    case "[object Array]":
      i = [...n, ...e];
      break;
    case "[object Object]":
      i = D(D({}, n), e);
      break;
    case "[object Map]":
      i = new Map([...n, ...e]);
      break;
    case "[object Set]":
      i = /* @__PURE__ */ new Set([...n, ...e]);
      break;
    default:
      i = e;
      break;
  }
  this.set(t, i, r);
}, "qf");
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "remoteSet", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkSet", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "update", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "delete", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkDelete", 1);
var Ai;
var Mi;
var tc;
var zu;
var sc;
var Fr;
var zd;
var jf;
var V0 = class {
  static {
    __name(this, "V0");
  }
  constructor(t, e) {
    g(this, tc);
    g(this, zd);
    h(this, "stores", /* @__PURE__ */ new Map());
    g(this, Ai, void 0);
    g(this, Mi, "");
    g(this, sc, void 0);
    g(this, Fr, /* @__PURE__ */ new Map());
    m(this, Ai, e), m(this, Mi, t.getValue("meetingId")), m(this, sc, t), L(this, zd, jf).call(this);
  }
  create(t) {
    const e = new Yn(
      { name: t, socketHandler: a(this, Ai), meetingId: a(this, Mi) }
    );
    return a(this, Ai).storeGetKeys(a(this, Mi), t, []), new Promise((i, n) => {
      const o = setTimeout(() => n(Error("Failed")), 3e3);
      a(this, Fr).set(t, { rejectTimeout: o, resolve: i, store: e });
    });
  }
};
Ai = /* @__PURE__ */ new WeakMap(), Mi = /* @__PURE__ */ new WeakMap(), tc = /* @__PURE__ */ new WeakSet(), zu = /* @__PURE__ */ __name(function() {
  return a(this, sc).getValue("peerId");
}, "zu"), sc = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), zd = /* @__PURE__ */ new WeakSet(), jf = /* @__PURE__ */ __name(function() {
  [
    W.storeInsertKeys,
    W.storeGetKeys,
    W.storeDeleteKeys
  ].forEach((t) => {
    a(this, Ai).on(
      t,
      (e) => u(this, null, function* () {
        var n, o;
        if (e.pluginId !== a(this, Mi))
          return;
        const r = (n = e.storeItems) == null ? void 0 : n.map((c) => {
          var d;
          return {
            timestamp: c.timestamp,
            peerId: c.peerId,
            payload: JSON.parse(
              (d = c.payload) != null && d.length ? new TextDecoder().decode(c.payload) : "{}"
            ),
            key: c.storeKey
          };
        });
        if (t === W.storeGetKeys) {
          const c = a(this, Fr).get(e.storeName), d = this.stores.get(e.storeName) || (c == null ? void 0 : c.store);
          a(this, Fr).get(e.storeName) && (this.stores.set(e.storeName, c.store), c.resolve(d), clearTimeout(c.rejectTimeout), a(this, Fr).delete(e.storeName)), r.forEach((l) => {
            d.set(l.key, l.payload, false, false);
          });
          return;
        }
        const i = this.stores.get(e.storeName) || ((o = a(this, Fr).get(e.storeName)) == null ? void 0 : o.store);
        i !== void 0 && (t === W.storeInsertKeys && r.forEach(({ key: c, peerId: d, payload: l }) => {
          d !== a(this, tc, zu) && i.set(c, l, false, true);
        }), t === W.storeDeleteKeys && r.forEach(({ key: c, peerId: d }) => {
          d !== a(this, tc, zu) && i.delete(c, false, true);
        }));
      })
    );
  });
}, "jf");
function gi(s) {
  var t, e, r, i, n, o, c, d, l, p, f, S, T;
  return s ? {
    media: {
      audio: {
        enabled: s.audioEnabled,
        trackId: (t = s.audioTrack) == null ? void 0 : t.id,
        permission: "mediaPermissions" in s ? (e = s.mediaPermissions) == null ? void 0 : e.audio : null
      },
      video: {
        enabled: s.videoEnabled,
        trackId: (r = s.videoTrack) == null ? void 0 : r.id,
        permission: "mediaPermissions" in s ? (i = s.mediaPermissions) == null ? void 0 : i.video : null
      },
      screenshare: {
        enabled: s.screenShareEnabled,
        permission: "mediaPermissions" in s ? (n = s.mediaPermissions) == null ? void 0 : n.screenshare : null,
        audio: {
          enabled: (c = (o = s.screenShareTracks) == null ? void 0 : o.audio) == null ? void 0 : c.enabled,
          trackId: (l = (d = s.screenShareTracks) == null ? void 0 : d.audio) == null ? void 0 : l.id
        },
        video: {
          enabled: (f = (p = s.screenShareTracks) == null ? void 0 : p.video) == null ? void 0 : f.enabled,
          trackId: (T = (S = s.screenShareTracks) == null ? void 0 : S.video) == null ? void 0 : T.id
        }
      }
    }
  } : {};
}
__name(gi, "gi");
var L0 = Object.defineProperty;
var x0 = Object.getOwnPropertyDescriptor;
var Qn = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? x0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && L0(t, e, i), i;
}, "Qn");
var U0 = 0.8;
var $0 = 1.2;
var pn;
var gn;
var $t;
var Di;
var vo;
var Hr;
var wa;
var Oi;
var yo;
var Yd;
var Gf;
var Qs;
var rc;
var Br;
var Ni;
var To;
var Xs;
var Qd;
var ic;
var Yu;
var Xd;
var Wf;
var Zd;
var Jf;
var $g;
var yr = ($g = class extends qt {
  static {
    __name(this, "$g");
  }
  constructor(t, e, r, i) {
    const n = t.getValue("logger");
    super(n);
    g(this, Di);
    g(this, Hr);
    g(this, Oi);
    g(this, Yd);
    g(this, Ni);
    g(this, ic);
    g(this, Xd);
    g(this, Zd);
    h(this, "id");
    h(this, "userId");
    h(this, "name");
    h(this, "picture");
    h(this, "isHost");
    h(this, "customParticipantId");
    h(this, "flags");
    h(this, "device");
    h(this, "videoTrack");
    h(this, "audioTrack");
    h(this, "screenShareTracks");
    h(this, "videoEnabled");
    h(this, "audioEnabled");
    h(this, "screenShareEnabled");
    h(this, "producers");
    h(this, "manualProducerConfig");
    g(this, pn, void 0);
    h(this, "supportsRemoteControl", false);
    g(this, gn, void 0);
    h(this, "presetName");
    g(this, $t, void 0);
    g(this, Qs, void 0);
    g(this, rc, void 0);
    g(this, Br, /* @__PURE__ */ new Map());
    g(this, Xs, 1);
    g(this, Qd, Ih((t2) => {
      if (!this.videoTrack)
        return;
      const { clientWidth: e2, clientHeight: r2 } = t2, { width: i2, height: n2 } = this.videoTrack.getSettings();
      if (!i2 || !n2)
        return;
      const o2 = n2 / r2, c2 = i2 / e2, d2 = Math.max(o2, c2);
      d2 > $0 && a(this, Xs) === 1 ? (m(this, Xs, 0), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      })) : d2 < U0 && a(this, Xs) === 0 && (m(this, Xs, 1), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      }));
    }, 2e3));
    m(this, $t, t);
    const {
      id: o,
      userId: c,
      displayName: d,
      device: l,
      picture: p,
      isHost: f,
      flags: S,
      clientSpecificId: T,
      stageStatus: _,
      customParticipantId: P,
      audioMuted: w,
      audioTrack: A,
      videoEnabled: N = false,
      videoTrack: H,
      producers: $,
      metadata: F
    } = e;
    this.id = o, this.userId = c, this.name = d, this.device = l, this.picture = p, this.isHost = f, this.flags = S, this.manualProducerConfig = EC, m(this, gn, _ != null ? _ : "ON_STAGE"), this.customParticipantId = P != null ? P : T, this.audioEnabled = !w, this.audioTrack = A, this.videoEnabled = N, this.videoTrack = H, this.screenShareTracks = {
      audio: void 0,
      video: void 0
    }, this.producers = $ != null ? $ : [], this.presetName = F == null ? void 0 : F.preset_name, m(this, pn, false), m(this, Qs, r), m(this, rc, i), this.setupEvents(), this.updateVideo = this.updateVideo.bind(this), L(this, ic, Yu).call(this);
  }
  get clientSpecificId() {
    return this.customParticipantId;
  }
  get stageStatus() {
    return a(this, gn);
  }
  get telemetry() {
    return a(this, $t).getValue("telemetry");
  }
  setVideoEnabled(t, e = true) {
    this.videoEnabled = t, e && (this.logger.info("DyteParticipant::setVideoEnabled::videoUpdate", D({}, gi(this))), this.emit("videoUpdate", {
      videoEnabled: this.videoEnabled,
      videoTrack: this.videoTrack
    }));
  }
  setAudioEnabled(t, e = true) {
    this.audioEnabled = t, e && (this.logger.info("DyteParticipant::setAudioEnabled::audioUpdate", D({}, gi(this))), this.emit("audioUpdate", {
      audioEnabled: this.audioEnabled,
      audioTrack: this.audioTrack
    }));
  }
  setScreenShareEnabled(t, e = true) {
    this.screenShareEnabled = t, e && this.emit("screenShareUpdate", {
      screenShareEnabled: this.screenShareEnabled,
      screenShareTracks: this.screenShareTracks
    });
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ic, Yu)), a(this, Hr, wa) && (this.on("audioUpdate", L(this, Xd, Wf)), this.on("screenShareUpdate", L(this, Zd, Jf)));
  }
  pin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t pin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to pin participants.", "1201");
      return a(this, Di, vo).pinPeer(this.id);
    });
  }
  unpin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t unpin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to unpin participants.", "1201");
      return a(this, Di, vo).pinPeer(null);
    });
  }
  setIsPinned(t, e = true) {
    var i;
    m(this, pn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, Ni, To)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  disableAudio() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_audio", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant audio without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantAudio)
        return a(this, Di, vo).disableAudio(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_audio", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant audio.",
        "1201"
      );
    });
  }
  kick() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::kick", {
        dyteParticipant: { id: t }
      }), !a(this, Yd, Gf))
        throw new R("Can`t kick participant without joining room", "1205");
      if (a(this, Qs).permissions.kickParticipant) {
        yield a(this, $t).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
          peerId: t
        });
        return;
      }
      throw this.logger.error("DyteParticipant::unauthorized_kick", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to kick participants.",
        "1201"
      );
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_video", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant video without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantVideo)
        return a(this, Di, vo).disableVideo(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_video", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant video.",
        "1201"
      );
    });
  }
  getPermissions() {
    return u(this, null, function* () {
      return a(this, rc).getUserPermissions(this.userId);
    });
  }
  setStageStatus(t) {
    m(this, gn, t), this.emit("stageStatusUpdate", this);
  }
  get isPinned() {
    return a(this, pn);
  }
  registerVideoElement(t) {
    var r, i, n, o;
    if (!t)
      return;
    let e;
    (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), "ResizeObserver" in window && (e = new ResizeObserver(() => a(this, Qd).call(this, t)), e.observe(t)), a(this, Br).set(t, { observer: e }), this.updateVideo(t), (o = a(this, Ni, To)) == null || o.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (n = this.raised) != null ? n : false
    );
  }
  deregisterVideoElement(t) {
    var e, r, i, n;
    if (!t) {
      (e = a(this, Ni, To)) == null || e.removeSource(this.id);
      return;
    }
    t.srcObject = void 0, (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), a(this, Br).delete(t), (n = a(this, Ni, To)) == null || n.removeSource(this.id);
  }
  updateVideo(t) {
    var e;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const r = (e = t.srcObject) == null ? void 0 : e.getTracks()[0];
      if ((r == null ? void 0 : r.id) === this.videoTrack.id)
        return;
      const i = new MediaStream();
      i.addTrack(this.videoTrack), t.srcObject = i;
    } else
      t.srcObject = void 0;
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, pn = /* @__PURE__ */ new WeakMap(), gn = /* @__PURE__ */ new WeakMap(), $t = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakSet(), vo = /* @__PURE__ */ __name(function() {
  return a(this, $t).getValue("roomNodeClient");
}, "vo"), Hr = /* @__PURE__ */ new WeakSet(), wa = /* @__PURE__ */ __name(function() {
  return a(this, $t).getValue("audioPlayback");
}, "wa"), Oi = /* @__PURE__ */ new WeakSet(), yo = /* @__PURE__ */ __name(function() {
  return a(this, $t).getValue("connectionHandler").mediaJoined;
}, "yo"), Yd = /* @__PURE__ */ new WeakSet(), Gf = /* @__PURE__ */ __name(function() {
  return a(this, $t).getValue("connectionHandler").socketJoined;
}, "Gf"), Qs = /* @__PURE__ */ new WeakMap(), rc = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), Ni = /* @__PURE__ */ new WeakSet(), To = /* @__PURE__ */ __name(function() {
  return a(this, $t).getValue("pip");
}, "To"), Xs = /* @__PURE__ */ new WeakMap(), Qd = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakSet(), Yu = /* @__PURE__ */ __name(function() {
  Array.from(a(this, Br).keys()).forEach(this.updateVideo);
}, "Yu"), Xd = /* @__PURE__ */ new WeakSet(), Wf = /* @__PURE__ */ __name(function() {
  var t, e;
  this.audioEnabled && this.audioTrack ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(this.id, this.audioTrack) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(this.id);
}, "Wf"), Zd = /* @__PURE__ */ new WeakSet(), Jf = /* @__PURE__ */ __name(function() {
  var t, e;
  this.screenShareEnabled && this.screenShareTracks.audio ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(`screenshare-${this.id}`, this.screenShareTracks.audio) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(`screenshare-${this.id}`);
}, "Jf"), $g);
Qn([
  E.trace("DyteParticipant.disableAudio")
], yr.prototype, "disableAudio", 1);
Qn([
  E.trace("DyteParticipant.kick")
], yr.prototype, "kick", 1);
Qn([
  E.trace("DyteParticipant.disableVideo")
], yr.prototype, "disableVideo", 1);
Qn([
  E.trace("DyteParticipant.getPermissions")
], yr.prototype, "getPermissions", 1);
Qn([
  E.trace("DyteParticipant.setStageStatus")
], yr.prototype, "setStageStatus", 1);
yr = Qn([
  ht("1200")
], yr);
var mi = class extends Vf {
  static {
    __name(this, "mi");
  }
  constructor(t, e) {
    const {
      onAddEvent: r = "participantJoined",
      onDeleteEvent: i = "participantLeft",
      onClearEvent: n = "participantsCleared"
    } = e != null ? e : {};
    super({
      onAddEvent: r,
      onDeleteEvent: i,
      onClearEvent: n
    }, t);
  }
  add(t, e = true) {
    return this.has(t.id) && Object.is(this.get(t.id), t) === false && this.delete(t.id), super.add(t, e);
  }
  clear(t = true, e = false) {
    return super.clear(t, e);
  }
  delete(t, e = true, r = false) {
    return super.delete(t, e, r);
  }
};
var qr;
var F0 = class extends Jn {
  static {
    __name(this, "F0");
  }
  constructor(e) {
    super(e);
    g(this, qr, void 0);
    m(this, qr, /* @__PURE__ */ new Map());
  }
  __set(e, r) {
    return a(this, qr).set(e, r);
  }
  __clear() {
    return a(this, qr).clear();
  }
  get(e) {
    return a(this, qr).get(e);
  }
  toArray() {
    return Array.from(a(this, qr).values());
  }
};
qr = /* @__PURE__ */ new WeakMap();
var H0 = class {
  static {
    __name(this, "H0");
  }
  constructor() {
    h(this, "_orderedArray");
    h(this, "_map");
    this._map = /* @__PURE__ */ new Map(), this._orderedArray = [];
  }
  add(t, e) {
    if (!this._map.has(t))
      return this._map.set(t, { peerId: t, priority: e }), this._orderedArray.splice(Math.max(e - 1, 0), 0, t), this.index(t);
    const r = this.index(t);
    this.delete(t);
    const i = this.add(t, e);
    return r !== i ? i : -1;
  }
  delete(t) {
    if (this._map.has(t)) {
      const e = this.index(t);
      this._map.delete(t), this._orderedArray.splice(e, 1);
    }
  }
  index(t) {
    return this._map.has(t) ? this._orderedArray.indexOf(t) : -1;
  }
  [Symbol.iterator]() {
    return this._orderedArray[Symbol.iterator]();
  }
};
var B0 = class {
  static {
    __name(this, "B0");
  }
  constructor() {
    h(this, "_activeSpeakerPeers");
    h(this, "_compulsoryPeers");
    this._activeSpeakerPeers = new H0(), this._compulsoryPeers = /* @__PURE__ */ new Set();
  }
  add(t, e, r) {
    if (!t)
      return -1;
    if (e < 0)
      return this._compulsoryPeers.add(t), 0;
    const i = r.getValue("logger");
    if (this.compulsoryPeers.includes(t) && (e > 0 || e === 246267631)) {
      if (i.info("DyteSelectedPeer::removing_compulsory_peer", {
        selectedPeer: {
          peerId: t
        }
      }), this._removeFromCompulsoryPeer(t), e === 246267631)
        return -1;
    } else if (e === 229490415)
      return this.delete(t, r), -1;
    return this._activeSpeakerPeers.add(t, e);
  }
  delete(t, e) {
    const r = e == null ? void 0 : e.getValue("logger");
    r == null || r.info("DyteSelectedPeer::deleting_peer_from_selectedPeer", {
      selectedPeer: {
        peerId: t
      }
    }), this._removeFromCompulsoryPeer(t), this._activeSpeakerPeers.delete(t);
  }
  index(t) {
    return this._activeSpeakerPeers.index(t);
  }
  get peers() {
    return Array.from(new Set(this.compulsoryPeers.concat(this.activeSpeakerPeers)));
  }
  get compulsoryPeers() {
    return Array.from(this._compulsoryPeers.values());
  }
  get activeSpeakerPeers() {
    return Array.from(this._activeSpeakerPeers);
  }
  _removeFromCompulsoryPeer(t) {
    this._compulsoryPeers.delete(t);
  }
};
var Kf = new B0();
var q0 = Object.defineProperty;
var j0 = Object.getOwnPropertyDescriptor;
var Wt = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? j0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && q0(t, e, i), i;
}, "Wt");
var G0 = ["ACTIVE_GRID", "PAGINATED", "MANUAL"];
var Le;
var Vi;
var Eo;
var Li;
var _o;
var mn;
var Td;
var xi;
var wt;
var Fg;
var Pt = (Fg = class extends qt {
  static {
    __name(this, "Fg");
  }
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    g(this, Vi);
    g(this, Li);
    g(this, mn);
    h(this, "waitlisted");
    h(this, "joined");
    h(this, "active");
    h(this, "videoSubscribed");
    h(this, "audioSubscribed");
    h(this, "pinned");
    h(this, "all");
    g(this, Le, void 0);
    g(this, xi, void 0);
    g(this, wt, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "viewMode");
    h(this, "currentPage");
    h(this, "lastActiveSpeaker");
    h(this, "selectedPeers", Kf);
    m(this, Le, t), m(this, xi, e), m(this, wt, r), this.waitlisted = new mi(i), this.joined = new mi(i), this.videoSubscribed = new mi(i), this.audioSubscribed = new mi(i), this.active = this.videoSubscribed, this.pinned = new mi(i), this.all = new F0(i), this.viewMode = "ACTIVE_GRID", this.currentPage = 0, this.setupEvents();
  }
  get pip() {
    return a(this, Le).getValue("pip");
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  get telemetry() {
    return a(this, Le).getValue("telemetry");
  }
  setupEvents() {
    a(this, Le).getValue("peerSessionStore").on(k.E2EE_ACTIVE_CONSUMER, ({ peerId: e }) => {
      var r;
      ((r = a(this, Le).getValue("modules").e2ee) == null ? void 0 : r.enabled) !== true && this.emit("media_decode_error", {
        reason: `Got encrypted media for participantId ${e}, but encryption wasn't enabled in init.defaults`,
        code: "1702"
      });
    });
    const t = a(this, Le).getValue("audioPlayback");
    t && this.audioSubscribed.on("participantLeft", (e) => {
      t.removeParticipantTrack(e.id);
    });
  }
  get count() {
    return this.joined.size;
  }
  get maxActiveParticipantsCount() {
    var t;
    return (t = a(this, Le)) == null ? void 0 : t.getValue("maxPreferredStreams");
  }
  setMaxActiveParticipantsCount(t) {
    if (t < 0 || t > 24)
      throw new R("0 <= Max active participants count limit <= 24", "1203");
    a(this, Le).setValue("maxPreferredStreams", t), a(this, mn, Td) && a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  get pageCount() {
    if (this.viewMode === "PAGINATED") {
      const t = this.selectedPeers.compulsoryPeers.length, e = this.joined.toArray().filter((r) => r.stageStatus === "ON_STAGE");
      return Math.ceil(
        (e.length - t) / Math.max(this.maxActiveParticipantsCount - t, 1)
      );
    }
    return 0;
  }
  acceptWaitingRoomRequest(t) {
    var r, i;
    if (!a(this, Li, _o))
      throw new R(
        "Can`t accept waiting room request without joining room",
        "1205"
      );
    const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
    return a(this, wt).acceptWaitingRoomRequest([e]);
  }
  acceptAllWaitingRoomRequest(t) {
    return u(this, null, function* () {
      const e = t.map((r) => {
        var i, n;
        return (n = (i = this.waitlisted.get(r)) == null ? void 0 : i.userId) != null ? n : r;
      });
      return a(this, wt).acceptWaitingRoomRequest(e);
    });
  }
  rejectWaitingRoomRequest(t) {
    return u(this, null, function* () {
      var r, i;
      if (!a(this, Li, _o))
        throw new R(
          "Can`t reject waiting room request without joining room",
          "1205"
        );
      const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
      a(this, wt).rejectWaitingRoomRequest([e]);
    });
  }
  setViewMode(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_view_mode", {
        pageNavigation: {
          viewMode: t,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), !((r) => G0.includes(r))(t))
        throw this.logger.error("DyteParticipants::setViewMode::invalid_view_mode", {
          pageNavigation: {
            viewMode: t,
            currentPage: this.currentPage,
            pageCount: this.pageCount,
            maxActiveParticipantsCount: this.maxActiveParticipantsCount
          }
        }), new R(
          `Invalid view mode: ${t}. Try ACTIVE_GRID, PAGINATED or MANUAL.`,
          "1207"
        );
      if (this.viewMode === t) {
        this.logger.info(
          "DyteParticipants::setViewMode::view_mode_same_as_previous"
        );
        return;
      }
      if (t === "MANUAL")
        throw new R(
          "Manual Subscription is not enabled for your Organization. Please contact support.",
          "1208"
        );
      this.viewMode = t, t === "PAGINATED" ? (this.currentPage = 1, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: this.currentPage })) : t === "ACTIVE_GRID" && (this.currentPage = 0, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE)), this.emit("viewModeChanged", {
        viewMode: t,
        currentPage: this.currentPage,
        pageCount: this.pageCount
      });
    });
  }
  subscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: true
            }), this.videoSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: true
            }), this.audioSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: true
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: true
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).createConsumers(i);
    });
  }
  unsubscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: false
            });
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: false
            });
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: false
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: false
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).closeConsumers(i);
    });
  }
  getPeerIdsForCurrentPage() {
    this.logger.info("DyteParticipants::getPeerIdsForCurrentPage()", {
      pageNavigation: {
        viewMode: this.viewMode,
        currentPage: this.currentPage,
        pageCount: this.pageCount,
        maxActiveParticipantsCount: this.maxActiveParticipantsCount
      }
    });
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (c) => this.joined.has(c)
    ), r = Array.from(this.pinned.keys()).filter(
      (c) => !e.includes(c)
    ), i = Array.from(this.joined.toArray().filter((c) => c.stageStatus === "ON_STAGE").map((c) => c.id)), n = Math.max(
      (this.currentPage - 1) * (this.maxActiveParticipantsCount - e.length - r.length)
    ), o = this.currentPage * (this.maxActiveParticipantsCount - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  setPage(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_page", {
        pageNavigation: {
          settingPage: t,
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), this.viewMode === "PAGINATED") {
        if (!Number.isInteger(t))
          throw this.logger.error("DyteParticipants::invalid_page_number"), new R(`Invalid page: ${t}. Page must be an integer and greater than 0 and less than or equal to .pageCount`, "1202");
        this.currentPage = t, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: t }), this.emit("pageChanged", {
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount
        });
      }
    });
  }
  disableAllAudio(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), !a(this, mn, Td))
        throw new R("Can`t disable all audio without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantAudio)
        return a(this, Vi, Eo).muteAll(t);
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), new R(
        "Unauthorized: User does not have permission to disable peer audio.",
        "1201"
      );
    });
  }
  disableAllVideo() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_video"), !a(this, mn, Td))
        throw new R("Can`t disable all video without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantVideo)
        return a(this, Vi, Eo).muteAllVideo();
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_video"), new R(
        "Unauthorized: User does not have permission to disable peer video.",
        "1201"
      );
    });
  }
  disableAudio(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableAudio();
    });
  }
  disableVideo(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableVideo();
    });
  }
  kick(t) {
    return u(this, null, function* () {
      yield a(this, Le).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
        peerId: t
      });
    });
  }
  kickAll() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::kick_all"), a(this, Le).getValue("viewType") !== "LIVESTREAM" && !a(this, Li, _o))
        throw new R("Can`t kick all without joining room", "1205");
      if (!a(this, xi).permissions.kickParticipant)
        throw this.logger.error("DyteParticipants::unauthorized_kick_all"), new R(
          "Unauthorized: User does not have permission to kick peers.",
          "1201"
        );
      const e = a(this, Le).getValue("flagsmith").hasFeature(X.PROPAGATE_KICK_ALL);
      a(this, wt).kickAll(e);
    });
  }
  broadcastMessage(t, e, r) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::broadcastMessage"), !a(this, Li, _o))
        throw new R("Can`t broadcast message without joining room", "1205");
      if (!(t != null && t.trim()))
        throw new R("`type` must be a non-empty string.", "1209");
      if (r)
        if ("meetingIds" in r)
          yield a(this, wt).broadcastToMeetings(t, r.meetingIds, e);
        else {
          let i = [];
          "participantIds" in r ? i = r.participantIds : i = this.joined.toArray().filter(
            (n) => {
              var o;
              return (o = r.presetNames) == null ? void 0 : o.includes(n.presetName);
            }
          ).map((n) => n.id), yield a(this, wt).broadcastToPeers(t, i, e);
        }
      else
        yield a(this, wt).broadcastMessage(t, e);
    });
  }
  getAllJoinedPeers(t, e, r) {
    return u(this, null, function* () {
      return (yield a(this, wt).getRoomPeers(t, e, r)).peers.map(_r.formatSocketServiceMessage);
    });
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = this.joined.toArray().filter((n) => t.includes(n.id)).map((n) => n.userId), i = [...new Set(r)];
      if (!i.length)
        throw new R("Cannot update permissions, no valid userIDs found", "1204");
      a(this, wt).updatePermissions(i, e);
    });
  }
  getParticipantsInMeetingPreJoin() {
    return u(this, null, function* () {
      return a(this, wt).getRoomPeersNonPaginated();
    });
  }
}, Le = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakSet(), Eo = /* @__PURE__ */ __name(function() {
  return a(this, Le).getValue("roomNodeClient");
}, "Eo"), Li = /* @__PURE__ */ new WeakSet(), _o = /* @__PURE__ */ __name(function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === true;
}, "_o"), mn = /* @__PURE__ */ new WeakSet(), Td = /* @__PURE__ */ __name(function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === true;
}, "Td"), xi = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), Fg);
Wt([
  E.trace("DyteParticipants.setViewMode")
], Pt.prototype, "setViewMode", 1);
Wt([
  E.trace("DyteParticipants.setPage")
], Pt.prototype, "setPage", 1);
Wt([
  E.trace("DyteParticipants.disableAllAudio")
], Pt.prototype, "disableAllAudio", 1);
Wt([
  E.trace("DyteParticipants.disableAllVideo")
], Pt.prototype, "disableAllVideo", 1);
Wt([
  E.trace("DyteParticipants.disablePeerAudio")
], Pt.prototype, "disableAudio", 1);
Wt([
  E.trace("DyteParticipants.disablePeerVideo")
], Pt.prototype, "disableVideo", 1);
Wt([
  E.trace("DyteParticipants.kickPeer")
], Pt.prototype, "kick", 1);
Wt([
  E.trace("DyteParticipants.kickAll")
], Pt.prototype, "kickAll", 1);
Wt([
  E.trace("DyteParticipants.broadcastMessage"),
  Dt(zn, "rateLimitConfig")
], Pt.prototype, "broadcastMessage", 1);
Wt([
  E.trace("DyteParticipants.getAllJoinedPeers"),
  Dt({ maxInvocations: 10, period: 60 })
], Pt.prototype, "getAllJoinedPeers", 1);
Wt([
  E.trace("DyteParticipant.updatePermissions"),
  Dt({ maxInvocations: 1e3, period: 60 })
], Pt.prototype, "updatePermissions", 1);
Wt([
  E.trace("DyteParticipants.getParticipantsInMeetingPreJoin")
], Pt.prototype, "getParticipantsInMeetingPreJoin", 1);
Pt = Wt([
  ht("1200")
], Pt);
var xa = /* @__PURE__ */ ((s) => (s.NEW = "new", s.CONNECTING = "connecting", s.RECONNECTING = "reconnecting", s.DISCONNECTED = "disconnected", s.CONNECTED = "connected", s.FAILED = "failed", s.CLOSED = "closed", s))(xa || {});
var we = /* @__PURE__ */ ((s) => (s[s.HIVE = 1] = "HIVE", s[s.ROOM_NODE = 2] = "ROOM_NODE", s[s.CF = 3] = "CF", s))(we || {});
var W0 = Object.defineProperty;
var J0 = Object.getOwnPropertyDescriptor;
var Ea = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? J0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && W0(t, e, i), i;
}, "Ea");
var Zs;
var er;
var tr;
var Ui;
var fn;
var Hg;
var ba = (Hg = class {
  static {
    __name(this, "Hg");
  }
  constructor(s, t, e, r) {
    h(this, "participants");
    h(this, "self");
    h(this, "selectedPeers", Kf);
    h(this, "maxSpatialLayerUpdates", /* @__PURE__ */ new Map());
    h(this, "consumerPeerMap");
    h(this, "events");
    h(this, "roomSocketHandler");
    h(this, "context");
    h(this, "videoPeerConsumerMap", /* @__PURE__ */ new Map());
    g(this, Zs, { mode: "ACTIVE_GRID", page: 0 });
    g(this, er, void 0);
    g(this, tr, void 0);
    g(this, Ui, false);
    g(this, fn, false);
    h(this, "updateConsumerSpatialLayers", Ih(() => {
      const s2 = {}, t2 = new Map(this.maxSpatialLayerUpdates);
      this.maxSpatialLayerUpdates.clear(), Array.from(t2.entries()).forEach(([e2, r2]) => {
        s2[r2] === void 0 && (s2[r2] = {
          layer: r2,
          consumerIds: []
        }), s2[r2].consumerIds.push(e2);
      }), Object.keys(s2).forEach((e2) => {
        const r2 = s2[e2];
        this.logger.log(`Switching max spatial layer to ${r2.layer}`, { consumerIds: r2.consumerIds }), this.roomNodeClient.switchConsumersToLayer(r2.consumerIds, r2.layer);
      });
    }, 2e3));
    h(this, "updateConsumers", (s2, t2) => u(this, null, function* () {
      try {
        s2.length !== 0 && (this.logger.info("Queueing create consumers for producers", { producers: s2 }), yield this.roomNodeClient.createConsumers(s2));
      } catch (e2) {
        this.logger.error("Error activating peers", { error: e2 });
      }
      try {
        t2.length !== 0 && (this.logger.info("Queueing close consumers for producers", { producers: t2 }), yield this.roomNodeClient.closeConsumers(t2));
      } catch (e2) {
        this.logger.error("Error deactivating peers", { error: e2 });
      }
    }));
    this.context = s;
    const i = s.getValue("logger");
    switch (m(this, er, new mi(i)), m(this, tr, new mi(i)), this.roomSocketHandler = e, this.participants = new Pt(s, t, this.roomSocketHandler), this.self = t, this.consumerPeerMap = /* @__PURE__ */ new Map(), r) {
      case we.HIVE: {
        this.events = is;
        break;
      }
      case we.CF: {
        this.events = Ts;
        break;
      }
      default:
        this.events = is;
    }
    t.config.viewType !== "CHAT" && this.setupEventsGlobal(), this.setupEvents();
  }
  get roomNodeClient() {
    return this.context.getValue("roomNodeClient");
  }
  get mediaJoined() {
    var s;
    return ((s = this.roomNodeClient) == null ? void 0 : s.mediaJoined) === true;
  }
  get pip() {
    return this.context.getValue("pip");
  }
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  setupEvents() {
    this.roomSocketHandler.on(
      x.getWaitingRoomRequests,
      this.waitingRoomRequestHandler.bind(this)
    ), this.context.getValue("peerSessionStore").on(k.SOCKET_PEERS, (s) => u(this, null, function* () {
      const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
      if (t) {
        const e = s && (s == null ? void 0 : s.length) < 20 ? {
          peers: JSON.stringify(s.map((r) => r.peerId))
        } : void 0;
        this.logger.info("Processing socket peers", e);
      }
      s == null || s.forEach((e) => {
        e.waitlisted || this.onParticipantJoined(this.fromSocketService(e));
      }), t && this.logger.info("Processed socket peers");
    })), this.roomSocketHandler.on(
      this.events.peerJoinedBroadcast,
      ({ participant: s }) => {
        this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN) && this.logger.info("events.peerJoinedBroadcast", { peers: s.peerId }), this.onMediaJoined(
          s.peerId,
          s.producerStates,
          s.capabilities
        );
      }
    ), this.roomSocketHandler.on(
      this.events.selfJoinComplete,
      ({ participants: s, selectedPeers: t, roomState: e }) => {
        if (this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN)) {
          const n = s && (s == null ? void 0 : s.length) < 20 ? {
            peers: JSON.stringify(s.map((o) => o.peerId))
          } : void 0;
          this.logger.info("events.selfJoinComplete", n);
        }
        s.forEach(({ peerId: n, producerStates: o, capabilities: c }) => this.onMediaJoined(
          n,
          o,
          c
        ));
        const { audioPeers: r, compulsoryPeers: i } = t != null ? t : {};
        e.pinnedPeerIds.length !== 0 && this.onParticipantPinned(e.pinnedPeerIds[0]), this.computeActivateParticipants(r != null ? r : [], i), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: true });
      }
    ), this.context.getValue("peerSessionStore").on(
      k.MAX_SPATIAL_LAYER_CHANGE,
      ({ peerId: s, maxSpatialLayer: t }) => {
        const e = this.videoPeerConsumerMap.get(s);
        e && (this.maxSpatialLayerUpdates.set(e, t), this.updateConsumerSpatialLayers());
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_PRODUCER,
      ({ peerId: s, producer: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              },
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        if (e.producers.push(t), this.logger.info(
          "ParticipantController::NEW_PRODUCER::producer_added_to_participant",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        ), this.participants.viewMode === "MANUAL") {
          let r = false;
          const i = t.kind === "audio", n = t.kind === "video", o = e.manualProducerConfig;
          (i && (o.audio && !t.screenShare || o.screenshareAudio && t.screenShare) || n && (o.video && !t.screenShare || o.screenshareVideo && t.screenShare)) && (r = true), r ? this.roomNodeClient.createConsumers([t]) : this.logger.info(
            "ParticipantController::NEW_PRODUCER::not_consuming_producer",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                peerId: s,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              }
            }
          );
          return;
        }
        (t == null ? void 0 : t.kind) === "audio" && this.participants.audioSubscribed.get(s) || (t == null ? void 0 : t.kind) === "video" && this.participants.videoSubscribed.get(s) || t != null && t.screenShare ? this.roomNodeClient.createConsumers([t]).catch((r) => {
          this.logger.error("ParticipantController::createConsumer failed", { error: r });
        }) : this.logger.info(
          "ParticipantController::NEW_PRODUCER::not_consuming_producer",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_CLOSED,
      ({ peerId: s, producerId: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        e.producers = e.producers.filter(
          (r) => r.producerId !== t
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_TOGGLE,
      ({
        peerId: s,
        producerId: t,
        paused: e,
        kind: r
      }) => {
        const i = this.participants.joined.get(s);
        if (i) {
          r === "audio" && i.setAudioEnabled(!e);
          const n = i.producers.find(
            (o) => o.producerId === t
          );
          n && (n.pause = e);
        }
      }
    ), this.roomSocketHandler.on(
      this.events.globalPeerPinBroadcast,
      (s) => {
        let t;
        if (s && (t = s.participantId), !this.mediaJoined)
          return;
        const e = t;
        this.onParticipantPinned(e);
        const r = this.participants.joined.get(e);
        r && this.roomNodeClient.activatePeers(r.producers).catch((i) => {
          this.logger.error("unable to create consumers", {
            error: i
          });
        });
      }
    ), this.roomSocketHandler.on(this.events.selectedPeer, ({ audioPeers: s, compulsoryPeers: t }) => {
      this.mediaJoined && this.onSelectedPeers(t.concat(s));
    }), this.roomSocketHandler.on(this.events.selectedPeerDiff, ({ entries: s }) => {
      if (!this.mediaJoined)
        return;
      const t = s.map((e) => ({
        peerId: e.peerId,
        priority: e.priority
      }));
      this.updateActiveParticipantsWithPriorities(t, true);
    });
  }
  waitingRoomRequestHandler(s) {
    const t = s.requests.filter(
      (r) => !this.participants.waitlisted.toArray().find((i) => i.userId === r.userId)
    ), e = this.participants.waitlisted.toArray().filter(
      (r) => !s.requests.find((i) => i.userId === r.userId)
    );
    t.forEach((r) => this.participants.waitlisted.add(
      new yr(
        this.context,
        {
          id: r.peerId,
          displayName: r.displayName,
          audioMuted: true,
          videoEnabled: false,
          audioTrack: void 0,
          videoTrack: void 0,
          stageStatus: "OFF_STAGE",
          userId: r.userId,
          flags: {},
          isHost: false,
          customParticipantId: r.customParticipantId,
          picture: r.picture,
          metadata: {
            preset_name: r.presetName
          }
        },
        this.self,
        this.roomSocketHandler
      )
    )), e.forEach((r) => this.participants.waitlisted.delete(r.id));
  }
  get maxPreferredStreams() {
    return this.participants.maxActiveParticipantsCount;
  }
  selectPagePeers(s) {
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (d) => this.participants.joined.has(d)
    ), r = Array.from(this.participants.pinned.keys()).filter(
      (d) => !e.includes(d)
    ), i = Array.from(this.participants.joined.toArray().filter((d) => d.stageStatus === "ON_STAGE").map((d) => d.id)), n = Math.max(
      (s - 1) * (this.maxPreferredStreams - e.length - r.length)
    ), o = s * (this.maxPreferredStreams - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  selectActivePeers(s) {
    const t = /* @__PURE__ */ new Map(), e = Array.from(
      this.participants.joined.toArray().filter((p) => p.stageStatus === "ON_STAGE").map((p) => (t.set(p.id, true), p.id))
    ), r = this.selectedPeers.peers, i = this.participants.pinned.toArray().reduce((p, f) => (f.stageStatus !== "ON_STAGE" ? this.participants.pinned.delete(f.id) : p.push(f.id), p), []), n = this.self.stageStatus === "ON_STAGE" ? 1 : 0, o = s - n, c = new Set(
      r.concat(i).filter((p) => p !== this.self.id && t.has(p))
    );
    let d = Array.from(c);
    const l = o - c.size;
    if (l >= 0) {
      const p = e.filter((f) => !c.has(f) && f !== this.self.id).slice(0, l);
      d = Array.from(c).concat(p);
    } else
      d = d.slice(0, o);
    return d;
  }
  updateSubscriptions(s, t) {
    const { page: e, createAllConsumers: r } = t != null ? t : {};
    s && a(this, Zs).mode !== s && (a(this, Zs).mode = s), e && a(this, Zs).page !== e && (a(this, Zs).page = e);
    const { mode: i, page: n } = a(this, Zs);
    switch (r && (a(this, er).clear(), a(this, tr).clear()), i) {
      case "PAGINATED": {
        if (!n)
          return;
        const o = this.selectPagePeers(n), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMap(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c), this.logger.debug(
          "ParticipantController::updateActive::updating_current_page_peers",
          { peerIds: o }
        );
        break;
      }
      case "ACTIVE_GRID": {
        const o = this.selectActivePeers(this.participants.maxActiveParticipantsCount), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMapMinReplacement(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c);
        break;
      }
      default:
        throw new Error(`View mode ${s} not supported`);
    }
    setTimeout(() => this.syncConsumers(), a(this, Zs).mode === "PAGINATED" && !a(this, Ui) ? 200 : 0);
  }
  syncConsumers() {
    return u(this, null, function* () {
      var e, r, i;
      if (((i = (r = (e = this.context.getValue("connectionHandler")) == null ? void 0 : e.mediaState) == null ? void 0 : r.recv) == null ? void 0 : i.state) !== "connected")
        return;
      if (a(this, Ui)) {
        m(this, fn, true);
        return;
      }
      m(this, Ui, true), m(this, fn, false);
      let s = [], t = [];
      if (this.context.getValue("flagsmith").hasFeature(X.NEW_SYNC_CONSUMERS)) {
        const n = [], o = this.participants.videoSubscribed.toArray().reduce((P, w) => w.videoEnabled ? (n.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), c = [], d = this.participants.audioSubscribed.toArray().reduce((P, w) => w.audioEnabled ? (c.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), [l, p] = ba.mapDiff(
          a(this, er),
          o
        );
        this.updateParticipantsMap(a(this, er), n);
        const [f, S] = ba.mapDiff(
          a(this, tr),
          d
        );
        this.updateParticipantsMap(a(this, tr), c);
        const T = p.filter((P) => !this.participants.videoSubscribed.get(P)), _ = S.filter((P) => !this.participants.audioSubscribed.get(P));
        s = [
          ...this.mapPeerIdsToProducers(l, ["video"]),
          ...this.mapPeerIdsToProducers(f, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(T, ["video"]),
          ...this.mapPeerIdsToProducers(_, ["audio"])
        ];
      } else {
        const [n, o] = ba.mapDiff(
          a(this, er),
          this.participants.videoSubscribed
        );
        this.updateParticipantsMap(
          a(this, er),
          this.participants.videoSubscribed.toArray().filter(({ videoEnabled: l }) => !!l).map(({ id: l }) => l)
        );
        const [c, d] = ba.mapDiff(
          a(this, tr),
          this.participants.audioSubscribed
        );
        this.updateParticipantsMap(
          a(this, tr),
          this.participants.audioSubscribed.toArray().filter(({ audioEnabled: l }) => !!l).map(({ id: l }) => l)
        ), s = [
          ...this.mapPeerIdsToProducers(n, ["video"]),
          ...this.mapPeerIdsToProducers(c, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(o, ["video"]),
          ...this.mapPeerIdsToProducers(d, ["audio"])
        ];
      }
      try {
        (s.length > 0 || t.length > 0) && (yield this.updateConsumers(s, t));
      } finally {
        m(this, Ui, false);
      }
      a(this, fn) && this.syncConsumers();
    });
  }
  static mapDiff(s, t) {
    const e = [], r = [], i = Array.from(s.keys()), n = Array.from(t.keys());
    return i.forEach((o) => {
      n.includes(o) || r.push(o);
    }), n.forEach((o) => {
      i.includes(o) || e.push(o);
    }), [
      e,
      r
    ];
  }
  computeActivateParticipants(s, t) {
    const e = s.map((i, n) => ({
      peerId: i,
      priority: n + 1
    })), r = t == null ? void 0 : t.map((i, n) => ({
      peerId: i,
      priority: -(n + 1)
    }));
    e.push(...r != null ? r : []), e.length > 0 && this.updateActiveParticipantsWithPriorities(e);
  }
  fromSocketService(s) {
    const t = ba.formatSocketServiceMessage(s);
    return new yr(this.context, B(D({}, t), {
      isHost: false,
      videoEnabled: false,
      audioMuted: true,
      videoTrack: void 0,
      audioTrack: void 0
    }), this.self, this.roomSocketHandler);
  }
  updatePipSource(s, t) {
    var e, r;
    t ? (e = this.pip) == null || e.enableSource(s) : (r = this.pip) == null || r.disableSource(s);
  }
  onMediaJoined(s, t, e) {
    if (!this.mediaJoined || s === this.self.id)
      return;
    const r = this.participants.joined.get(s);
    if (!r) {
      this.logger.warn(`Received media.peerJoinedBroadcast for non-existent peer ${s}`);
      return;
    }
    t.forEach((i) => {
      i.kind === xs.AUDIO && !i.screenShare ? r.setAudioEnabled(!i.pause) : i.kind === xs.VIDEO && !i.screenShare && (r.setVideoEnabled(!i.pause), this.updatePipSource(r.id, !i.pause)), r.producers.push(B(D({}, i), {
        producingTransportId: i.producingTransportId,
        kind: i.kind === xs.AUDIO ? "audio" : "video",
        producingPeerId: s,
        mimeType: i.mimeType
      }));
    }), this.roomNodeClient.handlePeerCapabilities(s, e), this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || this.roomNodeClient.shareWebcam(this.self.videoTrack), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  updateParticipantsMapMinReplacement(s, t) {
    const e = Array.from(s.keys()), r = new Map(s), i = new Set(t), n = [];
    e.forEach((o, c) => {
      (!i.has(o) || !this.participants.joined.get(o)) && n.push(c);
    }), t.forEach((o) => {
      if (s.get(o))
        return;
      if (e.length < t.length) {
        e.push(o);
        return;
      }
      const c = n.shift();
      e[c] = o;
    }), n.forEach((o) => {
      e.splice(o, 1);
    }), Array.from(s.keys()).forEach((o) => {
      s.delete(o, !i.has(o));
    }), e.forEach((o) => {
      if (!this.participants.joined.get(o)) {
        this.logger.warn(
          "updateActiveParticipants::participant_not_in_joined_list",
          {
            dyteParticipant: { id: o }
          }
        );
        return;
      }
      s.add(
        this.participants.joined.get(o),
        !r.get(o)
      );
    }), s.emit("participantsUpdate");
  }
  updateParticipantsMap(s, t) {
    Array.from(s.keys()).forEach((r) => {
      t.includes(r) || s.delete(r, true);
    }), t.forEach((r) => {
      s.get(r) || s.add(this.participants.joined.get(r), true);
    }), s.emit("participantsUpdate");
  }
  updatePinnedParticipants() {
    this.participants.pinned.forEach((s) => {
      s.setIsPinned(false), this.participants.pinned.delete(s.id);
    });
  }
  setupEventsGlobal() {
    this.roomSocketHandler.on(x.joinRoom, ({ peer: s }) => {
      if (!s.waitlisted) {
        const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
        t && this.logger.info("Processing socket join", { peers: s.peerId }), this.onParticipantJoined(this.fromSocketService(s)), t && this.logger.info("Processed socket join", { peers: s.peerId });
      }
    }), this.roomSocketHandler.on(x.leaveRoom, (s) => {
      const { peerId: t } = s.peer;
      this.selectedPeers.delete(t, this.context), this.onParticipantLeave(t);
    }), this.context.getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => {
        this.self.permissions.acceptWaitingRequests && this.roomSocketHandler.getWaitingRoomRequests();
      }
    ), this.self.permissions.on("permissionsUpdate", (s) => {
      const { acceptWaitingRequests: t } = s;
      t !== void 0 && (t ? this.roomSocketHandler.getWaitingRoomRequests() : this.participants.waitlisted.clear());
    }), this.context.getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, () => {
      this.participants.joined.clear(), this.participants.videoSubscribed.clear(), this.participants.audioSubscribed.clear(), this.participants.pinned.clear(), this.participants.currentPage = 0, this.participants.viewMode = "ACTIVE_GRID", this.participants.emit("viewModeChanged", {
        viewMode: "ACTIVE_GRID",
        currentPage: this.participants.currentPage,
        pageCount: this.participants.pageCount
      });
    }), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_PAUSED,
      ({ id: s }) => {
        this.processConsumerPaused(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_RESUMED,
      ({ id: s }) => {
        this.processConsumerResumed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_CONSUMER,
      ({ id: s }) => {
        this.processNewConsumer(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_CLOSED,
      ({ id: s }) => {
        this.processConsumerClosed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        t !== "spotlight" && this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.LOW_CONSUMER_SCORE,
      ({
        peerId: s,
        score: t,
        kind: e
      }) => {
        const r = this.participants.joined.get(s);
        r && (r.emit("poorConnection", { score: t, kind: e }), this.participants.emit("poorConnection", {
          participantId: s,
          score: t,
          kind: e
        }));
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        peerId: r,
        scoreStats: i
      }) => {
        var c;
        const n = t === "video" && ((c = e == null ? void 0 : e.screenShare) != null ? c : false), o = this.participants.joined.get(r);
        o && (o.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }), this.participants.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }));
      }
    ), this.context.getValue("peerSessionStore").onAsync(k.KICK_PEER, (t) => u(this, [t], function* ({ peerId: s }) {
      const e = this.participants.joined.get(s);
      this.roomNodeClient.kick(s), yield this.roomSocketHandler.kick(s), e ? e.emit("kicked") : this.participants.joined.emit("kicked", { id: s });
    })), this.context.getValue("peerSessionStore").on(k.UPDATE_ACTIVE, (...e) => u(this, [...e], function* ({ page: s, createAllConsumers: t } = {}) {
      this.updateSubscriptions(s ? "PAGINATED" : "ACTIVE_GRID", { page: s, createAllConsumers: t });
    }));
  }
  onParticipantPinned(s) {
    return u(this, null, function* () {
      if (!s) {
        this.self.isPinned && this.self.setIsPinned(false), this.participants.pinned.size !== 0 && this.updatePinnedParticipants();
        return;
      }
      if (s === this.self.id) {
        this.participants.pinned.size !== 0 && this.updatePinnedParticipants(), this.self.setIsPinned(true);
        return;
      }
      const t = this.participants.joined.get(s);
      this.self.isPinned && this.self.setIsPinned(false), this.updatePinnedParticipants(), t.setIsPinned(true), this.participants.pinned.add(t);
    });
  }
  onParticipantJoined(s) {
    return u(this, null, function* () {
      var t, e, r;
      this.self.id !== s.id && !((t = s.flags) != null && t.recorder) && !((e = s.flags) != null && e.hidden_participant) && !((r = s.flags) != null && r.hiddenParticipant) && (this.participants.videoSubscribed.delete(s.id), this.participants.audioSubscribed.delete(s.id), this.participants.joined.add(s), this.participants.waitlisted.delete(s.id), s.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: s.name,
          userId: s.userId,
          peerId: s.id
        },
        add: true
      })), this.context.getValue("peerSessionStore").emit(k.PEER_JOINED_INTERNAL, s);
    });
  }
  onParticipantLeave(s) {
    return u(this, null, function* () {
      const t = this.participants.joined.get(s);
      this.participants.joined.delete(s, true, true), this.participants.pinned.delete(s, true, true), this.participants.waitlisted.delete(s, true, true), this.roomNodeClient && (this.roomNodeClient.handlePeerLeaving(s), this.roomNodeClient.closeConsumers(t == null ? void 0 : t.producers)), t && t.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: t.name,
          userId: t.userId,
          peerId: t.id
        },
        add: false
      });
      const { currentPage: e } = this.participants, r = this.maxPreferredStreams * (e - 1), i = this.participants.videoSubscribed.get(s);
      r === 0 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.joined.size <= r ? e === 2 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.setPage(e - 1) : i && this.updateSubscriptions(
        e ? "PAGINATED" : "ACTIVE_GRID",
        { page: e }
      );
    });
  }
  processMedia(s) {
    var f;
    const t = this.roomNodeClient.getConsumers(), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      producerId: o,
      rtpReceiver: c,
      paused: d,
      localId: l
    } = (f = t.get(s)) != null ? f : {};
    if (!e)
      return this.logger.warn("processMedia::Peer ID is undefined", {
        consumer: {
          id: s,
          kind: r,
          peerId: e,
          appData: {
            supportsRemoteControl: !!(i != null && i.supportsRemoteControl),
            screenShare: !!(i != null && i.screenShare)
          },
          remotelyPaused: d,
          producerId: o
        }
      }), {};
    const p = i;
    return r === "video" && p.screenShare !== true && this.videoPeerConsumerMap.set(e, s), this.logger.info("ParticipantController::processMedia", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: p,
        remotelyPaused: d,
        producerId: o
      }
    }), this.consumerPeerMap.set(s, {
      type: r,
      peerId: e,
      appData: p,
      remotelyPaused: d,
      producerId: o
    }), {
      peerId: e,
      kind: r,
      appData: p,
      remotelyPaused: d,
      track: n,
      producerId: o,
      rtpReceiver: c,
      localId: l
    };
  }
  processConsumerClosed(s) {
    const {
      peerId: t,
      type: e,
      appData: r,
      remotelyPaused: i,
      producerId: n
    } = this.consumerPeerMap.get(s) || {}, o = this.participants.joined.get(t);
    if (this.logger.info("ParticipantController::processConsumerClosed", {
      consumer: {
        id: s,
        peerId: t,
        appData: r,
        kind: e,
        remotelyPaused: i,
        producerId: n
      }
    }), this.consumerPeerMap.delete(s), e === "video" && r.screenShare !== true && this.videoPeerConsumerMap.delete(t), !o)
      return;
    const c = o.producers.find((l) => l.producerId === n);
    c && (c.consumer = {
      id: s,
      peerId: t,
      kind: void 0,
      appData: r,
      paused: i,
      producerId: n,
      rtpReceiver: void 0,
      localId: void 0
    });
    const d = [];
    r && r.screenShare ? (o.setScreenShareEnabled(false), this.context.getValue("callstats").consumerSharedMediaState(s, { screen: false }), o.screenShareTracks.video && d.push(o.screenShareTracks.video.id), o.screenShareTracks.audio && d.push(o.screenShareTracks.audio.id), o.screenShareTracks = {
      audio: void 0,
      video: void 0
    }) : e === "audio" ? (o.setAudioEnabled(false), o.audioTrack && d.push(o.audioTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { audio: false }), o.audioTrack = void 0) : e === "video" && (o.setVideoEnabled(false), this.updatePipSource(o.id, false), o.videoTrack && d.push(o.videoTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { video: false }), o.videoTrack = void 0), r.e2ee && d.forEach((l) => {
      this.context.getValue("peerSessionStore").emit(
        k.E2EE_INACTIVE_CONSUMER,
        {
          peerId: t,
          trackId: l
        }
      );
    });
  }
  processConsumerResumed(s) {
    var S;
    const t = this.processMedia(s), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      remotelyPaused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    } = t;
    if (!e)
      return;
    this.logger.info("ParticipantController::processConsumerResumed", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: i,
        remotelyPaused: o,
        producerId: c
      }
    });
    const p = this.participants.joined.get(e);
    if (!p)
      return;
    const f = p.producers.find((T) => T.producerId === c);
    if (f && (f.consumer = {
      id: s,
      peerId: e,
      kind: r,
      appData: i,
      paused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    }), i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: e, rtpReceiver: d, track: n }), i.screenShare) {
      r === "video" ? p.screenShareTracks.video = n : r === "audio" && (p.screenShareTracks.audio = n), p.setScreenShareEnabled(true), (S = this.context) == null || S.getValue("callstats").consumerSharedMediaState(s, { screen: true });
      return;
    }
    r === "video" ? (p.videoTrack = n, p.setVideoEnabled(true), this.updatePipSource(p.id, true), this.context.getValue("callstats").consumerSharedMediaState(s, { video: true })) : r === "audio" && (p.audioTrack = n, p.setAudioEnabled(p.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: p.audioEnabled
    }));
  }
  processConsumerPaused(s) {
    this.logger.info(
      `ParticipantController::processConsumerPaused called for consumerId: ${s}`
    );
    const {
      peerId: t,
      kind: e,
      track: r,
      appData: i,
      remotelyPaused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processConsumerPaused", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        appData: i,
        remotelyPaused: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f) => f.producerId === o);
    p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: i,
      paused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), r && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_CONSUMER, { peerId: t, trackId: r.id }), e === "video" ? (l.videoTrack = r, l.setVideoEnabled(false), this.updatePipSource(l.id, false), this.context.getValue("callstats").consumerSharedMediaState(s, { video: false })) : e === "audio" && (l.audioTrack = r, l.setAudioEnabled(l.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: l.audioEnabled
    }));
  }
  processNewConsumer(s) {
    const {
      peerId: t,
      kind: e,
      remotelyPaused: r,
      track: i,
      appData: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processNewConsumer", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        remotelyPaused: r,
        appData: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f) => f.producerId === o);
    if (p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: n,
      paused: r,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), n.screenShare) {
      e === "video" ? l.screenShareTracks.video = i : e === "audio" && (l.screenShareTracks.audio = i), (!r || this.self.permissions.isRecorder || this.context.getValue("flagsmith").hasFeature(X.SCREEENSHARE_ERR_HACK)) && l.setScreenShareEnabled(true), n.supportsRemoteControl && (l.supportsRemoteControl = true), this.participants.broadcastMessage("screenshareConsumerCreated", {
        producerId: o,
        peerId: t,
        screenShare: true,
        consumerId: s,
        consumerPeerId: this.self.id
      }), this.logger.info("ParticipantController::newScreenshareConsumer::screenshareConsumerCreated", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          remotelyPaused: r,
          appData: n,
          producerId: o
        }
      });
      return;
    }
    e === "video" ? (l.videoTrack = i, r || (l.setVideoEnabled(true), this.updatePipSource(l.id, true)), this.context.getValue("callstats").consumerSharedMediaState(s, {
      video: !r
    })) : e === "audio" && (l.audioTrack = i, r || l.setAudioEnabled(true), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: !r
    })), !r && n.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: t, rtpReceiver: c, track: i });
  }
  static formatSocketServiceMessage(s) {
    var e, r, i, n, o, c;
    if (!s)
      return;
    const t = Nh(s.stageType);
    return {
      id: s.peerId,
      userId: s.userId,
      name: s.displayName,
      displayName: s.displayName,
      stageType: t,
      customParticipantId: s.customParticipantId,
      presetId: s.presetId,
      picture: s.displayPictureUrl,
      waitlisted: s.waitlisted,
      stageStatus: t,
      metadata: {
        preset_name: (e = s.flags) == null ? void 0 : e.presetName
      },
      recorderType: (r = s.flags) == null ? void 0 : r.recorderType,
      flags: {
        hiddenParticipant: (i = s.flags) == null ? void 0 : i.hiddenParticipant,
        hidden_participant: (n = s.flags) == null ? void 0 : n.hiddenParticipant,
        recorder: ((o = s.flags) == null ? void 0 : o.recorderType) !== void 0 && ((c = s.flags) == null ? void 0 : c.recorderType) !== "NONE"
      }
    };
  }
  mapPeerIdsToProducers(s, t) {
    const e = /* @__PURE__ */ __name((i, n) => i.filter(({ kind: o, screenShare: c }) => n.includes(o) || c && n.includes("screenshare")), "e");
    return s.flatMap((i) => {
      const n = this.participants.joined.get(i);
      if (n)
        return e(n.producers, t);
    }).filter((i) => !!i);
  }
  onSelectedPeers(s, t) {
    return u(this, null, function* () {
      this.participants.viewMode === "ACTIVE_GRID" && this.computeActivateParticipants(s, t);
    });
  }
  updateActiveParticipantsWithPriorities(s, t = false) {
    if (!this.mediaJoined) {
      this.logger.warn(
        "Skipped::ParticipantController::updateActiveParticipantsWithPriorities",
        {
          roomJoined: this.mediaJoined
        }
      );
      return;
    }
    s.forEach((r) => {
      this.selectedPeers.add(r.peerId, r.priority, this.context);
    });
    const e = this.selectedPeers.activeSpeakerPeers.at(0);
    e !== void 0 && e !== this.participants.lastActiveSpeaker && (this.participants.lastActiveSpeaker = e, this.participants.emit("activeSpeaker", {
      peerId: e,
      volume: 1
    })), t && this.updateSubscriptions(this.participants.viewMode);
  }
}, Zs = /* @__PURE__ */ new WeakMap(), er = /* @__PURE__ */ new WeakMap(), tr = /* @__PURE__ */ new WeakMap(), Ui = /* @__PURE__ */ new WeakMap(), fn = /* @__PURE__ */ new WeakMap(), Hg);
var _r = ba;
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEvents", 1);
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEventsGlobal", 1);
Ea([
  E.trace("ParticipantController.processMedia")
], _r.prototype, "processMedia", 1);
Ea([
  E.trace("ParticipantController.processConsumerClosed")
], _r.prototype, "processConsumerClosed", 1);
Ea([
  E.trace("ParticipantController.processConsumerResumed")
], _r.prototype, "processConsumerResumed", 1);
Ea([
  E.trace("ParticipantController.processConsumerPaused")
], _r.prototype, "processConsumerPaused", 1);
Ea([
  E.trace("ParticipantController.processNewConsumer")
], _r.prototype, "processNewConsumer", 1);
var he = _s(
  kh().permissions
);
var q;
var Sn;
var $i;
var el;
var St;
var Vt;
var Oa = class extends qt {
  static {
    __name(this, "Oa");
  }
  constructor(e, r, i, n = false) {
    const o = e.getValue("logger");
    super(o);
    g(this, St);
    g(this, q, void 0);
    g(this, Sn, void 0);
    g(this, $i, void 0);
    g(this, el, (e2) => {
      var p, f, S;
      const l = e2, {
        chat: r2,
        connectedMeetings: i2,
        plugins: n2,
        polls: o2,
        media: c
      } = l, d = ho(l, [
        "chat",
        "connectedMeetings",
        "plugins",
        "polls",
        "media"
      ]);
      if (r2 && (r2.private && br(a(this, q).chat.private, r2.private), r2.public && br(a(this, q).chat.public, r2.public), this.emit("chatUpdate")), i2 && br(a(this, q).connectedMeetings, i2), c) {
        const T = /* @__PURE__ */ __name((P) => {
          switch (P) {
            case Qr.NONE:
              return j.Allowed;
            case Qr.ALLOWED:
              return j.Allowed;
            case Qr.NOT_ALLOWED:
              return j.NotAllowed;
            case Qr.CAN_REQUEST:
              return j.CanRequest;
            default:
              return;
          }
        }, "T"), _ = {
          audio: void 0,
          video: void 0,
          screenshare: void 0
        };
        (p = c.audio) != null && p.canProduce && (_.audio = {
          canProduce: T(c.audio.canProduce)
        }), (f = c.video) != null && f.canProduce && (_.video = {
          canProduce: T(c.video.canProduce)
        }), (S = c.screenshare) != null && S.canProduce && (_.screenshare = {
          canProduce: T(c.screenshare.canProduce)
        }), br(a(this, q).media, _);
      }
      n2 && (br(a(this, q).plugins, n2), this.emit("pluginsUpdate")), o2 && (br(a(this, q).polls, o2), this.emit("pollsUpdate")), Object.keys(d).length !== 0 && br(a(this, q), d), this.emit("permissionsUpdate", e2);
    });
    if (!r)
      throw this.logger.error("DytePermissionsPreset::load_preset_permissions_failed"), new R("Could not load preset permissions.", "0904");
    m(this, $i, e), m(this, Sn, i), m(this, q, r), n && this.setupEvents();
  }
  setupEvents() {
    a(this, $i).getValue("peerSessionStore").on(k.UPDATE_PERMISSIONS, a(this, el));
  }
  static fromResponse(e, r, i) {
    return new Oa(i, e, r, true);
  }
  static default(e, r) {
    return new Oa(e, he, r);
  }
  static init(e, r, i) {
    let n;
    return i ? n = new Oa(e, i, r, true) : n = new Oa(e, he, r), n;
  }
  get mediaRoomType() {
    const { sfu: e } = a(this, $i).getValue("roomNodeOptions");
    return e === we.CF ? "CF" : "HIVE";
  }
  get stageEnabled() {
    var e;
    return ((e = a(this, q)) == null ? void 0 : e.stageEnabled) || a(this, Sn) === Mt.Webinar || a(this, Sn) === Mt.Livestream;
  }
  get acceptStageRequests() {
    var e, r;
    return this.stageEnabled ? ((e = a(this, q)) == null ? void 0 : e.acceptStageRequests) || ((r = a(this, q)) == null ? void 0 : r.canAcceptProductionRequests) : false;
  }
  get stageAccess() {
    var e, r, i;
    return ((e = a(this, q)) == null ? void 0 : e.stageAccess) === j.NotAllowed ? j.NotAllowed : ((r = a(this, q)) == null ? void 0 : r.stageAccess) === j.CanRequest ? j.CanRequest : ((i = a(this, q)) == null ? void 0 : i.stageAccess) === j.Allowed || a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed ? j.Allowed : a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest ? j.CanRequest : j.NotAllowed;
  }
  get acceptWaitingRequests() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.acceptWaitingRequests) != null ? r : he.acceptWaitingRequests;
  }
  get requestProduceVideo() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.video) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  get requestProduceAudio() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.audio) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  get requestProduceScreenshare() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.screenshare) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  get canAllowParticipantAudio() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantAudio) != null ? r : he.disableParticipantAudio;
  }
  get canAllowParticipantScreensharing() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canAcceptProductionRequests) != null ? r : he.canAcceptProductionRequests;
  }
  get canAllowParticipantVideo() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantVideo) != null ? r : he.disableParticipantVideo;
  }
  get canDisableParticipantAudio() {
    return this.canAllowParticipantAudio;
  }
  get canDisableParticipantVideo() {
    return this.canAllowParticipantVideo;
  }
  get kickParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.kickParticipant) != null ? r : he.kickParticipant;
  }
  get pinParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.pinParticipant) != null ? r : he.pinParticipant;
  }
  get canRecord() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canRecord) != null ? r : he.canRecord;
  }
  get waitingRoomType() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  get waitingRoomBehaviour() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  get plugins() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.plugins) != null ? r : he.plugins;
  }
  get polls() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.polls) != null ? r : he.polls;
  }
  get produceVideo() {
    return this.canProduceVideo;
  }
  get requestProduce() {
    return a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest;
  }
  get canProduceVideo() {
    var r;
    const e = (r = a(this, q).media.video.canProduce) != null ? r : he.media.video.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  get produceScreenshare() {
    return this.canProduceScreenshare;
  }
  get canProduceScreenshare() {
    var r;
    const e = (r = a(this, q).media.screenshare.canProduce) != null ? r : he.media.screenshare.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  get produceAudio() {
    return this.canProduceAudio;
  }
  get canProduceAudio() {
    var r;
    const e = (r = a(this, q).media.audio.canProduce) != null ? r : he.media.audio.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  get chatPublic() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.public) != null ? i : he.chat.public;
  }
  get chatPrivate() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.private) != null ? i : he.chat.private;
  }
  get chatChannel() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.channel) != null ? i : he.chat.channel;
  }
  get chatMessage() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.message) != null ? i : he.chat.message;
  }
  get connectedMeetings() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.connectedMeetings) != null ? r : he == null ? void 0 : he.connectedMeetings;
  }
  get hiddenParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.hiddenParticipant) != null ? r : he.hiddenParticipant;
  }
  get showParticipantList() {
    var e;
    return (e = a(this, q).showParticipantList) != null ? e : he.showParticipantList;
  }
  get canChangeParticipantRole() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  get canChangeParticipantPermissions() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  get canChangeTheme() {
    return false;
  }
  get canPresent() {
    return a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed;
  }
  get acceptPresentRequests() {
    return this.acceptStageRequests;
  }
  get canEditDisplayName() {
    var e;
    return (e = a(this, q).canEditDisplayName) != null ? e : false;
  }
  get maxScreenShareCount() {
    return 1;
  }
  get isRecorder() {
    return a(this, q).isRecorder;
  }
  get canSpotlight() {
    return a(this, q).canSpotlight;
  }
  get canLivestream() {
    return a(this, q).canLivestream;
  }
  get transcriptionEnabled() {
    return a(this, q).transcriptionEnabled;
  }
};
var Qu = Oa;
q = /* @__PURE__ */ new WeakMap(), Sn = /* @__PURE__ */ new WeakMap(), $i = /* @__PURE__ */ new WeakMap(), el = /* @__PURE__ */ new WeakMap(), St = /* @__PURE__ */ new WeakSet(), Vt = /* @__PURE__ */ __name(function() {
  return a(this, $i).getValue("stageStatus");
}, "Vt");
var us;
var zf = class extends qt {
  static {
    __name(this, "zf");
  }
  constructor() {
    super(...arguments);
    h(this, "localMediaHandler");
    g(this, us, void 0);
  }
  updatePermission() {
    return u(this, null, function* () {
      var d, l;
      const e = /* @__PURE__ */ __name((p, f) => {
        this.mediaPermissions[p] = f;
        const S = { message: this.mediaPermissions[p], kind: p };
        f === "DENIED" ? a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, S) : a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, S);
      }, "e");
      if (Te.getName() === "firefox")
        return;
      const r = "microphone", i = "camera", n = yield (d = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : d.query({ name: r }), o = yield (l = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : l.query({
        name: i
      }), c = /* @__PURE__ */ __name((p, f) => {
        switch (f) {
          case "granted":
            e(p, "ACCEPTED");
            break;
          case "denied":
            e(p, "DENIED");
            break;
          case "prompt":
            e(p, "NOT_REQUESTED");
            break;
        }
        this.localMediaHandler.repopulateAvailableDevices();
      }, "c");
      n && (n.onchange = () => c("audio", n.state)), o && (o.onchange = () => c("video", o.state));
    });
  }
  populateMediaPermissionsInCallstats(i) {
    return u(this, arguments, function* ({
      message: e,
      kind: r
    }) {
      var n, o, c, d;
      switch (r) {
        case "audio": {
          (n = a(this, us)) == null || n.getValue("callstats").mediaPermission("AUDIO", e), (o = a(this, us)) == null || o.getValue("callstats").mediaPermission("SPEAKER", e);
          break;
        }
        case "video": {
          (c = a(this, us)) == null || c.getValue("callstats").mediaPermission("VIDEO", e);
          break;
        }
        case "screenshare": {
          (d = a(this, us)) == null || d.getValue("callstats").mediaPermission("SCREENSHARE", e);
          break;
        }
      }
    });
  }
  get peerId() {
    var e;
    return (e = a(this, us)) == null ? void 0 : e.getValue("peerId");
  }
  init() {
    return u(this, arguments, function* (e = {}, r = false, i = null) {
      var n, o, c, d, l, p, f;
      if (Te.init(), !this.localMediaHandler)
        try {
          let S = true;
          if ((n = i == null ? void 0 : i.getValue("defaults")) != null && n.mediaHandler)
            S = false, this.localMediaHandler = i.getValue("defaults").mediaHandler.localMediaHandler;
          else if (navigator.RNLocalMediaHandlerImpl) {
            const { RNLocalMediaHandlerImpl: T } = navigator;
            this.localMediaHandler = yield T.init(e);
          } else
            this.localMediaHandler = new Ot(
              i,
              e.constraints,
              (o = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : o.isNonPreferredDevice,
              (c = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : c.autoSwitchAudioDevice
            );
          if (i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_UPDATE,
            (T) => u(this, null, function* () {
              if (this.populateMediaPermissionsInCallstats({
                message: T.message,
                kind: T.kind
              }), T.message === "NOT_REQUESTED")
                switch (T == null ? void 0 : T.kind) {
                  case "audio":
                    this.rawAudioTrack && (this.logger.info("Disabling audio due to media permission update"), this.disableAudio());
                    break;
                  case "video":
                    this.rawVideoTrack && (this.logger.info("Disabling video due to media permission update"), this.disableVideo());
                    break;
                  default:
                    break;
                }
              this.emit("mediaPermissionUpdate", T);
            })
          ), i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_ERROR,
            (T) => u(this, null, function* () {
              const { kind: _, message: P, constraints: w } = T;
              this.populateMediaPermissionsInCallstats({
                message: P,
                kind: _
              }), _ === "audio" ? (this.logger.info(`Disabling audio due to media permission error  skipping: ${this.localMediaHandler.audioUpdateInProgress}`), this.localMediaHandler.audioUpdateInProgress === false && this.disableAudio()) : _ === "video" && (this.logger.info(`Disabling video due to media permission error skipping: ${this.localMediaHandler.videoUpdateInProgress}`), this.localMediaHandler.videoUpdateInProgress === false && this.disableVideo()), this.logger.error("SelfController::mediaPermissionError", {
                error: { message: P },
                constraints: w,
                mediaPermissionsErrors: {
                  kind: _,
                  message: P
                }
              }), this.emit("mediaPermissionError", T), this.emit("mediaPermissionUpdate", { message: P, kind: _ });
            })
          ), S) {
            this.logger.info(`Setting up DyteSelfMedia streams using media handler. audio:${(d = e == null ? void 0 : e.audio) != null ? d : true} video:${(l = e == null ? void 0 : e.video) != null ? l : true}`);
            const T = this.localMediaHandler.setupStreams({
              video: (p = e == null ? void 0 : e.video) != null ? p : true,
              audio: (f = e == null ? void 0 : e.audio) != null ? f : true
            });
            r || (yield T);
          }
        } catch (S) {
          this.logger.error("DyteSelf::init::Failed To Setup Streams", {
            error: { name: S.name, message: S.message }
          });
        }
    });
  }
  set context(e) {
    m(this, us, e), this.localMediaHandler.context = e;
  }
  get audioTrack() {
    return this.localMediaHandler.audioTrack;
  }
  get rawAudioTrack() {
    return this.localMediaHandler.rawAudioTrack;
  }
  get mediaPermissions() {
    return this.localMediaHandler.permissions;
  }
  addAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addAudioMiddleware(e);
    });
  }
  removeAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAudioMiddleware(e);
    });
  }
  removeAllAudioMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllAudioMiddlewares();
    });
  }
  get videoTrack() {
    return this.localMediaHandler.videoTrack;
  }
  get rawVideoTrack() {
    return this.localMediaHandler.rawVideoTrack;
  }
  addVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addVideoMiddleware(e);
    });
  }
  setVideoMiddlewareGlobalConfig() {
    return u(this, arguments, function* (e = {
      disablePerFrameCanvasRendering: false
    }) {
      return this.localMediaHandler.setVideoMiddlewareGlobalConfig(e);
    });
  }
  removeVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeVideoMiddleware(e);
    });
  }
  removeAllVideoMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllVideoMiddlewares();
    });
  }
  get screenShareTracks() {
    return this.localMediaHandler.screenShareTracks;
  }
  get audioEnabled() {
    return this.localMediaHandler.audioEnabled;
  }
  get videoEnabled() {
    return this.localMediaHandler.videoEnabled;
  }
  get screenShareEnabled() {
    return this.localMediaHandler.screenShareEnabled;
  }
  enableAudio() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      this.localMediaHandler.disableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  getCurrentDevices() {
    return this.localMediaHandler.getCurrentDevices();
  }
  getAudioDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getAudioDevices();
    });
  }
  getVideoDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getVideoDevices();
    });
  }
  getSpeakerDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getSpeakerDevices();
    });
  }
  getDeviceById(e, r) {
    let i;
    return r === "audio" ? i = "audioinput" : r === "video" ? i = "videoinput" : r === "speaker" && (i = "audiooutput"), this.localMediaHandler.getDeviceById(e, i);
  }
  setDevice(e) {
    return u(this, null, function* () {
      switch (e.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(e);
          } catch (r) {
          } finally {
            this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(e);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(e);
          } catch (r) {
          } finally {
            this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
      this.emit("deviceUpdate", {
        device: e
      });
    });
  }
};
us = /* @__PURE__ */ new WeakMap();
var K0 = Object.defineProperty;
var z0 = Object.getOwnPropertyDescriptor;
var Ct = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? z0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && K0(t, e, i), i;
}, "Ct");
var vn;
var vt;
var yn;
var He;
var sr;
var di;
var je;
var Ze;
var Tn;
var Ed;
var xe;
var Be;
var En;
var _n;
var ac;
var Xu;
var Bg;
var Xe = (Bg = class extends zf {
  static {
    __name(this, "Bg");
  }
  constructor(t, e, r, i, n) {
    var c;
    const o = t.getValue("logger");
    super(o);
    g(this, sr);
    g(this, je);
    g(this, Tn);
    g(this, xe);
    g(this, ac);
    h(this, "name");
    h(this, "picture");
    h(this, "customParticipantId");
    h(this, "waitlistStatus");
    g(this, vn, void 0);
    g(this, vt, void 0);
    g(this, yn, void 0);
    h(this, "role");
    h(this, "userId");
    h(this, "organizationId");
    h(this, "supportsRemoteControl", false);
    h(this, "device");
    g(this, He, void 0);
    h(this, "hidden", false);
    h(this, "presetName");
    h(this, "roomState", "init");
    g(this, En, /* @__PURE__ */ new Set());
    g(this, _n, /* @__PURE__ */ new Set());
    m(this, He, t), this.userId = e.id, this.name = e.name, this.picture = e.picture, this.customParticipantId = (c = e.customParticipantId) != null ? c : e.clientSpecificId, this.waitlistStatus = "none", m(this, vt, r), m(this, vn, i), this.hidden = false, m(this, yn, false), this.organizationId = e.organizationId, this.supportsRemoteControl = Te.isElectron(), this.device = Te.getDeviceInfo(), this.presetName = n, i.viewType !== Mt.Chat && this.updatePermission(), this.updateVideo = this.updateVideo.bind(this), L(this, ac, Xu).call(this);
  }
  get telemetry() {
    return a(this, He).getValue("telemetry");
  }
  get stageStatus() {
    return a(this, He).getValue("stageStatus");
  }
  get id() {
    return this.peerId;
  }
  get peerId() {
    return a(this, He).getValue("peerId");
  }
  static __init__(t, e, r, i, n, o = false) {
    return u(this, null, function* () {
      var S, T, _, P, w, A;
      let c = (T = (S = t.getValue("defaults")) == null ? void 0 : S.audio) != null ? T : true, d = (P = (_ = t.getValue("defaults")) == null ? void 0 : _.video) != null ? P : true;
      r.canProduceAudio !== "ALLOWED" && (c = false), r.canProduceVideo !== "ALLOWED" && (d = false);
      const l = new Xe(t, e, r, i, n);
      if (i.viewType === Mt.Chat)
        return l;
      const p = a0(i.mediaConstraints);
      br(p, (w = t.getValue("defaults")) == null ? void 0 : w.mediaConfiguration);
      const f = (A = t.getValue("defaults")) == null ? void 0 : A.mediaHandler;
      return f && (f.context = t), yield l.init({
        audio: c,
        video: d,
        constraints: p
      }, o, t), l.setupEvents(), l;
    });
  }
  cleanupEvents() {
    this.removeAllListeners("videoUpdate"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("VIDEO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_LIST_UPDATED"), this.localMediaHandler.removeAllListeners("SCREENSHARE_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("SCREENSHARE_ENDED"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_SILENT"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_AUDIO"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_VIDEO"), a(this, vt).removeAllListeners("permissionsUpdate");
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ac, Xu));
    const t = a(this, Tn, Ed);
    t && t.onError((e) => {
      this.emit("autoplayError", e);
    }), this.localMediaHandler.on("AUDIO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::AUDIO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.audioEnabled)
        try {
          yield a(this, je, Ze).shareMic(this.audioTrack);
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::Error while sharing mic", {
            error: e
          }), this.localMediaHandler.disableAudio();
        }
      this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    })), this.localMediaHandler.on("VIDEO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::VIDEO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.rawVideoTrack === void 0)
        this.logger.info("DyteSelf::VIDEO_TRACK_CHANGE::Forcing_disable_video"), this.disableVideo();
      else if (this.videoEnabled && a(this, xe, Be))
        try {
          const e = yield a(this, je, Ze).shareWebcam(this.videoTrack);
          e && e.id !== this.videoTrack.id && a(this, He).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, je, Ze).shareWebcam(this.videoTrack));
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::failed shareWebcam", {
            error: e
          }), this.videoEnabled && (yield this.localMediaHandler.disableVideo());
        }
      this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    })), this.localMediaHandler.on(
      "DEVICE_CHANGE",
      (r) => u(this, [r], function* ({ device: e }) {
        var i;
        this.emit("deviceUpdate", {
          device: e
        }), e.kind === "audiooutput" && typeof HTMLAudioElement.prototype.setSinkId == "function" && ((i = a(this, Tn, Ed)) == null || i.setSpeakerDevice(e.deviceId));
      })
    ), this.localMediaHandler.on("DEVICE_LIST_UPDATED", (e) => {
      this.emit("deviceListUpdate", e);
    }), this.localMediaHandler.on("SCREENSHARE_TRACK_CHANGE", () => u(this, null, function* () {
      if (!a(this, xe, Be)) {
        this.logger.error(
          "DyteSelf.SCREENSHARE_TRACK_CHANGE.LocalMediaInitialized_WithoutRoomNode"
        );
        return;
      }
      if (this.screenShareEnabled)
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (e) {
          this.logger.error(
            "DyteSelf::setupEvents::Error while sharing screen",
            {
              error: e
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
      this.logger.info("DyteSelf::setupEvents::SCREENSHARE_TRACK_CHANGE", D({}, gi(this))), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    })), this.localMediaHandler.on("SCREENSHARE_ENDED", () => u(this, null, function* () {
      this.logger.log("Disabling screenshare due to SCREENSHARE_ENDED"), yield this.disableScreenShare(), this.logger.info("DyteSelf::setupEvents::SCREENSHARE_ENDED", D({}, gi(this)));
    })), this.localMediaHandler.on("AUDIO_TRACK_SILENT", () => {
      var e;
      (e = a(this, He)) == null || e.getValue("callstats").mediaTrackMuted("AUDIO");
    }), this.localMediaHandler.on("FORCE_MUTE_AUDIO", () => {
      this.disableAudio();
    }), this.localMediaHandler.on("FORCE_MUTE_VIDEO", () => u(this, null, function* () {
      var e;
      a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (e = a(this, He)) == null || e.getValue("callstats").videoOff();
    })), a(this, vt).on("permissionsUpdate", (e) => {
      var r, i, n;
      (r = e == null ? void 0 : e.media) != null && r.audio && a(this, vt).canProduceAudio !== j.Allowed && (this.disableAudio(), this.logger.info(`Disabled audio due to dynamic preset change: canProduceAudio: ${this.permissions.canProduceAudio}`)), (i = e == null ? void 0 : e.media) != null && i.video && a(this, vt).canProduceVideo !== j.Allowed && (this.disableVideo(), this.logger.info(`Disabled video due to dynamic preset change: canProduceVideo: ${this.permissions.canProduceVideo}`)), (n = e == null ? void 0 : e.media) != null && n.screenshare && a(this, vt).canProduceScreenshare !== j.Allowed && (this.disableScreenShare(), this.logger.info(`Disabled screenshare due to dynamic preset change: canProduceScreenshare: ${this.permissions.canProduceScreenshare}`));
    });
  }
  get permissions() {
    return a(this, vt);
  }
  get config() {
    return a(this, vn);
  }
  get roomJoined() {
    var t;
    return a(this, vn).viewType === Mt.Livestream && this.stageStatus !== "ON_STAGE" ? ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === true : a(this, xe, Be);
  }
  setName(t) {
    if (!t)
      throw new R("Name cannot be empty.", "1103");
    this.name = t;
  }
  setupTracks() {
    return u(this, arguments, function* (t = {}) {
      t.forceReset, yield this.disableAudio(), yield this.disableVideo(), this.localMediaHandler.removeAudioTrack(), this.localMediaHandler.removeVideoTrack(), t.audio && (yield this.enableAudio()), t.video && (yield this.enableVideo());
    });
  }
  destructMediaHandler() {
    return u(this, null, function* () {
      return this.localMediaHandler.destruct();
    });
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeDocumentEventListeners();
    });
  }
  enableAudio(t) {
    return u(this, null, function* () {
      var e;
      if (this.permissions.canProduceAudio !== j.NotAllowed && !(a(this, vt).canProduceAudio === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.audioEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").audioOn(), yield this.localMediaHandler.enableAudio(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE") {
          if (this.audioTrack)
            try {
              yield a(this, je, Ze).shareMic(this.audioTrack);
            } catch (r) {
              this.logger.error("DyteSelf::enableAudio::Error while sharing mic", {
                error: r
              }), this.localMediaHandler.disableAudio();
            }
          if (!this.audioEnabled)
            return;
          a(this, je, Ze).unmuteSelf();
        }
        this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      }
    });
  }
  enableVideo(t) {
    return u(this, null, function* () {
      var e;
      if (a(this, vt).canProduceVideo !== j.NotAllowed && !(a(this, vt).canProduceVideo === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.videoEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").videoOn(), yield this.localMediaHandler.enableVideo(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE")
          try {
            yield a(this, je, Ze).shareWebcam(this.videoTrack);
          } catch (r) {
            this.logger.error("DyteSelf::enableVideo::Error while sharing video", {
              error: r
            }), this.videoEnabled && this.localMediaHandler.disableVideo();
          }
        this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        }), this.logger.info("DyteSelf.enableVideo", D({}, gi(this)));
      }
    });
  }
  updateVideoConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateVideoConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateVideoConstraints(t);
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t enable screenshare without joining room", "1105");
      if (a(this, vt).canProduceScreenshare !== j.NotAllowed && !(a(this, vt).canProduceScreenshare === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.screenShareEnabled && (yield this.localMediaHandler.enableScreenShare(), this.screenShareTracks.audio || this.screenShareTracks.video)) {
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (t) {
          this.logger.error(
            "DyteSelf::enableScreenShare::Error while sharing screen",
            {
              error: t
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
        this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      }
    });
  }
  updateScreenshareConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateScreenshareConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateScreenshareConstraints(t);
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      var t;
      this.audioEnabled && (this.localMediaHandler.disableAudio(), a(this, xe, Be) && a(this, je, Ze).muteSelf(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").audioOff());
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      var t;
      this.videoEnabled && (yield this.localMediaHandler.disableVideo(), a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").videoOff());
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare(), a(this, xe, Be) && (yield a(this, je, Ze).disableScreenShare()), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      }));
    });
  }
  getAllDevices() {
    return this.localMediaHandler.getAllDevices();
  }
  setIsPinned(t, e = true) {
    var i;
    m(this, yn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, sr, di)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  get isPinned() {
    return a(this, yn);
  }
  pin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t pin participants without joining room", "1105");
      return this.show(), a(this, je, Ze).pinPeer(this.id);
    });
  }
  unpin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t unpin participants without joining room", "1105");
      return a(this, je, Ze).pinPeer(null);
    });
  }
  hide() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t toggle participant tile without joining room", "1105");
      this.hidden = true, this.emit("toggleTile", { hidden: this.hidden });
    });
  }
  show() {
    if (!a(this, xe, Be))
      throw new R("Can`t toggle participant tile without joining room", "1105");
    this.hidden = false, this.emit("toggleTile", { hidden: this.hidden });
  }
  setDevice(t) {
    return u(this, null, function* () {
      var r, i, n;
      if (!t)
        throw new R("No device selected", "1104");
      const e = this.getCurrentDevices();
      if (t.deviceId && (((r = e == null ? void 0 : e.audio) == null ? void 0 : r.deviceId) === t.deviceId || ((i = e == null ? void 0 : e.video) == null ? void 0 : i.deviceId) === t.deviceId || ((n = e == null ? void 0 : e.speaker) == null ? void 0 : n.deviceId) === t.deviceId) && (this.logger.warn("DyteSelf.setDevice.setting_to_in_use_device", { devices: [t] }), a(this, He).getValue("flagsmith").hasFeature(X.SKIP_SETTING_IN_USE_DEVICE)))
        throw new R("Cannot set device currently in use", "1106");
      switch (t.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).muteSelf()), this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(t);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
    });
  }
  cleanUpTracks() {
    var t, e, r, i;
    (t = this.audioTrack) == null || t.stop(), (e = this.rawAudioTrack) == null || e.stop(), (r = this.videoTrack) == null || r.stop(), (i = this.rawVideoTrack) == null || i.stop();
  }
  playAudio() {
    var t;
    return (t = a(this, Tn, Ed)) == null ? void 0 : t.play();
  }
  registerVideoElement(t, e = false) {
    var r, i;
    t && (e ? a(this, En).add(t) : a(this, _n).add(t), this.updateVideo(t), e || (i = a(this, sr, di)) == null || i.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (r = this.raised) != null ? r : false
    ));
  }
  deregisterVideoElement(t, e = false) {
    if (!t) {
      a(this, sr, di).removeSource(this.id);
      return;
    }
    t.srcObject = void 0, e ? a(this, En).delete(t) : (a(this, _n).delete(t), a(this, sr, di).removeSource(this.id));
  }
  updateVideo(t, e = false) {
    var r, i, n;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const o = (r = t.srcObject) == null ? void 0 : r.getTracks()[0];
      if ((o == null ? void 0 : o.id) === this.videoTrack.id)
        return;
      const c = new MediaStream();
      c.addTrack(this.videoTrack), t.srcObject = c, e || (i = a(this, sr, di)) == null || i.enableSource(this.id);
    } else
      t.srcObject = void 0, e || (n = a(this, sr, di)) == null || n.disableSource(this.id);
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, vn = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), He = /* @__PURE__ */ new WeakMap(), sr = /* @__PURE__ */ new WeakSet(), di = /* @__PURE__ */ __name(function() {
  return a(this, He).getValue("pip");
}, "di"), je = /* @__PURE__ */ new WeakSet(), Ze = /* @__PURE__ */ __name(function() {
  return a(this, He).getValue("roomNodeClient");
}, "Ze"), Tn = /* @__PURE__ */ new WeakSet(), Ed = /* @__PURE__ */ __name(function() {
  return a(this, He).getValue("audioPlayback");
}, "Ed"), xe = /* @__PURE__ */ new WeakSet(), Be = /* @__PURE__ */ __name(function() {
  var t;
  return ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === true;
}, "Be"), En = /* @__PURE__ */ new WeakMap(), _n = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakSet(), Xu = /* @__PURE__ */ __name(function() {
  Array.from(a(this, _n)).forEach((t) => this.updateVideo(t, false)), Array.from(a(this, En)).forEach((t) => this.updateVideo(t, true));
}, "Xu"), Bg);
Ct([
  E.trace("DyteSelf.cleanupEvents")
], Xe.prototype, "cleanupEvents", 1);
Ct([
  E.trace("DyteSelf.setupEvents")
], Xe.prototype, "setupEvents", 1);
Ct([
  E.trace("DyteSelf.setupTracks")
], Xe.prototype, "setupTracks", 1);
Ct([
  E.trace("DyteSelf.destructMediaHandler")
], Xe.prototype, "destructMediaHandler", 1);
Ct([
  E.trace("DyteSelf.removeDocumentEventListeners")
], Xe.prototype, "removeDocumentEventListeners", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableAudio")
], Xe.prototype, "enableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableVideo")
], Xe.prototype, "enableVideo", 1);
Ct([
  E.trace("DyteSelf.updateVideoConstraints")
], Xe.prototype, "updateVideoConstraints", 1);
Ct([
  E.trace("DyteSelf.enableScreenShare"),
  Er.executeWithLock({
    methodName: "meeting.self.enableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  })
], Xe.prototype, "enableScreenShare", 1);
Ct([
  E.trace("DyteSelf.updateScreenshareConstraints")
], Xe.prototype, "updateScreenshareConstraints", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableAudio")
], Xe.prototype, "disableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableVideo")
], Xe.prototype, "disableVideo", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableScreenShare")
], Xe.prototype, "disableScreenShare", 1);
Ct([
  E.trace("DyteSelf.setDevice")
], Xe.prototype, "setDevice", 1);
Xe = Ct([
  ht("1100")
], Xe);
var Fh = class _Fh extends Error {
  static {
    __name(this, "Fh");
  }
  constructor(t) {
    super(t != null ? t : "AwaitQueue stopped"), this.name = "AwaitQueueStoppedError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _Fh);
  }
};
var Hh = class _Hh extends Error {
  static {
    __name(this, "Hh");
  }
  constructor(t) {
    super(t != null ? t : "AwaitQueue task removed"), this.name = "AwaitQueueRemovedTaskError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _Hh);
  }
};
var nc;
var Zu = class {
  static {
    __name(this, "Zu");
  }
  constructor(t, e = false) {
    h(this, "pendingTasks", /* @__PURE__ */ new Map());
    h(this, "nextTaskId", 0);
    h(this, "stopping", false);
    g(this, nc, void 0);
    this.log = e, m(this, nc, { info: e && t ? t.info : () => {
    } });
  }
  get size() {
    return this.pendingTasks.size;
  }
  push(t, e, r) {
    return u(this, null, function* () {
      if (e = e != null ? e : t.name, typeof t != "function")
        throw new TypeError("given task is not a function");
      if (e)
        try {
          Object.defineProperty(t, "name", { value: e });
        } catch (i) {
        }
      return new Promise((i, n) => {
        const o = {
          id: this.nextTaskId++,
          task: t,
          metadata: r,
          name: e,
          enqueuedAt: Date.now(),
          executedAt: void 0,
          completed: false,
          resolve: /* @__PURE__ */ __name((c) => {
            if (o.completed)
              return;
            o.completed = true, this.pendingTasks.delete(o.id), i(c);
            const [d] = this.pendingTasks.values();
            d && !d.executedAt && this.execute(d);
          }, "resolve"),
          reject: /* @__PURE__ */ __name((c) => {
            if (!o.completed && (o.completed = true, this.pendingTasks.delete(o.id), n(c), !this.stopping)) {
              const [d] = this.pendingTasks.values();
              d && !d.executedAt && this.execute(d);
            }
          }, "reject")
        };
        this.pendingTasks.set(o.id, o), this.pendingTasks.size === 1 && this.execute(o);
      });
    });
  }
  stop() {
    this.stopping = true;
    for (const t of this.pendingTasks.values())
      t.reject(new Fh());
    this.stopping = false;
  }
  remove(t) {
    const e = Array.from(this.pendingTasks.values())[t];
    e && e.reject(new Hh());
  }
  get(t) {
    return Array.from(this.pendingTasks.values())[t];
  }
  dump() {
    const t = Date.now();
    let e = 0;
    return Array.from(this.pendingTasks.values()).map((r) => ({
      idx: e++,
      task: r.task,
      name: r.name,
      enqueuedTime: r.executedAt ? r.executedAt - r.enqueuedAt : t - r.enqueuedAt,
      executionTime: r.executedAt ? t - r.executedAt : 0
    }));
  }
  execute(t) {
    return u(this, null, function* () {
      if (t.executedAt)
        throw new Error("task already being executed");
      t.executedAt = Date.now();
      try {
        const e = this.pendingTasks.size, r = yield t.task(), i = Date.now();
        a(this, nc).info(
          `AwaitQueue.push(${t.name})_timings`,
          {
            awaitQueueTask: {
              id: t.id,
              metadata: t.metadata,
              queueSizeAtStart: e,
              execTime: (i - t.executedAt) / 1e3,
              taskStartTime: (t.executedAt - t.enqueuedAt) / 1e3
            }
          }
        ), t.resolve(r);
      } catch (e) {
        t.reject(e);
      }
    });
  }
};
nc = /* @__PURE__ */ new WeakMap();
function Y0(s, t) {
  const e = new Error(t);
  return e.name = s, e;
}
__name(Y0, "Y0");
var Uo = class _Uo extends R {
  static {
    __name(this, "Uo");
  }
  constructor(t) {
    super(t), this.name = "UnsupportedError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, _Uo) : this.stack = new Error(t).stack;
  }
};
var At = class _At extends R {
  static {
    __name(this, "At");
  }
  constructor(t) {
    super(t), this.name = "InvalidStateError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, _At) : this.stack = new Error(t).stack;
  }
};
var fi = class extends R {
  static {
    __name(this, "fi");
  }
  constructor(t) {
    super(t), this.name = "TransportConnectionError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, At) : this.stack = new Error(t).stack;
  }
};
var fg = /* @__PURE__ */ __name((s) => new Promise((t) => setTimeout(t, s)), "fg");
function Yf(s, t) {
  return u(this, null, function* () {
    return new Promise((e, r) => u(this, null, function* () {
      const { strategy: i, maxRetryCount: n, delayTime: o } = D({
        strategy: "linear",
        maxRetryCount: 3,
        delayTime: 10
      }, t);
      let c = 0, d, l = false;
      const p = /* @__PURE__ */ __name((f) => {
        l = true, r(f);
      }, "p");
      for (; c < n; ) {
        try {
          const f = yield s(c, p);
          return e(f);
        } catch (f) {
          if (d = f, l)
            break;
          if (c < n)
            i === "linear" ? yield fg(o * (c + 1)) : i === "exponential" && (yield fg(o * (c + Math.max(0, c - 1))));
          else
            break;
        }
        c += 1;
      }
      return r(d);
    }));
  });
}
__name(Yf, "Yf");
function Q0(s) {
  return s.map((t) => ({
    channels: t.channels,
    clockRate: t.clockRate,
    mimeType: t.mimeType,
    sdpFmtpLine: t.sdpFmtpLine
  }));
}
__name(Q0, "Q0");
function X0(s) {
  return s.map((t) => ({
    uri: t.uri
  }));
}
__name(X0, "X0");
function dd(s) {
  return {
    codecs: Q0(s.codecs),
    headerExtensions: X0(s.headerExtensions ? s.headerExtensions : [])
  };
}
__name(dd, "dd");
function Z0(s) {
  const t = RTCRtpReceiver.getCapabilities("audio"), e = RTCRtpReceiver.getCapabilities("video"), r = RTCRtpSender.getCapabilities("audio"), i = RTCRtpSender.getCapabilities("video");
  s && (e.codecs = e.codecs.filter(({ mimeType: d }) => s === d), i.codecs = i.codecs.filter(({ mimeType: d }) => s === d));
  const n = {
    audio: dd(t),
    video: dd(e)
  };
  return {
    sender: {
      audio: dd(r),
      video: dd(i)
    },
    receiver: n
  };
}
__name(Z0, "Z0");
var ze;
var eD = class {
  static {
    __name(this, "eD");
  }
  constructor(t, e) {
    g(this, ze, void 0);
    h(this, "events");
    h(this, "sfuType");
    m(this, ze, t), this.sfuType = e, this.events = e === we.CF ? Ts : is;
  }
  joinRoom(t, e, r, i = false, n = null) {
    return u(this, null, function* () {
      const o = {
        roomUuid: t,
        displayName: e,
        prejoined: i,
        capabilities: r
      };
      return n && (o.location = n), (yield a(this, ze).sendMessagePromiseWithTimeout({
        event: this.events.joinRoom,
        protobuf: gR.toBinary(o),
        timeout: 5e3
      })).payload;
    });
  }
  connectTransport(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.createWebRTCTransport,
        BC.toBinary(t)
      )).payload, { transportId: r, description: i, producerIds: n } = lf.fromBinary(e), o = {
        sdp: i == null ? void 0 : i.sdp,
        type: i.type
      };
      return {
        transportId: r,
        answer: o,
        producerIds: n
      };
    });
  }
  produce(t) {
    return u(this, null, function* () {
      var n, o;
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.produce,
        IR.toBinary(t)
      )).payload, r = uw.fromBinary(e);
      return {
        answer: {
          sdp: (n = r == null ? void 0 : r.description) == null ? void 0 : n.sdp,
          type: (o = r == null ? void 0 : r.description) == null ? void 0 : o.type
        },
        producerId: r.producerId
      };
    });
  }
  consume(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.consume,
        PR.toBinary(t)
      )).payload, {
        consumerIdsMap: { map: r },
        description: i
      } = dw.fromBinary(e);
      return { consumerStateMap: r, sessionDescription: i };
    });
  }
  closeProducer(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.closeProducer,
        LR.toBinary(t)
      )).payload, { description: r } = vw.fromBinary(e);
      return r;
    });
  }
  closeConsumer(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      return (yield a(this, ze).sendMessagePromise(
        this.events.closeConsumer,
        UR.toBinary(t)
      )).payload;
    });
  }
  updateConsumersSimulcastConfig(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Method not implemented");
      return (yield a(this, ze).sendMessagePromise(
        this.events.updateConsumersSimulcastConfig,
        bR.toBinary(t)
      )).payload;
    });
  }
  hostControlForPeer(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: e === "audio",
        screeShare: false,
        video: e === "video",
        participantId: t
      }, i = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlPeer,
        jR.toBinary(r)
      )).payload;
      if (!i)
        return false;
      const { status: n } = Rw.fromBinary(i);
      return n === "success";
    });
  }
  hostControlForAll(t) {
    return u(this, null, function* () {
      const e = {
        audio: t === "audio",
        screenShare: false,
        video: t === "video"
      }, r = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlAllPeers,
        WR.toBinary(e)
      )).payload;
      if (!r)
        return false;
      const { status: i } = bw.fromBinary(r);
      return i === "success";
    });
  }
  kickAll() {
    return u(this, null, function* () {
      const t = {
        propagateKickAcrossRooms: false
      };
      a(this, ze).sendMessagePromise(
        x.kickAll,
        gf.toBinary(t)
      );
    });
  }
  kickPeer(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessagePromise(
        x.kick,
        yf.toBinary(t)
      );
    });
  }
  changeDisplayName(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.changeDisplayName,
        BR.toBinary(t)
      )).payload;
      if (!e)
        return false;
      const { status: r } = Iw.fromBinary(e);
      return r === "success";
    });
  }
  notifySelfJoinComplete() {
    return u(this, null, function* () {
      const t = {}, e = (yield a(this, ze).sendMessagePromise(
        this.events.selfJoinComplete,
        fR.toBinary(t)
      )).payload;
      return Du.fromBinary(e);
    });
  }
  audioActivity(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessage(this.events.audioActivity, jC.toBinary(t));
    });
  }
};
ze = /* @__PURE__ */ new WeakMap();
var oc;
var Yl = class extends ut.EventEmitter {
  static {
    __name(this, "Yl");
  }
  constructor(e) {
    super();
    g(this, oc, void 0);
    m(this, oc, e), this.setMaxListeners(1 / 0);
  }
  get logger() {
    return a(this, oc).getValue("logger");
  }
  safeEmit(e, ...r) {
    const i = this.listenerCount(e);
    try {
      return this.emit(e, ...r);
    } catch (n) {
      return this.logger.error(
        `EnhancedEventEmitter:: safeEmit() | event listener ${e} threw an error`,
        {
          error: n
        }
      ), Boolean(i);
    }
  }
  safeEmitAsPromise(e, ...r) {
    return u(this, null, function* () {
      const i = {}.EVENT_PROMISE_TIMEOUT ? parseInt({}.EVENT_PROMISE_TIMEOUT, 10) : 1e4;
      return this.safeEmitAsPromiseWithTimeout(e, i, ...r);
    });
  }
  safeEmitAsPromiseWithTimeout(e, r, ...i) {
    return u(this, null, function* () {
      return new Promise((n, o) => {
        setTimeout(o, r, "event request timeout");
        try {
          this.emit(e.toString(), ...i, n, o);
        } catch (c) {
          this.logger.error(
            `EnhancedEventEmitter:: safeEmitAsPromise() | event listener for event ${e.toString()} threw an error [event:%s]:%o`,
            {
              error: c
            }
          ), o(c);
        }
      });
    });
  }
};
oc = /* @__PURE__ */ new WeakMap();
var Bh = class extends Yl {
  static {
    __name(this, "Bh");
  }
  constructor() {
    super(...arguments);
    h(this, "_sendWebStream", new MediaStream());
    h(this, "_sendScreenShareStream", new MediaStream());
    h(this, "_direction");
    h(this, "pc");
    h(this, "_transportReady", false);
    h(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
    h(this, "enableHighBitrate", false);
    h(this, "enableStereo", false);
    h(this, "enableDtx", true);
    h(this, "sfu", we.HIVE);
  }
  get midTransceiverMap() {
    return this._mapMidTransceiver;
  }
  close() {
    if (this.logger.debug(`${this.name}::close()`), this.pc)
      try {
        this.pc.close();
      } catch (e) {
        this.logger.error(`${this.name}::pc.close()`, { error: e });
      }
  }
  restartIce() {
    return u(this, null, function* () {
      this.logger.debug(`${this.name}::restartIce()`);
      const e = yield this.pc.createOffer({
        iceRestart: true
      });
      return this.logger.debug(`${this.name}::restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), {
        offerSdp: e,
        callback: /* @__PURE__ */ __name((i) => u(this, null, function* () {
          this.logger.info(`${this.name}::restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(i)}]`), yield this.pc.setRemoteDescription(i);
        }), "callback")
      };
    });
  }
  init({
    direction: e,
    iceServers: r,
    iceTransportPolicy: i,
    additionalSettings: n,
    proprietaryConstraints: o,
    onTrackHandler: c
  }) {
    this.logger.debug("HandlerInterface::init()"), this._direction = e, this.pc = new RTCPeerConnection(
      D({
        iceServers: r || [],
        iceTransportPolicy: i || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require"
      }, n),
      o
    ), c && this.pc.addEventListener("track", (d) => {
      c(d);
    }), this._addEventListeners();
  }
  connect() {
    return u(this, null, function* () {
      let e;
      this.sfu === we.CF ? this.pc.addTransceiver("video", { direction: "sendonly" }) : e = this.pc.createDataChannel("dyte");
      const r = yield this.pc.createOffer();
      return yield this.pc.setLocalDescription(r), this.logger.info(`connect offer: ${JSON.stringify(r)}`), {
        offerSdp: r,
        callback: /* @__PURE__ */ __name((n) => u(this, null, function* () {
          this.logger.debug(`${this.name}::connect() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`), yield this.pc.setRemoteDescription(n), e == null || e.close();
        }), "callback")
      };
    });
  }
  getTransportStats() {
    return u(this, null, function* () {
      return this.pc.getStats();
    });
  }
  _assertSendDirection() {
    if (this._direction !== "send")
      throw new Error(
        'method can just be called for handlers with "send" direction'
      );
  }
  _assertRecvDirection() {
    if (this._direction !== "recv")
      throw new Error(
        'method can just be called for handlers with "recv" direction'
      );
  }
  getReceiverStats(e) {
    return u(this, null, function* () {
      this._assertRecvDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.receiver.getStats();
    });
  }
  stopSending(e) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`stopSending() [localId:${e}]`);
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      r.sender.replaceTrack(null), this.pc.removeTrack(r.sender), r.direction = "inactive";
      const i = yield this.pc.createOffer();
      return this.logger.debug(`stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(i)}]`), yield this.pc.setLocalDescription(i), {
        offerSdp: i,
        callback: /* @__PURE__ */ __name((o) => u(this, null, function* () {
          this.logger.debug(`stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(o)}]`), yield this.pc.setRemoteDescription(o), this.midTransceiverMap.delete(e);
        }), "callback")
      };
    });
  }
  replaceTrack(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), r ? this.logger.debug(`replaceTrack() [localId:${e}, track.id:${r.id}]`) : this.logger.debug(`replaceTrack() [localId:${e}, no track]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      yield i.sender.replaceTrack(r);
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          c <= r ? o.active = true : o.active = false;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  setRtpEncodingParameters(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          n.encodings[c] = D(D({}, o), r);
        }
      ), yield i.sender.setParameters(n);
    });
  }
  getSenderStats(e) {
    this._assertSendDirection();
    const r = this.midTransceiverMap.get(e);
    if (!r)
      throw new Error("associated RTCRtpTransceiver not found");
    return r.sender.getStats();
  }
  _addEventListeners() {
    this.pc.addEventListener(
      "icecandidate",
      (e) => {
        e.candidate && this.emit("@icecandidate", {
          candidate: e.candidate
        });
      }
    ), this.pc.addEventListener("iceconnectionstatechange", () => {
      switch (this.pc.iceConnectionState) {
        case "checking":
          this.emit("@connectionstatechange", "connecting");
          break;
        case "connected":
        case "completed":
          this.emit("@connectionstatechange", "connected"), this._transportReady = true;
          break;
        case "failed":
          this.emit("@connectionstatechange", "failed");
          break;
        case "disconnected":
          this.emit("@connectionstatechange", "disconnected");
          break;
        case "closed":
          this.emit("@connectionstatechange", "closed");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("negotiationneeded", () => {
      this.emit("@negotiationneeded", {}), this.logger.debug("negotiationneeded");
    }), this.pc.addEventListener("icegatheringstatechange", () => {
      switch (this.pc.iceGatheringState) {
        case "gathering":
          this.logger.debug("icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
          break;
        case "complete":
          this.logger.debug("icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("icecandidateerror", (e) => {
      this.logger.warn("icecandidateerror", {
        error: {
          code: e.errorCode,
          message: e.errorText
        }
      });
    }), this.pc.addEventListener("datachannel", (e) => {
      this.logger.info("data channel created: ", {
        rtcChannel: {
          label: e.channel.label
        }
      });
      const { channel: r } = e;
      r.onopen = () => {
        this.logger.info("data channel open: ", {
          rtcChannel: {
            label: e.channel.label
          }
        }), this.safeEmit("dc_open", e.channel);
      }, r.onclose = () => {
        this.logger.warn("data channel closed: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
      }, r.onerror = () => {
        this.logger.error("data channel error: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
      };
    }), this.addCustomEventListeners();
  }
  addCustomEventListeners() {
  }
};
var qh = class _qh extends Bh {
  static {
    __name(this, "qh");
  }
  static createFactory(t) {
    return () => new _qh(t);
  }
  get name() {
    return "Chrome74";
  }
  init({
    direction: t,
    iceServers: e,
    iceTransportPolicy: r,
    additionalSettings: i,
    proprietaryConstraints: n,
    onTrackHandler: o
  }) {
    this._direction = t, this.pc = new RTCPeerConnection(
      D({
        iceServers: e || [],
        iceTransportPolicy: r || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        sdpSemantics: "unified-plan"
      }, i),
      n
    ), o && this.pc.addEventListener("track", (c) => {
      o(c);
    }), this._addEventListeners();
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection();
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      });
      if (!navigator.isReactNative) {
        this.logger.debug("creating new transceiver");
        const l = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
        this.logger.info(`senders available params: ${JSON.stringify(l)}`);
        const p = [];
        r && r.length && r.forEach((f) => {
          var T;
          const S = l.codecs.find((_) => _.mimeType.includes(f.name));
          if (f.parameters) {
            this.logger.debug(`codecOption.parameters:${JSON.stringify(f.parameters)}`);
            const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
            _.push(...f.parameters);
            const P = Array.from(new Set(_).values());
            S.sdpFmtpLine = P.join(";");
          }
          p.push(S);
        }), this.logger.info(`selected codecs: ${JSON.stringify(p)}`), o.setCodecPreferences(p);
      }
      const c = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(c), r && r.findIndex(({ name: l }) => l === "opus") >= 0) {
        const { enableDtx: l, enableStereo: p } = this, f = this.enableHighBitrate ? p ? 128e3 : 64e3 : p ? 64e3 : 32e3;
        c.sdp = c.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${l ? "usedtx=1;" : ""}${p ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${f}`
        ), c.sdp += `a=rtcp-fb:111 nack\r
`;
      }
      this.midTransceiverMap.set(o.mid, o);
      const d = /* @__PURE__ */ __name((l) => u(this, null, function* () {
        return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(l)}]`), yield this.pc.setRemoteDescription(l), o.mid;
      }), "d");
      return this.logger.debug(`send() | calling pc.setLocalDescription() [offer: ${JSON.stringify(c, void 0, 2)}]`), {
        offerSdp: c,
        callback: d,
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => {
        this.safeEmit(
          "datachannel",
          t.channel,
          String.fromCharCode(...new Uint8Array(r.data))
        );
      };
    });
  }
};
var xd = class _xd extends Bh {
  static {
    __name(this, "xd");
  }
  constructor(e, r) {
    super(e);
    h(this, "supportsSendEncodings", false);
    this.supportsSendEncodings = r.supportsSendEncodings;
  }
  static createFactory(e, r) {
    return () => new _xd(
      e,
      r
    );
  }
  get name() {
    return "Firefox60";
  }
  send(o) {
    return u(this, arguments, function* ({
      track: e,
      encodings: r,
      codecOptions: i,
      screenShare: n
    }) {
      this._assertSendDirection();
      const c = this.supportsSendEncodings && r !== void 0 ? { sendEncodings: r } : {}, d = this.pc.addTransceiver(e, D({
        direction: "sendonly",
        streams: [
          n ? this._sendScreenShareStream : this._sendWebStream
        ]
      }, c));
      if (!this.supportsSendEncodings && r) {
        r.reverse();
        const S = d.sender.getParameters();
        S.encodings = r, yield d.sender.setParameters(S);
      }
      const l = /* @__PURE__ */ __name((S, T) => {
        var $;
        const _ = parse(S), P = _.media[_.media.length - 1], w = P.rtp.filter((F) => T.some((K) => K.name === F.codec)), A = P.fmtp.filter((F) => w.some((K) => K.payload === F.payload)), N = ($ = P.rtcpFb) == null ? void 0 : $.filter((F) => w.some((K) => K.payload === F.payload)), H = w.map((F) => F.payload);
        return _.media[_.media.length - 1].rtp = w, _.media[_.media.length - 1].fmtp = A, _.media[_.media.length - 1].rtcpFb = N, _.media[_.media.length - 1].payloads = H.join(" "), write(_);
      }, "l"), p = yield this.pc.createOffer();
      if (p.sdp = l(p.sdp, i), this.logger.debug(`send() | calling pc.setLocalDescription() [offer:${JSON.stringify(p)}]`), yield this.pc.setLocalDescription(p), e === "audio" || e.kind === "audio") {
        const { enableDtx: S, enableStereo: T } = this, _ = this.enableHighBitrate ? T ? 128e3 : 64e3 : T ? 64e3 : 32e3;
        p.sdp = p.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${T ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${_}`
        );
      }
      return this.midTransceiverMap.set(d.mid, d), {
        offerSdp: p,
        callback: /* @__PURE__ */ __name((S) => u(this, null, function* () {
          return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(S)}]`), yield this.pc.setRemoteDescription(S), d.mid;
        }), "callback"),
        sender: d.sender,
        mid: d.mid
      };
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters(), o = n.encodings.length - 1 - r;
      n.encodings.forEach(
        (c, d) => {
          d >= o ? c.active = true : c.active = false;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (e) => {
      const { channel: r } = e;
      r.onmessage = (i) => u(this, null, function* () {
        const n = yield i.data.arrayBuffer();
        this.safeEmit(
          "datachannel",
          e.channel,
          String.fromCharCode(...new Uint8Array(n))
        );
      });
    });
  }
};
var jh = class _jh extends Bh {
  static {
    __name(this, "jh");
  }
  static createFactory(t) {
    return () => new _jh(t);
  }
  get name() {
    return "Safari12";
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection(), this.logger.debug("Safari12::creating new transceiver");
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      }), c = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
      this.logger.info(`Safari12::senders available params: ${JSON.stringify(c)}`);
      const d = [];
      r && r.length > 0 && r.forEach((f) => {
        var T;
        const S = c.codecs.find(
          (_) => _.mimeType.includes(f.name)
        );
        if (f.parameters) {
          this.logger.info(`Safari12::codecOption.parameters:, ${JSON.stringify(f.parameters)}`);
          const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
          _.push(...f.parameters);
          const P = [...new Set(_).values()];
          S.sdpFmtpLine = P.join(";");
        }
        d.push(S);
      }), this.logger.info(`Safari12::selected codecs: ${JSON.stringify(d)}`), o.setCodecPreferences(d);
      const l = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(l), t === "audio" || t.kind === "audio") {
        const { enableStereo: f, enableDtx: S } = this, T = this.enableHighBitrate ? f ? 128e3 : 64e3 : f ? 64e3 : 32e3;
        l.sdp = l.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${f ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${T}`
        );
      }
      return this.midTransceiverMap.set(o.mid, o), {
        offerSdp: l,
        callback: /* @__PURE__ */ __name((f) => u(this, null, function* () {
          return this.logger.debug(
            `Safari12::send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(f)}]`
          ), yield this.pc.setRemoteDescription(f), o.mid;
        }), "callback"),
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.ondatachannel = (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => u(this, null, function* () {
        const i = String.fromCharCode(
          ...new Uint8Array(r.data)
        );
        this.safeEmit("datachannel", t.channel, i);
      });
    };
  }
};
function tD(s, t) {
  return typeof s == "undefined" ? t : typeof window != "undefined" && Object.getOwnPropertyDescriptor(window, "structuredClone") ? structuredClone(s) : JSON.parse(JSON.stringify(s));
}
__name(tD, "tD");
var cc;
var Fi;
var Ds;
var tl;
var Os;
var kr;
var dc;
var eh;
var sl;
var Qf;
var rl;
var Xf;
var sD = class extends Yl {
  static {
    __name(this, "sD");
  }
  constructor(e, r) {
    var i;
    super(e);
    g(this, Os);
    g(this, dc);
    g(this, sl);
    g(this, rl);
    h(this, "rtpReceiver");
    h(this, "id");
    h(this, "localId");
    h(this, "producerId");
    h(this, "producingTransportId");
    h(this, "mimeType");
    h(this, "track");
    h(this, "peerId");
    h(this, "appData");
    h(this, "transceiver");
    g(this, cc, void 0);
    g(this, Fi, void 0);
    g(this, Ds, void 0);
    g(this, tl, void 0);
    this.id = r.id, this.localId = r.localId, m(this, cc, r.handler), this.appData = r.appData, this.peerId = r.producingPeerId, this.producingTransportId = r.producingTransportId, m(this, Ds, false), this.producerId = r.producerId, this.track = r.track, m(this, Fi, (i = r.paused) != null ? i : false), this.mimeType = r.mimeType, this.transceiver = r.transceiver, this.rtpReceiver = r.rtpReceiver, L(this, sl, Qf).call(this), m(this, tl, e);
  }
  get closed() {
    return a(this, Ds);
  }
  get kind() {
    return this.track.kind;
  }
  get paused() {
    return a(this, Fi);
  }
  close(e, r) {
    a(this, Ds) || (this.logger.debug(`Consumer::close() ${e ? `with reason ${e}` : ""}`, a(this, Os, kr)), m(this, Ds, true), r && (L(this, rl, Xf).call(this), this.transceiver.stop()), this.safeEmit("close", e));
  }
  getStats() {
    return u(this, null, function* () {
      if (a(this, Ds))
        throw new At("closed");
      return a(this, cc).getReceiverStats(this.localId);
    });
  }
  pause() {
    if (this.logger.debug("consumer::pause()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("consumer::pause() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, true), this.track.enabled = false, this.safeEmit("pause");
  }
  resume() {
    if (this.logger.debug("consumer::resume()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("Consumer::resume() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, false), this.track.enabled = true, this.safeEmit("resume");
  }
};
cc = /* @__PURE__ */ new WeakMap(), Fi = /* @__PURE__ */ new WeakMap(), Ds = /* @__PURE__ */ new WeakMap(), tl = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakSet(), kr = /* @__PURE__ */ __name(function() {
  return {
    consumer: {
      id: this.id,
      appData: this.appData,
      peerId: this.peerId,
      kind: this.kind
    }
  };
}, "kr"), dc = /* @__PURE__ */ new WeakSet(), eh = /* @__PURE__ */ __name(function() {
  this.logger.debug('Consumer::track "ended" event', a(this, Os, kr)), this.safeEmit("trackended");
}, "eh"), sl = /* @__PURE__ */ new WeakSet(), Qf = /* @__PURE__ */ __name(function() {
  this.track.addEventListener("ended", L(this, dc, eh).bind(this));
}, "Qf"), rl = /* @__PURE__ */ new WeakSet(), Xf = /* @__PURE__ */ __name(function() {
  try {
    this.track.removeEventListener("ended", L(this, dc, eh)), this.track.stop();
  } catch (e) {
    this.logger.error("Consumer::destroyTrack()", B(D({}, a(this, Os, kr)), {
      error: e
    }));
  }
}, "Xf");
var hs;
var Pn;
var Cn;
var Hi;
var es;
var et;
var jr;
var Rn;
var il;
var Ft;
var os;
var rD = class extends Yl {
  static {
    __name(this, "rD");
  }
  constructor(e, r) {
    var i, n;
    super(e);
    g(this, Ft);
    h(this, "id");
    h(this, "localId");
    g(this, hs, void 0);
    h(this, "kind");
    h(this, "appData");
    h(this, "rtpSender");
    g(this, Pn, void 0);
    g(this, Cn, void 0);
    g(this, Hi, void 0);
    g(this, es, false);
    g(this, et, void 0);
    g(this, jr, void 0);
    g(this, Rn, void 0);
    g(this, il, void 0);
    this.id = r.id, this.localId = r.localId, m(this, et, r.track), this.kind = (i = r.track) == null ? void 0 : i.kind, m(this, jr, r.disableTrackOnPause ? !((n = r.track) != null && n.enabled) : false), m(this, Rn, void 0), m(this, Pn, r.stopTracks), m(this, Cn, r.disableTrackOnPause), m(this, Hi, r.zeroRtpOnPause), this.appData = r.appData || {}, this._onTrackEnded = this._onTrackEnded.bind(this), m(this, hs, r.handler), this.rtpSender = r.rtpSender, this._handleTrack(), m(this, il, e);
  }
  get closed() {
    return a(this, es);
  }
  get track() {
    return a(this, et);
  }
  get paused() {
    return a(this, jr);
  }
  get maxSpatialLayer() {
    return a(this, Rn);
  }
  close(e) {
    return u(this, null, function* () {
      if (a(this, es))
        return;
      if (this.logger.debug(`Producer::close() ${e ? `with reason ${e}` : ""}`, a(this, Ft, os)), m(this, es, true), this._destroyTrack(), e === Ud) {
        this.safeEmit("close", { reason: e });
        return;
      }
      const { offerSdp: r, callback: i } = yield a(this, hs).stopSending(this.localId), { answer: n } = yield this.safeEmitAsPromise("close", { offer: r, reason: e });
      i(n);
    });
  }
  getStats() {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      return a(this, hs).getSenderStats(this.localId);
    });
  }
  pause() {
    this.logger.debug("Producer::pause()", a(this, Ft, os)), a(this, es) && this.logger.error("Producer::pause() | Producer closed", a(this, Ft, os)), m(this, jr, true), a(this, et) && a(this, Cn) && (a(this, et).enabled = false), a(this, Hi) && a(this, hs).replaceTrack(this.localId, null), this.emit("pause");
  }
  resume() {
    if (this.logger.debug("Producer::resume()", a(this, Ft, os)), a(this, es)) {
      this.logger.error("Producer::resume() | Producer closed", a(this, Ft, os));
      return;
    }
    m(this, jr, false), a(this, et) && a(this, Cn) && (a(this, et).enabled = true), a(this, Hi) && a(this, hs).replaceTrack(this.localId, a(this, et)), this.emit("resume");
  }
  replaceTrack(r) {
    return u(this, arguments, function* ({
      track: e
    }) {
      if (this.logger.debug(`Producer::replaceTrack() trackId: ${e == null ? void 0 : e.id}`, a(this, Ft, os)), a(this, es)) {
        if (e && a(this, Pn))
          try {
            e.stop();
          } catch (i) {
            this.logger.error("Producer::replaceTrack", B(D({}, a(this, Ft, os)), {
              error: i
            }));
          }
        throw new At("closed");
      } else if (e && e.readyState === "ended")
        throw new At("track ended");
      if (e === a(this, et)) {
        this.logger.debug(`replaceTrack() | same track, ignored trackId: ${e.id}`, a(this, Ft, os));
        return;
      }
      (!a(this, Hi) || !a(this, jr)) && (yield a(this, hs).replaceTrack(this.localId, e)), this._destroyTrack(), m(this, et, e), this._handleTrack();
    });
  }
  setMaxSpatialLayer(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (this.kind !== "video")
        throw new Uo("not a video Producer");
      if (typeof e != "number")
        throw new TypeError("invalid spatialLayer");
      yield a(this, hs).setMaxSpatialLayer(this.localId, e), m(this, Rn, e);
    });
  }
  setRtpEncodingParameters(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (typeof e != "object")
        throw new TypeError("invalid params");
      yield a(this, hs).setRtpEncodingParameters(this.localId, e);
    });
  }
  _onTrackEnded() {
    this.logger.debug(`Producer::track "ended" event trackId: ${this.track.id}`, a(this, Ft, os)), this.safeEmit("trackended", this.track.id);
  }
  _handleTrack() {
    a(this, et) && a(this, et).addEventListener("ended", this._onTrackEnded);
  }
  _destroyTrack() {
    var e;
    if (a(this, et))
      try {
        a(this, et).removeEventListener("ended", this._onTrackEnded), a(this, Pn) && a(this, et).stop();
      } catch (r) {
        this.logger.error(`Producer::_destroyTrack trackId: ${(e = this.track) == null ? void 0 : e.id}`, B(D({}, a(this, Ft, os)), {
          error: r
        }));
      }
  }
};
hs = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), Hi = /* @__PURE__ */ new WeakMap(), es = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakSet(), os = /* @__PURE__ */ __name(function() {
  return {
    producer: {
      id: this.id,
      appData: this.appData,
      kind: this.kind
    }
  };
}, "os");
function Zf(s) {
  return typeof s == "object" && !Array.isArray(s) && s !== null;
}
__name(Zf, "Zf");
function yu(s) {
  return Math.random().toString(36).substring(2, 2 + s);
}
__name(yu, "yu");
var ld = 1;
function Sg(s) {
  const t = s;
  return delete t.payload._bolt, t;
}
__name(Sg, "Sg");
function iD(s) {
  return s.payload && Zf(s.payload);
}
__name(iD, "iD");
function eS(s) {
  var t, e;
  return iD(s) && (e = (t = s.payload._bolt) == null ? void 0 : t.id) != null ? e : "";
}
__name(eS, "eS");
var Gr;
var al;
var Bi;
var Na = class extends ut.EventEmitter {
  static {
    __name(this, "Na");
  }
  constructor(e, r, i, n) {
    super();
    h(this, "channel");
    h(this, "queue");
    h(this, "serverProtocolVersion");
    g(this, Gr, /* @__PURE__ */ new Map());
    g(this, al, void 0);
    g(this, Bi, void 0);
    h(this, "respond", (e2, r2, i2 = false) => {
      let n2;
      i2 ? n2 = Na.createErrorResponse(e2, r2) : n2 = Na.createResponse(e2, r2), this.channel.send(JSON.stringify(n2));
    });
    h(this, "notify", (e2) => {
      const r2 = Na.createNotification(e2);
      this.channel.send(JSON.stringify(r2));
    });
    h(this, "request", (e2) => u(this, null, function* () {
      const r2 = Na.createRequest(e2), i2 = new Promise((n2, o) => {
        const { id: d } = r2.payload._bolt, l = {
          id: d,
          method: r2.type,
          resolve: /* @__PURE__ */ __name((p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), n2(p));
          }, "resolve"),
          timer: setTimeout(() => {
            this.queue.delete(d) && o(new Error(`request timeout for message id: ${d}`));
          }, 2e4),
          cancel: /* @__PURE__ */ __name((p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), o(p));
          }, "cancel")
        };
        this.queue.set(d, l);
      });
      return this.channel.send(JSON.stringify(r2)), i2;
    }));
    h(this, "send", (e2) => {
      const r2 = JSON.stringify(e2), i2 = 16384;
      if (r2.length > i2) {
        const n2 = i2 - 200, o = Math.ceil(r2.length / n2), c = [];
        for (let l = 0; l < o; l += 1) {
          const p = l * n2, f = (l + 1) * n2;
          c.push(r2.slice(p, f));
        }
        const d = v4();
        for (let l = 0; l < o; l += 1) {
          const p = c[l], S = JSON.stringify({
            id: d,
            count: o,
            chunkIndex: l,
            chunk: p
          });
          a(this, Bi).debug(`Sending message chunk over dc: ${S}`), this.channel.send(S);
        }
      } else
        a(this, Bi).debug(`Sending message over dc: ${r2}`), this.channel.send(r2);
    });
    h(this, "processMessage", (e2) => {
      var i2;
      a(this, Gr).has(e2.id) || a(this, Gr).set(e2.id, []);
      const r2 = a(this, Gr).get(e2.id);
      if (r2[e2.chunkIndex] = e2, (r2 == null ? void 0 : r2.length) === e2.count && !r2.some((n2) => n2 === void 0)) {
        const n2 = a(this, Gr).get(e2.id), o = n2 == null ? void 0 : n2.reduce((d, l) => d + l.chunk, "");
        a(this, Gr).delete(e2.id);
        const c = JSON.parse(o);
        if (!c.payload || !Zf(c.payload))
          throw new Error("corrupted incoming message over dc", {
            cause: { code: "CORRUPT_DC_MESSAGE", values: c }
          });
        if (this.processBoltHandshake(c))
          return;
        if (this.serverProtocolVersion = (i2 = c.payload._bolt) == null ? void 0 : i2.version, !this.processResponseMsg(c))
          return c;
      }
    });
    h(this, "processResponseMsg", (e2) => {
      const { id: r2 } = e2.payload._bolt, i2 = this.queue.get(r2);
      return i2 ? (a(this, Bi).debug(`resolving pending request with id: ${r2}, complete response: ${JSON.stringify(e2)}`), e2.type === "error" ? i2.cancel(Sg(e2)) : i2.resolve(Sg(e2)), true) : false;
    });
    h(this, "processBoltHandshake", (e2) => {
      var r2, i2;
      return e2.type === "_bolt" || e2.type === "handshake" ? (this.respond((i2 = (r2 = e2.payload._bolt) == null ? void 0 : r2.id) != null ? i2 : yu(8), { type: "_bolt", payload: { message: "pong" } }), true) : false;
    });
    this.label = i, this.transportId = n, m(this, al, e), m(this, Bi, e.getValue("logger")), this.channel = r, this.queue = /* @__PURE__ */ new Map();
  }
};
var li = Na;
Gr = /* @__PURE__ */ new WeakMap(), al = /* @__PURE__ */ new WeakMap(), Bi = /* @__PURE__ */ new WeakMap(), h(li, "createRequest", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      _bolt: {
        id: yu(8),
        type: "REQUEST",
        version: ld
      }
    })
  };
}), h(li, "createResponse", (e, r) => {
  var i;
  if ((i = r.payload) != null && i._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: r.type,
    payload: B(D({}, r.payload), {
      _bolt: {
        id: e,
        type: "RESPONSE",
        version: ld
      }
    })
  };
}), h(li, "createNotification", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      bolt: {
        id: yu(8),
        type: "NOTIFY",
        version: ld
      }
    })
  };
}), h(li, "createErrorResponse", (e, r) => ({
  type: "error",
  payload: {
    error: r.message,
    _bolt: {
      id: e,
      type: "RESPONSE",
      version: ld
    }
  }
}));
var Ud = "transport closed";
var qi;
var ji;
var Va = class extends Yl {
  static {
    __name(this, "Va");
  }
  constructor(e, r, {
    id: i,
    direction: n,
    handlerFactory: o,
    iceServers: c,
    iceTransportPolicy: d,
    proprietaryConstraints: l,
    additionalSettings: p,
    appData: f,
    config: S
  }) {
    var P, w, A;
    super(e);
    h(this, "awaitQueue");
    h(this, "observer");
    g(this, qi, void 0);
    h(this, "id");
    h(this, "serverId");
    h(this, "direction");
    h(this, "maxSctpMessageSize");
    h(this, "handler");
    h(this, "connectionState", "new");
    h(this, "producers");
    h(this, "consumers");
    h(this, "datachannels");
    h(this, "connected", false);
    h(this, "eventsDCReadyPromise");
    h(this, "eventsDCReadyPromiseResolver");
    h(this, "eventsDCFailureTimer");
    h(this, "transportConnectionPromise");
    h(this, "consumerTrackEvents");
    h(this, "unknownTracksMap");
    h(this, "appData");
    g(this, ji, void 0);
    m(this, ji, e);
    const T = e.getValue("logger");
    T.debug(`constructor() [id: ${i}, direction: ${n}]`), m(this, qi, r), this.id = i, this.direction = n;
    const _ = tD(p, {});
    delete _.iceServers, delete _.iceTransportPolicy, delete _.bundlePolicy, delete _.rtcpMuxPolicy, delete _.sdpSemantics, this.producers = /* @__PURE__ */ new Map(), this.consumers = /* @__PURE__ */ new Map(), this.datachannels = /* @__PURE__ */ new Map(), this.consumerTrackEvents = /* @__PURE__ */ new Map(), this.unknownTracksMap = /* @__PURE__ */ new Map(), this.awaitQueue = new Zu(T, true), this.handler = o(), this.handler.enableHighBitrate = (P = S == null ? void 0 : S.enableHighBitrate) != null ? P : false, this.handler.enableStereo = (w = S == null ? void 0 : S.enableStereo) != null ? w : false, this.handler.enableDtx = (A = S == null ? void 0 : S.enableDtx) != null ? A : true, this.handler.sfu = a(this, qi), this.handler.init({
      onTrackHandler: this._ontrack.bind(this),
      direction: n,
      iceServers: c,
      iceTransportPolicy: d,
      additionalSettings: p,
      proprietaryConstraints: l
    }), this.appData = f || {}, this.transportConnectionPromise = new Promise((N) => {
      this.once("connected", () => {
        N(true);
      }), this.once("disconnect", () => {
        N(false);
      }), this.once("close", () => {
        N(false);
      });
    }), this.eventsDCReadyPromise = new Promise((N) => {
      this.eventsDCReadyPromiseResolver = N;
    }), this.handler.on(
      "@connectionstatechange",
      (N) => {
        N !== this.connectionState && (this.logger.debug(`connection state changed to ${N}`), this.connectionState = N, N === "connected" && (this.connected = true, this.emit("connected")), N === "disconnected" && (this.connected = false, this.emit("disconnect")), (N === "failed" || N === "closed") && (this.connected = false, this.emit("close")), this.closed || this.safeEmit("connectionstatechange", N));
      }
    ), this.handler.on(
      "@icecandidate",
      ({ candidate: N }) => {
        this.closed || this.safeEmit("icecandidate", N);
      }
    ), this.handler.on("dc_open", (N) => {
      let H = this.datachannels.get(N.label);
      H || (H || (H = new li(a(this, ji), N, N.label, this.serverId), this.datachannels.set(N.label, H)), this.eventsDCFailureTimer = setTimeout(() => {
        N.label === "events" && (this.eventsDCReadyPromiseResolver(false), this.safeEmit("dc_error", N.label));
      }, 5e3));
    }), this.handler.on("datachannel", (N, H) => {
      N.label === "events" && (this.eventsDCReadyPromiseResolver(true), this.eventsDCFailureTimer && clearTimeout(this.eventsDCFailureTimer));
      const $ = this.datachannels.get(N.label);
      if (!$) {
        this.logger.error("unregistered datachannel for message", {
          rtcChannel: {
            label: N.label,
            message: H
          }
        });
        return;
      }
      try {
        const F = JSON.parse(H);
        this.logger.debug("datachannel message chunk recieved", {
          dataChannelMessageChunk: {
            id: F.id,
            count: F.count,
            chunkIndex: F.chunkIndex,
            chunk: F.chunk,
            transprtId: this.serverId
          }
        });
        const K = $.processMessage(F);
        if (!K)
          return;
        this.logger.debug(
          `datachannel message with id:${F.id} on transport:${this.serverId}complete - ${JSON.stringify(K)}`
        ), this.emit(`datachannel:${N.label}`, $.label, K);
      } catch (F) {
        this.logger.error("error parsing message", {
          error: F
        });
      }
    });
  }
  get closed() {
    return this.connectionState === "closed";
  }
  setServerId(e) {
    this.serverId = e;
  }
  getDatachannel(e) {
    return this.datachannels.get(e);
  }
  get isEventsDCReady() {
    return this.eventsDCReadyPromise;
  }
  close() {
    this.closed || (this.logger.debug("Transport close called"), this.connectionState = "closed", this.awaitQueue.stop(), this.awaitQueue = void 0, this.connected = false, this.handler.close(), Array.from(this.producers.values()).forEach(
      (e) => {
        e.close(Ud).catch(() => {
        });
      }
    ), this.producers.clear(), Array.from(this.consumers.values()).forEach((e) => {
      e.close(Ud);
    }), this.consumers.clear(), this.consumerTrackEvents.clear(), this.emit("close"));
  }
  getStats() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      return this.handler.getTransportStats();
    });
  }
  connect(e) {
    return u(this, null, function* () {
      try {
        if (yield this.awaitQueue.push(() => u(this, null, function* () {
          const { offerSdp: r, callback: i } = yield this.handler.connect(), {
            transportId: n,
            answer: o
          } = yield e(r);
          this.setServerId(n), yield i(o);
        })), !(yield this.transportConnectionPromise))
          throw new Error("ice connection failed");
        if (a(this, qi) === we.HIVE && !(yield this.isEventsDCReady))
          throw new Error("events datachannel not open");
      } catch (r) {
        throw this.logger.error("transport failed to connect:", { error: r }), r;
      }
    });
  }
  restartIce() {
    return u(this, null, function* () {
      if (this.logger.debug("restartIce()"), this.closed)
        throw new At("closed");
      return this.handler.restartIce();
    });
  }
  canProduce(e) {
    return u(this, null, function* () {
      const { track: r, appData: i } = e;
      if (r) {
        if (this.direction !== "send")
          throw new Uo("not a sending Transport");
        if (r.readyState === "ended")
          throw new At("track ended");
        if (i && typeof i != "object")
          throw new TypeError("if given, appData must be an object");
      } else
        throw new TypeError("missing track");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return true;
    });
  }
  produce(e, r) {
    return u(this, null, function* () {
      if (!(yield this.canProduce(e)))
        throw new Error("Cannot produce");
      const {
        track: n,
        encodings: o,
        codecOptions: c,
        stopTracks: d = true,
        disableTrackOnPause: l = true,
        zeroRtpOnPause: p = false,
        appData: f = {}
      } = e;
      this.logger.debug(`produce() [track:${n.id}]`);
      const { producerId: S, localId: T, rtpSender: _ } = yield this.awaitQueue.push(() => u(this, null, function* () {
        const {
          offerSdp: P,
          callback: w,
          sender: A,
          mid: N
        } = yield this.handler.send({
          track: n,
          encodings: o,
          codecOptions: c,
          screenShare: f == null ? void 0 : f.screenShare
        }), { answer: H, producerId: $ } = yield r(
          {
            offer: P,
            kind: n.kind,
            paused: l ? !n.enabled || Object.hasOwn(n, "fakeTracks") : false,
            appData: B(D({}, f || {}), { mid: N }),
            codecOptions: c,
            producingTransportId: this.serverId
          }
        ), F = yield w(H);
        return { producerId: $, localId: F, rtpSender: A };
      }), "Transport.produce");
      return this.createProducerObject({
        id: S,
        localId: T,
        track: n,
        stopTracks: d,
        disableTrackOnPause: l,
        zeroRtpOnPause: p,
        appData: f,
        handler: this.handler,
        rtpSender: _
      });
    });
  }
  createProducerObject(e) {
    return u(this, null, function* () {
      const r = new rD(a(this, ji), e);
      return this.producers.set(r.id, r), r.once("close", () => {
        this.producers.delete(r.id);
      }), this.emit("newproducer", r), r;
    });
  }
  closeProducer(e) {
    return u(this, null, function* () {
      yield this.awaitQueue.push(e.close.bind(e), "Transport.closeProducer");
    });
  }
  canConsume() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      if (this.direction !== "recv")
        throw new Uo("not a receiving transport");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return true;
    });
  }
  consume(e, r, i) {
    return u(this, null, function* () {
      return this.awaitQueue.push(() => u(this, null, function* () {
        const n = {}, {
          consumerStates: o,
          sessionDescription: c,
          failedProducers: d
        } = yield r(e);
        o.forEach((p, f) => {
          n[f] = this.createConsumerObjectAndWaitForTrack(B(D({}, p), {
            producerId: f
          }));
        }), c && (this.logger.info("Session description found, sending negotiation request"), yield i(c));
        const l = [];
        return yield Promise.all(Object.entries(n).map(
          ([p, f]) => f.then((S) => l.push(S)).catch(() => {
            this.logger.error(`Failed to create consumer object, producer: ${p}`, {
              error: { message: "This should not happen" },
              transport: { serverId: this.serverId }
            });
          })
        )), { consumers: l, failedProducers: d };
      }), "Transport.consume", { producersLength: e.length });
    });
  }
  static parseCodecAndFmtpMappings(e, r) {
    const i = parse(e.sdp), n = {};
    return i.media.forEach((o) => {
      r.includes(o.mid.toString()) && (n[o.mid.toString()] = {
        rtp: o.rtp,
        fmtp: o.fmtp,
        payloads: o.payloads,
        rtcpFb: o.rtcpFb
      });
    }), n;
  }
  static setCodecAndFmtpMappings(e, r, i) {
    const n = parse(e.sdp);
    return n.media = n.media.map((c) => {
      if (r.includes(c.mid.toString())) {
        const d = D({}, c);
        return d.rtp = i[c.mid.toString()].rtp, d.fmtp = i[c.mid.toString()].fmtp, d.payloads = i[c.mid.toString()].payloads, d.rtcpFb = i[c.mid.toString()].rtcpFb, d;
      }
      return c;
    }), B(D({}, e), {
      sdp: write(n)
    });
  }
  static parseHeaderExtensionMappings(e) {
    const r = parse(e.sdp), i = {};
    return r.media.forEach((n) => {
      i[n.mid] = n.ext;
    }), i;
  }
  static setHeaderExtensionMappings(e, r) {
    const i = parse(e.sdp);
    return i.media = i.media.map((o) => {
      const c = D({}, o);
      return c.ext = r[o.mid], c;
    }), B(D({}, e), {
      sdp: write(i)
    });
  }
  closeConsumers(e, r) {
    return u(this, null, function* () {
      try {
        const i = e.map((l) => l.transceiver.mid), n = Va.parseCodecAndFmtpMappings(
          this.handler.pc.remoteDescription,
          i
        ), o = Va.parseHeaderExtensionMappings(
          this.handler.pc.remoteDescription
        );
        this.logger.info("Stopping transceivers", { consumerIds: e.map(({ id: l }) => l) }), e.forEach((l) => l.close(void 0, true));
        let c = yield this.handler.pc.createOffer();
        this.logger.info("Created offer for closing consumers", { sdp: c.sdp }), c = Va.setCodecAndFmtpMappings(
          c,
          i,
          n
        ), c = Va.setHeaderExtensionMappings(
          c,
          o
        ), this.logger.info("Updated codec and fmtp mappings in close consumer offer", { sdp: c.sdp }), yield this.setLocalDescription(c), this.logger.info("Successfully set local description in close consumers");
        const d = yield r(e, c);
        this.logger.info("Received answer in close consumers", { sdp: d.sdp }), yield this.setRemoteDescription(d), this.logger.info("Remote description was set successfully in close consumers", { sdp: d.sdp });
      } catch (i) {
        this.logger.error("Failed to close consumers", { error: i });
      }
    });
  }
  setRemoteOffer(e) {
    return u(this, null, function* () {
      try {
        this.logger.info("Received offer from SFU", { sdp: e.sdp }), yield this.setRemoteDescription(e);
        const r = yield this.handler.pc.createAnswer();
        this.logger.info("Created answer corresponding to received offer", { sdp: r.sdp });
        const i = parse(r.sdp);
        return i.media = i.media.map((n) => {
          if (n.type === "audio") {
            const o = D({}, n), c = o.fmtp.find(
              (l) => l.payload === 111
            );
            return c && (c.config += ";stereo=1;sprop-stereo=1"), o.rtcpFb || (o.rtcpFb = []), o.rtcpFb.some(
              (l) => l.type === "nack"
            ) || o.rtcpFb.push({
              payload: parseInt(o.payloads, 10),
              type: "nack"
            }), o;
          }
          return n;
        }), r.sdp = write(i), this.logger.info("Setting munged SDP", { sdp: r.sdp }), yield this.setLocalDescription(r), this.logger.info("Successfully set local description", { sdp: r.sdp }), r;
      } catch (r) {
        throw this.logger.error("Set remote offer failed", { error: r }), r;
      }
    });
  }
  _ontrack(e) {
    const { track: r, transceiver: i, streams: n } = e;
    this.logger.info(`track event received [trackId: ${r.id}] [mid: ${i.mid}]`);
    let o;
    a(this, qi) === we.HIVE ? o = `${n[0].id}:${r.kind}` : o = `${i.mid}:${r.kind}`, r.addEventListener("ended", () => {
      this.logger.info(`rtc consumer track ended [trackId: ${r.id}]`), this.unknownTracksMap.delete(o);
    });
    const c = this.consumerTrackEvents.get(o);
    c ? (c(r, i), this.consumerTrackEvents.delete(o)) : (this.logger.warn(`track event handler not found ${o}`), this.unknownTracksMap.set(o, e));
  }
  sendErrorOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i, true);
  }
  sendResponseOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i);
  }
  createConsumerObjectAndWaitForTrack(e) {
    return u(this, null, function* () {
      const {
        consumerId: r,
        producerId: i,
        producingPeerId: n,
        producingTransportId: o,
        streamId: c,
        paused: d,
        screenShare: l,
        appData: p,
        kind: f,
        mimeType: S
      } = e, T = `${c}:${f}`, _ = B(D({}, e), {
        name: "consumer creation task error",
        message: "consumer creation failed"
      });
      return new Promise((P, w) => u(this, null, function* () {
        const A = setTimeout(() => {
          this.logger.warn(`Timed out waiting for track event ${T} producingPeerId: ${n}`), this.consumerTrackEvents.delete(T), _.isTimedout = true, w(_);
        }, 5e3), N = /* @__PURE__ */ __name(($, F) => {
          try {
            if ($.readyState === "ended")
              clearTimeout(A), w(_);
            else {
              const K = $;
              K.enabled = true, this.handler.midTransceiverMap.set(F.mid, F);
              const re = new sD(a(this, ji), {
                id: r,
                localId: F.mid,
                transceiver: F,
                track: K,
                paused: d,
                producerId: i,
                producingPeerId: n,
                producingTransportId: o,
                handler: this.handler,
                appData: B(D({}, p), { screenShare: l, peerId: n }),
                rtpReceiver: F.receiver,
                mimeType: S
              });
              this.consumers.set(r, re), re.once("close", () => {
                this.consumers.delete(re.id), this.handler.midTransceiverMap.delete(F.mid);
              }), this.logger.info("consumer created for ", {
                consumer: {
                  id: r,
                  kind: f,
                  appData: {
                    screenShare: l
                  },
                  peerId: n,
                  producerId: i
                }
              }), this.emit("newconsumer", re), clearTimeout(A), P(re);
            }
          } catch (K) {
            this.logger.warn("error while creating consumer:", K), clearTimeout(A), w(_);
          }
        }, "N"), H = this.unknownTracksMap.get(T);
        H ? (this.logger.info(`track event already received [trackId: ${H.track.id}] [mid: ${H.transceiver.mid}]`), this.unknownTracksMap.delete(T), N(H.track, H.transceiver)) : (this.logger.info(`Registering onTrack handler for key ${T} [producingPeerId: ${n}]`), this.consumerTrackEvents.set(T, N));
      }));
    });
  }
  setRemoteDescription(e) {
    return u(this, null, function* () {
      yield this.handler.pc.setRemoteDescription(e);
    });
  }
  setLocalDescription(e) {
    return u(this, null, function* () {
      this.logger.debug(`${this.direction}() {transportId: ${this.serverId}} | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), yield this.handler.pc.setLocalDescription(e);
    });
  }
  sendDataChannelMessage(e, r) {
    return u(this, null, function* () {
      const i = this.getDatachannel(e);
      if (!i)
        throw Y0("DC_NOT_READY", `${e} datachannel not ready`);
      const n = (yield i.request(r)).payload;
      return this.logger.info(`sendDataChannelMessage::response ${JSON.stringify(n)}`), n;
    });
  }
};
var th = Va;
qi = /* @__PURE__ */ new WeakMap(), ji = /* @__PURE__ */ new WeakMap();
function aD(s) {
  if (typeof navigator == "object" && navigator.product === "ReactNative") {
    if (typeof RTCPeerConnection == "undefined") {
      s.warn(
        "Device::this._detectDevice() | unsupported ReactNative without RTCPeerConnection"
      );
      return;
    }
    return s.debug("Device::this._detectDevice() | ReactNative handler chosen"), "Chrome74";
  }
  if (typeof navigator == "object" && true) {
    const t = "Cloudflare-Workers", e = Bowser.getParser(t), r = e.getEngine();
    if (e.satisfies({
      chrome: ">=74",
      chromium: ">=74",
      "microsoft edge": ">=88"
    }))
      return "Chrome74";
    if (e.satisfies({ chrome: ">=55", chromium: ">=55" }))
      return;
    if (e.satisfies({ firefox: ">=110" }))
      return "Firefox110";
    if (e.satisfies({ firefox: ">=60" }))
      return "Firefox60";
    if (e.satisfies({ ios: { OS: ">=14.3", firefox: ">=30.0" } }) || e.satisfies({ safari: ">=12.0" }) && typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection"))
      return "Safari12";
    if (e.satisfies({ safari: ">=11" }) || e.satisfies({ "microsoft edge": ">=11" }) && e.satisfies({ "microsoft edge": "<=18" }))
      return;
    if (r.name && r.name.toLowerCase() === "blink") {
      const i = t.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
      return i ? Number(i[1]) >= 74 ? "Chrome74" : void 0 : "Chrome74";
    }
    if (r.name.toLowerCase() === "webkit" && e.getOS().name.toLowerCase() === "ios")
      return typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") ? "Safari12" : void 0;
    s.warn("Device::this._detectDevice() | browser not supported");
    return;
  }
  s.warn("Device::this._detectDevice() | unknown device");
}
__name(aD, "aD");
var lc;
var rr;
var Gi;
var nD = class {
  static {
    __name(this, "nD");
  }
  constructor(t, e, { handlerName: r, handlerFactory: i } = {}) {
    h(this, "handlerFactory");
    g(this, lc, void 0);
    g(this, rr, void 0);
    g(this, Gi, void 0);
    const n = t.getValue("logger");
    if (n.debug("constructor()"), m(this, rr, t), m(this, Gi, n), m(this, lc, e), r && i)
      throw new TypeError(
        "just one of handlerName or handlerInterface can be given"
      );
    if (i)
      this.handlerFactory = i;
    else {
      if (r)
        a(this, Gi).debug(`Device::constructor() | handler given: ${r}`);
      else if (r = aD(a(this, Gi)), r)
        a(this, Gi).debug(`Device::constructor() | detected handler: ${r}`);
      else
        throw new Error("device not supported");
      switch (r) {
        case "Chrome74":
          this.handlerFactory = qh.createFactory(a(this, rr));
          break;
        case "Safari12":
          this.handlerFactory = jh.createFactory(a(this, rr));
          break;
        case "Firefox60":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: false }
          );
          break;
        case "Firefox110":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: true }
          );
          break;
        default:
          throw new TypeError(`unknown handlerName "${r}"`);
      }
    }
  }
  createTransport(t) {
    const e = v4();
    return new th(a(this, rr), a(this, lc), B(D({
      id: e
    }, t), {
      handlerFactory: this.handlerFactory
    }));
  }
};
lc = /* @__PURE__ */ new WeakMap(), rr = /* @__PURE__ */ new WeakMap(), Gi = /* @__PURE__ */ new WeakMap();
var oD = 2e3;
var wn;
var ot;
var ct;
var uc;
var hc;
var Wi;
var bn;
var kn;
var In;
var Ji;
var Ns;
var An;
var Mn;
var _d;
var pc;
var sh;
var nl;
var tS;
var gc;
var rh;
var ol;
var sS;
var cl;
var rS;
var dl;
var iS;
var ll;
var aS;
var ul;
var nS;
var mc;
var ih;
var fc;
var ah;
var cD = class extends ut.EventEmitter {
  static {
    __name(this, "cD");
  }
  constructor(e, r, i) {
    super();
    g(this, Mn);
    g(this, pc);
    g(this, nl);
    g(this, gc);
    g(this, ol);
    g(this, cl);
    g(this, dl);
    g(this, ll);
    g(this, ul);
    g(this, mc);
    g(this, fc);
    h(this, "context");
    g(this, wn, void 0);
    g(this, ot, void 0);
    g(this, ct, void 0);
    g(this, uc, void 0);
    g(this, hc, void 0);
    g(this, Wi, void 0);
    g(this, bn, void 0);
    g(this, kn, void 0);
    g(this, In, {
      transportFailureCount: {
        send: 0,
        recv: 0
      },
      lastConnectionTime: 0
    });
    g(this, Ji, void 0);
    g(this, Ns, "all");
    g(this, An, void 0);
    switch (this.context = e, m(this, Wi, r), m(this, An, i), m(this, wn, new nD(e, i)), m(this, bn, new eD(r, i)), i) {
      case we.CF: {
        m(this, kn, Ts);
        break;
      }
      case we.HIVE:
      default: {
        m(this, kn, is);
        break;
      }
    }
    a(this, Mn, _d).mediaState = {
      send: { state: xa.NEW },
      recv: { state: xa.NEW }
    }, (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy initially set to ${a(this, Ns)}`), L(this, pc, sh).call(this);
  }
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  get socket() {
    return a(this, Wi);
  }
  get socketHandler() {
    return a(this, bn);
  }
  get sendTransport() {
    return a(this, ot);
  }
  get recvTransport() {
    return a(this, ct);
  }
  get events() {
    return a(this, kn);
  }
  get nodeType() {
    return a(this, An);
  }
  set sendTransportConnectedCallback(e) {
    m(this, uc, e);
  }
  set recvTransportConnectedCallback(e) {
    m(this, hc, e);
  }
  setupTransports(e) {
    return u(this, null, function* () {
      yield L(this, nl, tS).call(this, e);
      let r, i;
      e.send && (r = L(this, gc, rh).call(this, a(this, ot)).then((n) => {
        try {
          a(this, uc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run send transport callback");
        }
      })), e.recv && (i = L(this, gc, rh).call(this, a(this, ct)).then((n) => {
        try {
          a(this, hc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run recv transport callback");
        }
      })), yield Promise.all([r, i]);
    });
  }
  stopTransports(e) {
    var r, i;
    if (e.send && this.sendTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ot);
      this.logger.info("Closing send transport", { transport: { id: n, serverId: o, type: c } }), a(this, ot).close(), a(this, ot).removeAllListeners(), m(this, ot, void 0);
    }
    if (e.recv && this.recvTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ct);
      this.logger.info("Closing recv transport", { transport: { id: n, serverId: o, type: c } }), (r = a(this, ct)) == null || r.close(), (i = a(this, ct)) == null || i.removeAllListeners(), m(this, ct, void 0);
    }
    L(this, pc, sh).call(this);
  }
  stopAllTransports() {
    this.logger.info("Closing all transports"), this.stopTransports({ send: true, recv: true });
  }
  handleErrors(e) {
    throw new Error("Method not implemented.");
  }
};
wn = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), uc = /* @__PURE__ */ new WeakMap(), hc = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), bn = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), Ji = /* @__PURE__ */ new WeakMap(), Ns = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakSet(), _d = /* @__PURE__ */ __name(function() {
  return this.context.getValue("connectionHandler");
}, "_d"), pc = /* @__PURE__ */ new WeakSet(), sh = /* @__PURE__ */ __name(function() {
  m(this, Ji, {
    send: void 0,
    recv: void 0
  });
}, "sh"), nl = /* @__PURE__ */ new WeakSet(), tS = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    var o, c, d, l, p, f, S, T;
    (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy set to ${a(this, Ns)}`);
    const n = yield lt().getICEServers().catch((_) => (this.logger.warn(`failed to get iceservers from server: ${_.message}`), []));
    if (e.send) {
      const _ = this.context.getValue("flagsmith").hasFeature(
        X.DISABLE_OPUS_DTX_CF
      );
      L(this, cl, rS).call(this, {
        iceServers: n,
        additionalSettings: {
          encodedInsertableStreams: (o = this.context.getValue("modules").e2ee) == null ? void 0 : o.enabled
        },
        config: {
          enableHighBitrate: (l = (d = (c = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : c.audio) == null ? void 0 : d.enableHighBitrate) != null ? l : false,
          enableStereo: (S = (f = (p = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : p.audio) == null ? void 0 : f.enableStereo) != null ? S : false,
          enableDtx: a(this, An) === we.HIVE ? true : !!_
        },
        iceTransportPolicy: a(this, Ns)
      });
    }
    e.recv && L(this, dl, iS).call(this, {
      iceServers: n,
      additionalSettings: {
        encodedInsertableStreams: (T = this.context.getValue("modules").e2ee) == null ? void 0 : T.enabled
      },
      iceTransportPolicy: a(this, Ns)
    });
  });
}, "tS"), gc = /* @__PURE__ */ new WeakSet(), rh = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    const { id: r, serverId: i, direction: n } = e;
    L(this, ll, aS).call(this, e);
    try {
      const o = this.context.getValue("flagsmith").hasFeature(
        X.ENABLE_HIVE_INFINITE_RETRIES
      ) ? 1 / 0 : 3;
      return yield Yf((c, d) => u(this, null, function* () {
        c > 0 && this.logger.debug(`Retrying transport connect, count: ${c}`, {
          transport: { id: r, serverId: i, type: n }
        });
        try {
          if (e.closed)
            throw new fi("Cannot reconnect closed transport");
          yield L(this, ol, sS).call(this, e);
        } catch (l) {
          if (l instanceof fi) {
            d(l);
            return;
          }
          throw this.logger.error("Failed to connect transport, retrying", { transport: e, error: l }), l;
        }
      }), {
        delayTime: 100,
        strategy: "exponential",
        maxRetryCount: o
      }), e;
    } catch (o) {
      throw this.logger.error(
        `Failed to connect send transport after retry: ${e.id}`,
        {
          error: o,
          transport: { id: r, serverId: i, type: n }
        }
      ), e.close(), e.removeAllListeners(), o;
    }
  });
}, "rh"), ol = /* @__PURE__ */ new WeakSet(), sS = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    const { id: r, direction: i } = e;
    if (this.logger.info(`Connecting ${i} transport`, {
      transport: { id: r, type: i }
    }), !a(this, Wi).isConnected)
      throw new fi("Socket is not connected");
    if (e.connectionState === "closed")
      throw new fi("Transport is closed");
    try {
      yield e.connect(
        (n) => L(this, ul, nS).call(this, i, n)
      ), this.logger.info(`Connected ${i} transport`, {
        transport: { id: r, serverId: e.serverId, type: i }
      });
    } catch (n) {
      throw a(this, In).transportFailureCount[i] += 1, n.message === "ice connection failed" ? new fi(n.message) : n;
    }
  });
}, "sS"), cl = /* @__PURE__ */ new WeakSet(), rS = /* @__PURE__ */ __name(function(e) {
  var r, i;
  if (a(this, ot) && a(this, ot).connected) {
    this.logger.info("Transport send is already connected", {
      transport: {
        id: (r = a(this, ot)) == null ? void 0 : r.id,
        serverId: (i = a(this, ot)) == null ? void 0 : i.serverId,
        type: "send"
      }
    });
    return;
  }
  m(this, ot, a(this, wn).createTransport(B(D({}, e), {
    direction: "send"
  }))), this.context.getValue("callstats").configureSendTransport(a(this, ot));
}, "rS"), dl = /* @__PURE__ */ new WeakSet(), iS = /* @__PURE__ */ __name(function(e) {
  var r, i;
  if (a(this, ct) && a(this, ct).connected) {
    this.logger.info("Transport recv is already connected", {
      transport: {
        id: (r = a(this, ct)) == null ? void 0 : r.id,
        serverId: (i = a(this, ct)) == null ? void 0 : i.serverId,
        type: "recv"
      }
    });
    return;
  }
  m(this, ct, a(this, wn).createTransport(B(D({}, e), {
    direction: "recv"
  }))), this.context.getValue("callstats").configureRecvTransport(a(this, ct));
}, "iS"), ll = /* @__PURE__ */ new WeakSet(), aS = /* @__PURE__ */ __name(function(e) {
  const { direction: r, id: i } = e;
  e.on("connectionstatechange", (n) => u(this, null, function* () {
    L(this, fc, ah).call(this, { state: n, direction: r }), this.logger.info(
      `Transport connection state changed for ${r} transport`,
      {
        transport: {
          id: i,
          serverId: e.serverId,
          type: r,
          status: n
        }
      }
    );
    const o = /* @__PURE__ */ __name(() => {
      const c = a(this, Ji)[r];
      c !== void 0 && (clearTimeout(c), a(this, Ji)[r] = void 0);
    }, "o");
    switch (n) {
      case "connected":
        o(), a(this, In).lastConnectionTime = performance.now();
        break;
      case "disconnected":
        a(this, Ji)[r] = setTimeout(() => u(this, null, function* () {
          this.logger.warn(`${r} transport is in disconnected state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        }), oD);
        break;
      case "failed":
        if (e.closed)
          return;
        o(), this.logger.warn(`${r} transport is in failed state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        break;
    }
  })), e.on("icecandidate", (n) => u(this, null, function* () {
    this.logger.debug("Sending iceCandidate:", { iceCandidate: n });
  })), e.on("datachannel:events", (n, o) => u(this, null, function* () {
    var c, d;
    this.logger.debug("Got data channel message on event:", {
      rtcChannel: { label: n, message: o }
    });
    try {
      switch (o.type) {
        case "handshake": {
          const l = {
            type: "handshake",
            payload: {
              message: "pong"
            }
          };
          e.sendResponseOverDC(n, eS(o), l);
          break;
        }
        case "hub-disconnect": {
          this.logger.debug(`media hub disconnected, full_reconnect: ${(c = o.payload) == null ? void 0 : c.full_reconnect}`), ((d = o.payload) == null ? void 0 : d.full_reconnect) === true && this.handleErrors("rejoin");
          break;
        }
        case "error":
          break;
        default:
          break;
      }
    } catch (l) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${n}`
      );
    }
  })), e.on("dc_error", () => {
    e.direction === "recv" && (this.logger.warn("Events datachannel did not open in 5s", { country: E.location.country }), this.handleErrors("reconnectRecvTransport"));
  });
}, "aS"), ul = /* @__PURE__ */ new WeakSet(), nS = /* @__PURE__ */ __name(function(e, r) {
  return u(this, null, function* () {
    const i = e === "recv";
    try {
      const { sdp: n, type: o } = r, c = {
        consuming: i,
        description: {
          sdp: n,
          type: o,
          target: i ? vr.SUBSCRIBER : vr.PUBLISHER
        },
        producers: []
      };
      return a(this, bn).connectTransport(c);
    } catch (n) {
      throw this.logger.error(
        `Error in ${e} transport connection:`,
        { error: n, country: E.location.country }
      ), n;
    }
  });
}, "nS"), mc = /* @__PURE__ */ new WeakSet(), ih = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    switch (this.logger.info("Called reconnect transport", { transport: { type: e } }), this.stopTransports({ [e]: true }), this.context.getValue("flagsmith").hasFeature(
      X.HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED
    ) && a(this, Wi).isConnected && a(this, In).transportFailureCount[e] > 2 && (this.logger.warn(`Multiple disconnections in ${e} transport, forcing relay`), m(this, Ns, "relay")), yield this.setupTransports({ [e]: true }), e) {
      case "send": {
        this.logger.info("Transport reconnected", { transport: a(this, ot) }), this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE);
        break;
      }
      case "recv": {
        this.logger.info("Transport reconnected", { transport: a(this, ct) }), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: true });
        break;
      }
      default:
        this.logger.warn("Unknown transport direction", { transport: { type: e } });
    }
    L(this, fc, ah).call(this, {
      state: xa.CONNECTED,
      direction: e
    });
  });
}, "ih"), fc = /* @__PURE__ */ new WeakSet(), ah = /* @__PURE__ */ __name(function(e) {
  const { state: r, direction: i } = e;
  a(this, Mn, _d).mediaState[i] = {
    state: r
  }, this.context.getValue("peerSessionStore").emit(
    k.TRANSPORT_STATE_UPDATE,
    D({
      transport: i
    }, a(this, Mn, _d).mediaState[i])
  );
}, "ah");
var Sc;
var hl;
var oS;
var dD = class {
  static {
    __name(this, "dD");
  }
  constructor(t, e) {
    g(this, hl);
    g(this, Sc, void 0);
    this.recvTransport = e, L(this, hl, oS).call(this), m(this, Sc, t);
  }
  get logger() {
    return a(this, Sc).getValue("logger");
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const r = {
        type: "create_consumer",
        payload: {
          producers: t.map(({
            producerId: c,
            producingTransportId: d,
            kind: l,
            mimeType: p
          }) => ({
            producerId: c,
            producingTransportId: d,
            preferredCodec: D(D({}, l === "video" && p ? { video: p } : {}), l === "audio" && p ? { audio: p } : {})
          }))
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), n = /* @__PURE__ */ new Map();
      t.forEach((c) => n.set(c.producerId, c));
      const o = /* @__PURE__ */ new Map();
      return Object.entries(i).forEach(([c, d]) => {
        const l = n.get(d.producerId);
        l && o.set(d.producerId, {
          consumerId: c,
          producingTransportId: l.producingTransportId,
          producingPeerId: l.producingPeerId,
          kind: l.kind,
          paused: l.pause,
          streamId: d.streamId,
          trackId: d.trackId,
          screenShare: l.screenShare,
          mimeType: l.mimeType,
          appData: {}
        });
      }), { consumerStates: o };
    });
  }
  negotiate(t, e, r) {
    return u(this, null, function* () {
      try {
        this.logger.debug(`Received offer over dc: ${t.sdp} for transport`);
        const i = yield this.recvTransport.setRemoteOffer(t), n = {
          type: "answer",
          payload: {
            type: i.type,
            sdp: i.sdp
          }
        };
        return this.logger.debug(`datachannel answer: ${JSON.stringify(n)}`), this.recvTransport.sendResponseOverDC(r, e, n), i;
      } catch (i) {
        throw this.logger.error("datachannel:events::Error:", i), i.code !== "DC_NOT_FOUND" && this.recvTransport.sendErrorOverDC(r, e, i), i;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = t.map((o) => o.id);
      this.logger.info(`Closing consumers: ${JSON.stringify(e)}`);
      const r = {
        type: "close_consumers",
        payload: {
          consumers: e
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), { failedConsumers: n } = i;
      return { failedConsumers: n };
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      var o;
      const r = this.recvTransport.getDatachannel("events");
      if (!r) {
        this.logger.warn("events datachannel not found");
        return;
      }
      const i = (o = t == null ? void 0 : t.map(({ id: c }) => c)) != null ? o : [], n = {
        type: "switch_consumer_layer",
        payload: {
          consumerIds: i,
          layer: e
        }
      };
      yield r.request(n), this.logger.info(`Consumers switched layers to ${e}`, { consumerIds: i });
    });
  }
};
Sc = /* @__PURE__ */ new WeakMap(), hl = /* @__PURE__ */ new WeakSet(), oS = /* @__PURE__ */ __name(function() {
  this.recvTransport.on("datachannel:events", (e, r) => u(this, null, function* () {
    try {
      switch (r.type) {
        case "negotiation": {
          const { sdp: i } = r.payload, n = {
            sdp: i,
            type: "offer"
          };
          this.negotiate(n, eS(r), e);
          break;
        }
        default:
          break;
      }
    } catch (i) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${e}`
      );
    }
  }));
}, "oS");
var vc;
var ts;
var lD = class {
  static {
    __name(this, "lD");
  }
  constructor(t, e, r, i, n) {
    g(this, vc, void 0);
    g(this, ts, void 0);
    this.events = e, this.recvTransport = r, this.socket = i, this.socketHandler = n, m(this, vc, t), m(this, ts, t.getValue("logger"));
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const e = /* @__PURE__ */ new Map(), r = [];
      t.forEach((d) => {
        const { producingPeerId: l, producerId: p, producingTransportId: f } = d, S = a(this, vc).getValue("flagsmith").hasFeature(X.ENABLE_CF_SIMULCAST) ? {
          simulcast: {
            preferredRid: "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        } : {};
        e.set(p, l), r.push(D({
          producingPeerId: l,
          producerId: p,
          producingTransportId: f
        }, S));
      });
      const i = yield this.socketHandler.consume({
        requests: r,
        consumingTransportId: this.recvTransport.serverId
      }), n = /* @__PURE__ */ new Map();
      t.forEach((d) => n.set(d.producerId, d));
      const o = /* @__PURE__ */ new Map(), c = [];
      return Object.entries(i.consumerStateMap).forEach(([d, l]) => {
        const p = n.get(d);
        if (!p)
          return;
        if (l.errorCode) {
          a(this, ts).warn(`Consumer request failed for producer ${d}`, {
            error: { message: l.errorCode }
          }), c.push(B(D({}, p), { errorCode: l.errorCode }));
          return;
        }
        let f = {};
        try {
          f = JSON.parse(l.producerState.appData);
        } catch (S) {
        }
        o.set(d, {
          consumerId: l.consumerId,
          producingTransportId: p.producingTransportId,
          producingPeerId: p.producingPeerId,
          kind: p.kind,
          paused: p.pause,
          streamId: l.producerTrack.streamId,
          trackId: l.producerTrack.trackId,
          screenShare: p.screenShare,
          mimeType: p.mimeType,
          appData: f
        });
      }), { consumerStates: o, sessionDescription: i.sessionDescription, failedProducers: c };
    });
  }
  negotiate(t) {
    return u(this, null, function* () {
      try {
        a(this, ts).info("Negotiating socket consumer", { transport: this.recvTransport }), a(this, ts).debug(`setting remote offer: ${JSON.stringify(t)} on recvTransport`, {
          transport: this.recvTransport
        });
        const e = yield this.recvTransport.setRemoteOffer(t), r = {
          transportId: this.recvTransport.serverId,
          description: {
            sdp: e.sdp,
            type: e.type,
            target: vr.SUBSCRIBER
          }
        };
        return a(this, ts).debug(`sending renegotiate request: ${JSON.stringify(r)} on recvTransport`, {
          transport: this.recvTransport
        }), yield this.socket.sendMessagePromise(
          this.events.renegotiateSessionDescription,
          JC.toBinary(r)
        ), a(this, ts).info("Renegotiation done", { transport: this.recvTransport }), e;
      } catch (e) {
        a(this, ts).error("Failed to renegotiate", { error: e });
        return;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = /* @__PURE__ */ __name((r, i) => u(this, null, function* () {
        const n = r.map((l) => l.localId);
        a(this, ts).info(`Closing consumers: ${JSON.stringify(n)}`);
        const o = {
          description: {
            sdp: i.sdp,
            type: i.type,
            target: vr.SUBSCRIBER
          },
          consumerIds: n,
          consumingTransportId: this.recvTransport.serverId
        }, c = yield this.socketHandler.closeConsumer(o), d = Tw.fromBinary(c).description;
        return {
          sdp: d.sdp,
          type: d.type
        };
      }), "e");
      return yield this.recvTransport.awaitQueue.push(() => this.recvTransport.closeConsumers(t, e), "ConsumerStrategy.close", { consumersLength: t.length }), {};
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      const r = {
        requests: [],
        consumingTransportId: this.recvTransport.serverId
      }, i = t.filter((n) => n && n.id);
      i.forEach(({ id: n, producingTransportId: o, localId: c }) => {
        r.requests.push({
          producerId: n,
          producingTransportId: o,
          mid: c,
          simulcast: {
            preferredRid: e === 0 ? "q" : "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        });
      }), yield this.socketHandler.updateConsumersSimulcastConfig(r), a(this, ts).info(`Consumers switched layers to ${e}`, { consumerIds: i == null ? void 0 : i.map(({ id: n }) => n) });
    });
  }
};
vc = /* @__PURE__ */ new WeakMap(), ts = /* @__PURE__ */ new WeakMap();
var Gh = class _Gh {
  static {
    __name(this, "Gh");
  }
  constructor(t) {
    this.socketHandler = t;
  }
  static getMSIDFromSDP(t, e) {
    return parse(t).media.filter(
      (n) => e === "video" ? n.type === "video" : n.type === "audio"
    ).at(-1).msid;
  }
  create(c) {
    return u(this, arguments, function* ({
      offer: t,
      kind: e,
      paused: r,
      appData: i,
      codecOptions: n,
      producingTransportId: o
    }) {
      var S, T;
      const d = _Gh.getMSIDFromSDP(t.sdp, e), l = {
        description: {
          sdp: t.sdp,
          type: t.type,
          target: vr.PUBLISHER
        },
        paused: r,
        kind: e,
        msid: d,
        appData: JSON.stringify(i),
        screenShare: (S = i.screenShare) != null ? S : false,
        mimeType: `${e}/${(T = n[0]) == null ? void 0 : T.name}`,
        producingTransportId: o
      }, { answer: p, producerId: f } = yield this.socketHandler.produce(l);
      return { answer: p, producerId: f };
    });
  }
};
var Ki;
var Wr;
var Dn;
var yc;
var ps;
var pl;
var ir;
var On;
var Tc;
var nh;
var gl;
var cS;
var ml;
var dS;
var fl;
var lS;
var Sl;
var uS;
var uD = class extends cD {
  static {
    __name(this, "uD");
  }
  constructor(e, r, i) {
    super(e, r, i);
    g(this, Tc);
    g(this, gl);
    g(this, ml);
    g(this, fl);
    g(this, Sl);
    g(this, Ki, void 0);
    g(this, Wr, void 0);
    g(this, Dn, void 0);
    g(this, yc, void 0);
    g(this, ps, void 0);
    g(this, pl, {
      producerCreationFailureCount: 0,
      consumerCreationFailureCount: 0,
      producerNotReadyFailureCount: 0
    });
    g(this, ir, []);
    g(this, On, void 0);
    this.context = e, this.sendTransportConnectedCallback = () => u(this, null, function* () {
      m(this, yc, new Gh(this.socketHandler));
    }), this.recvTransportConnectedCallback = (n) => u(this, null, function* () {
      switch (a(this, Dn).clear(), this.nodeType) {
        case we.CF: {
          m(this, ps, new lD(
            this.context,
            this.events,
            n,
            this.socket,
            this.socketHandler
          ));
          break;
        }
        case we.HIVE:
        default:
          m(this, ps, new dD(this.context, n));
      }
    }), this.reset();
  }
  get socketHandler() {
    return super.socketHandler;
  }
  get producers() {
    return a(this, Ki);
  }
  get consumers() {
    return a(this, Wr);
  }
  get producerIdToConsumerIdMap() {
    return a(this, Dn);
  }
  get logger() {
    return this.context.getValue("logger");
  }
  reset() {
    m(this, Ki, /* @__PURE__ */ new Map()), m(this, Wr, /* @__PURE__ */ new Map()), m(this, Dn, /* @__PURE__ */ new Map());
  }
  createProducer(e, r) {
    return u(this, null, function* () {
      var i;
      if (!this.sendTransport || this.sendTransport.closed)
        throw new Error("Send transport is closed");
      try {
        const n = yield this.sendTransport.produce(
          e,
          L(this, gl, cS).bind(this)
        );
        return (i = e.appData) != null && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, n), L(this, ml, dS).call(this, n, r), n;
      } catch (n) {
        throw this.logger.error("Failed to create producer", { error: n }), a(this, pl).producerCreationFailureCount += 1, n;
      }
    });
  }
  closeProducer(e, r) {
    return u(this, null, function* () {
      var n;
      const i = this.producers.get(e);
      if (!i) {
        this.logger.warn(`Producer with ID ${e} was not found`);
        return;
      }
      r != null && r.stopTrack && i.track.stop();
      try {
        yield this.sendTransport.closeProducer(i), (n = this.context.getValue("modules").e2ee) != null && n.enabled && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_PRODUCER, i);
      } catch (o) {
        this.logger.error("Failed to close producer on server", { error: o, producer: i });
      }
    });
  }
  closeAllProducers() {
    return Promise.all(Array.from(a(this, Ki).entries()).map(([, e]) => e.close()));
  }
  createConsumer(e) {
    return this.createConsumers([e]);
  }
  createConsumers(e) {
    return u(this, null, function* () {
      a(this, On) || clearTimeout(a(this, On)), m(this, ir, a(this, ir).concat(e)), yield L(this, Tc, nh).call(this);
    });
  }
  closeConsumer(e) {
    return this.closeConsumers([e]);
  }
  closeConsumers(e) {
    return u(this, null, function* () {
      if (!a(this, ps))
        return;
      const r = e.map((n) => this.consumers.get(n)).filter((n) => n !== void 0);
      if (r.length === 0)
        return;
      const { failedConsumers: i } = yield a(this, ps).close(r);
      i != null && i.length && this.logger.warn("Failed to close some consumers", { consumerIds: i });
    });
  }
  closeAllConsumers() {
    return this.closeConsumers(Array.from(a(this, Wr).keys()));
  }
  switchConsumersToLayer(e, r) {
    return u(this, null, function* () {
      a(this, ps).switchConsumersToLayer(e, r);
    });
  }
};
Ki = /* @__PURE__ */ new WeakMap(), Wr = /* @__PURE__ */ new WeakMap(), Dn = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), ps = /* @__PURE__ */ new WeakMap(), pl = /* @__PURE__ */ new WeakMap(), ir = /* @__PURE__ */ new WeakMap(), On = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakSet(), nh = /* @__PURE__ */ __name(function() {
  return u(this, null, function* () {
    if (!this.recvTransport || this.recvTransport.closed)
      throw new Error("Recv transport is closed");
    const e = 500, r = a(this, ir).splice(0, a(this, ir).length);
    try {
      const i = new Set(Array.from(this.consumers.values()).map(({ producerId: d }) => d)), n = r.filter(({ producerId: d }) => !this.producers.get(d) && !i.has(d));
      if (n.length === 0)
        return;
      const { consumers: o, failedProducers: c } = yield this.recvTransport.consume(
        n,
        L(this, fl, lS).bind(this),
        a(this, ps).negotiate.bind(a(this, ps))
      );
      if (o.forEach(L(this, Sl, uS).bind(this)), c != null && c.length) {
        this.logger.error("Failed to create consumers for producers", { producers: c });
        const d = c.filter(({ errorCode: l, producerId: p }) => l === "not_found_track_error" ? (this.logger.error(`Track not found for producer: ${p}. This will not be retried.`), false) : l === "backend_error" ? (this.logger.error("Unrecoverable error: backend error"), false) : true);
        m(this, ir, a(this, ir).concat(d)), m(this, On, setTimeout(
          L(this, Tc, nh).bind(this),
          e
        ));
      }
    } catch (i) {
      if (this.logger.error("failed to consume on transport", { error: i }), i.errorCode === "internal_error" && i.errorDescription === "Backend error" || i.errorCode === "invalid_session_description") {
        this.logger.error(
          "Irrecoverable error, closing current recvTransport to create a new one",
          {
            transport: this.recvTransport,
            error: { code: i.errorCode, message: i.errorDescription }
          }
        );
        try {
          this.stopTransports({ recv: true });
        } catch (n) {
        }
        yield this.setupTransports({ recv: true });
      }
    }
  });
}, "nh"), gl = /* @__PURE__ */ new WeakSet(), cS = /* @__PURE__ */ __name(function(e) {
  return a(this, yc).create(e);
}, "cS"), ml = /* @__PURE__ */ new WeakSet(), dS = /* @__PURE__ */ __name(function(e, r) {
  e.on("close", (i, n) => u(this, null, function* () {
    const { offer: o, reason: c } = i;
    if (this.logger.info("producer::closing", {
      debuggingHint: c,
      producer: B(D({}, e), { status: "closing" })
    }), c !== Ud) {
      const d = {
        producerId: e.id,
        description: {
          sdp: o.sdp,
          type: o.type,
          target: vr.PUBLISHER
        }
      };
      try {
        const l = yield this.socketHandler.closeProducer(d), p = {
          sdp: l == null ? void 0 : l.sdp,
          type: l == null ? void 0 : l.type
        };
        this.logger.info("producer::closed", { producer: B(D({}, e), { status: "closed" }) }), n({ answer: p });
      } catch (l) {
        this.logger.error("producer close error", l);
      }
    }
    this.producers.delete(e.id), r();
  })), e.on("trackended", () => {
    this.logger.info("producer::trackended", { producer: B(D({}, e), { status: "UNKNOWN" }) });
  }), a(this, Ki).set(e.id, e);
}, "dS"), fl = /* @__PURE__ */ new WeakSet(), lS = /* @__PURE__ */ __name(function(e) {
  return u(this, null, function* () {
    try {
      return yield this.recvTransport.canConsume(), yield a(this, ps).create(e);
    } catch (r) {
      throw this.logger.error("Error in consume request", { error: r }), r;
    }
  });
}, "lS"), Sl = /* @__PURE__ */ new WeakSet(), uS = /* @__PURE__ */ __name(function(e) {
  e.on("close", (r) => u(this, null, function* () {
    this.logger.debug("consumer closed", {
      consumer: {
        closureReason: r,
        id: e.id,
        kind: e.kind,
        appData: e.appData
      }
    }), a(this, Wr).delete(e.id), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, { id: e.id });
  })), a(this, Wr).set(e.id, e), this.producerIdToConsumerIdMap.set(e.producerId, e.id), this.context.getValue("peerSessionStore").emit(k.NEW_CONSUMER, {
    id: e.id,
    appData: e.appData,
    peerId: e.peerId
  });
}, "uS");
var Ec;
var _c;
var Pc;
var Nn;
var Vn;
var Ln;
var Cc;
var Rc;
var xn;
var bt;
var gs;
var ms;
var zi;
var Yi;
var ar;
var wc;
var vl;
var hS;
var yl;
var pS;
var Tl;
var gS;
var El;
var mS;
var _l = class {
  static {
    __name(this, "_l");
  }
  constructor({
    initialEnergyThreshold: t = 0.015,
    zeroCrossingThreshold: e = 20,
    minVoiceDuration: r = 3,
    hangoverFrames: i = 5,
    noiseAdaptationRate: n = 0.95,
    voiceAdaptationRate: o = 0.99,
    minEnergyThreshold: c = 5e-3,
    maxEnergyThreshold: d = 0.2,
    energyRatioThreshold: l = 1.5,
    noiseHistorySize: p = 50
  } = {}) {
    g(this, vl);
    g(this, yl);
    g(this, Ec, void 0);
    g(this, _c, void 0);
    g(this, Pc, void 0);
    g(this, Nn, void 0);
    g(this, Vn, void 0);
    g(this, Ln, void 0);
    g(this, Cc, void 0);
    g(this, Rc, void 0);
    g(this, xn, void 0);
    g(this, bt, void 0);
    g(this, gs, void 0);
    g(this, ms, false);
    g(this, zi, 0);
    g(this, Yi, 0);
    g(this, ar, []);
    g(this, wc, void 0);
    m(this, Nn, t), m(this, bt, t), m(this, Ec, e), m(this, _c, r), m(this, Pc, i), m(this, Vn, n), m(this, Ln, o), m(this, Cc, c), m(this, Rc, d), m(this, xn, l), m(this, wc, p), m(this, gs, t / 2);
  }
  get voiceDetected() {
    return a(this, ms);
  }
  processAudioChunk(t) {
    var o, c;
    const e = L(o = _l, Tl, gS).call(o, t), r = L(c = _l, El, mS).call(c, t);
    return L(this, vl, hS).call(this, e), e / a(this, gs) > a(this, xn) && e > a(this, bt) && r > a(this, Ec) ? (m(this, zi, a(this, zi) + 1), m(this, Yi, a(this, Pc)), a(this, zi) >= a(this, _c) && m(this, ms, true)) : (m(this, zi, 0), a(this, Yi) > 0 ? m(this, Yi, a(this, Yi) - 1) : a(this, ms) && m(this, ms, false), a(this, ms) || L(this, yl, pS).call(this, e)), { energy: e, isVoice: a(this, ms) };
  }
  reset() {
    m(this, ms, false), m(this, zi, 0), m(this, Yi, 0), m(this, bt, a(this, Nn)), m(this, gs, a(this, Nn) / 2), m(this, ar, []);
  }
  getThresholdInfo() {
    return {
      currentEnergyThreshold: a(this, bt),
      backgroundNoiseEnergy: a(this, gs),
      energyRatioThreshold: a(this, xn)
    };
  }
};
var Po = _l;
Ec = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), gs = /* @__PURE__ */ new WeakMap(), ms = /* @__PURE__ */ new WeakMap(), zi = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), vl = /* @__PURE__ */ new WeakSet(), hS = /* @__PURE__ */ __name(function(t) {
  a(this, ms) ? m(this, bt, a(this, Ln) * a(this, bt) + (1 - a(this, Ln)) * t) : m(this, bt, a(this, Vn) * a(this, bt) + (1 - a(this, Vn)) * a(this, gs)), m(this, bt, Math.max(
    a(this, Cc),
    Math.min(a(this, Rc), a(this, bt))
  ));
}, "hS"), yl = /* @__PURE__ */ new WeakSet(), pS = /* @__PURE__ */ __name(function(t) {
  if (t < a(this, bt) * 1.2)
    if (a(this, ar).push(t), a(this, ar).length > a(this, wc) && a(this, ar).shift(), a(this, ar).length >= 10) {
      const e = [...a(this, ar)].sort((i, n) => i - n), r = Math.floor(e.length / 2);
      m(this, gs, e[r]);
    } else
      m(this, gs, 0.95 * a(this, gs) + 0.05 * t);
}, "pS"), Tl = /* @__PURE__ */ new WeakSet(), gS = /* @__PURE__ */ __name(function(t) {
  return Math.sqrt(
    t.map((e) => e * e).reduce((e, r) => e + r) / t.length
  );
}, "gS"), El = /* @__PURE__ */ new WeakSet(), mS = /* @__PURE__ */ __name(function(t) {
  let e = 0;
  for (let r = 1; r < t.length; r += 1)
    (t[r] >= 0 && t[r - 1] < 0 || t[r] < 0 && t[r - 1] >= 0) && (e += 1);
  return e;
}, "mS"), g(Po, Tl), g(Po, El);
var bc;
var vg = class {
  static {
    __name(this, "vg");
  }
  constructor(t) {
    h(this, "RNAudioSampleHandler");
    g(this, bc, void 0);
    m(this, bc, t);
    const { RNAudioSampleHandlerImpl: e } = navigator;
    e == null || e.init().then((r) => {
      this.RNAudioSampleHandler = r;
    }).catch((r) => {
      this.logger.error("ReactNativeAudioSampler: Failed to initialize audio sampler", r);
    });
  }
  get logger() {
    return a(this, bc).getValue("logger");
  }
  get samples() {
    var e;
    const t = new Float32Array(1024);
    return (e = this.RNAudioSampleHandler) == null || e.getFloatTimeDomainData(t), t;
  }
  stop() {
    var t;
    (t = this.RNAudioSampleHandler) == null || t.destructor();
  }
};
bc = /* @__PURE__ */ new WeakMap();
var kc;
var yg = class {
  static {
    __name(this, "yg");
  }
  constructor(t) {
    h(this, "audioContext");
    h(this, "analyser");
    g(this, kc, void 0);
    m(this, kc, t), this.audioContext = new AudioContext(), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2048;
  }
  get logger() {
    return a(this, kc).getValue("logger");
  }
  get samples() {
    if (this.audioContext.state === "suspended")
      try {
        this.audioContext.resume();
      } catch (e) {
        this.logger.error("AudioContextSampler: Failed to resume audio context", e);
      }
    const t = new Float32Array(this.analyser.frequencyBinCount);
    return this.analyser.getFloatTimeDomainData(t), t;
  }
  set audioTrack(t) {
    const e = new MediaStream();
    e.addTrack(t), this.audioContext.createMediaStreamSource(e).connect(this.analyser);
  }
};
kc = /* @__PURE__ */ new WeakMap();
var hD = class {
  static {
    __name(this, "hD");
  }
  static setInterval(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setInterval(t, e, ...r) : global.setInterval(t, e, ...r);
  }
  static clearInterval(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearInterval(t) : global.clearInterval(t);
  }
  static setTimeout(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setTimeout(t, e, ...r) : global.setTimeout(t, e, ...r);
  }
  static clearTimeout(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearTimeout(t) : global.clearTimeout(t);
  }
};
var pD = 60;
var gD = 400;
var nr;
var or;
var fs;
var Ic;
var Qi;
var Un;
var cr;
var Jr;
var $n;
var dr;
var lr;
var Vs;
var Pl;
var fS;
var Ac;
var oh;
var Cl;
var SS;
var Rl;
var vS;
var No = class {
  static {
    __name(this, "No");
  }
  constructor(t, e) {
    g(this, Pl);
    g(this, Cl);
    g(this, nr, void 0);
    g(this, or, void 0);
    g(this, fs, void 0);
    g(this, Ic, void 0);
    g(this, Qi, void 0);
    g(this, Un, void 0);
    g(this, cr, void 0);
    g(this, Jr, void 0);
    g(this, $n, void 0);
    g(this, dr, void 0);
    g(this, lr, void 0);
    g(this, Vs, void 0);
    this.reportRequest = e, m(this, dr, t), m(this, Un, new Po());
    const { isReactNative: r } = navigator;
    m(this, lr, r ? new vg(a(this, dr)) : new yg(a(this, dr))), m(this, Vs, r ? hD : ud);
  }
  get logger() {
    return a(this, dr).getValue("logger");
  }
  set producerId(t) {
    m(this, fs, t);
  }
  set audioTrack(t) {
    m(this, Ic, t), a(this, lr) instanceof yg && (a(this, lr).audioTrack = t);
  }
  start() {
    this.logger.debug(`AudioActivityReporter: Starting audio activity reporter: ${a(this, fs)}`), a(this, nr) && a(this, Vs).clearInterval(a(this, nr)), m(this, nr, a(this, Vs).setInterval(() => u(this, null, function* () {
      var i;
      if (!a(this, Ic) || !a(this, fs))
        return;
      const { energy: t } = L(this, Pl, fS).call(this), e = L(i = No, Ac, oh).call(i, t);
      let r = 0.9;
      a(this, $n) !== e && a(this, $n) ? r = 0.9 : e ? r = 0.3 : r = 0.5, m(this, Qi, (a(this, Qi) || 0) * (1 - r) + t * r);
    }), pD)), a(this, or) && a(this, Vs).clearInterval(a(this, or)), m(this, or, a(this, Vs).setInterval(
      L(this, Cl, SS).bind(this),
      gD
    ));
  }
  stop() {
    try {
      this.logger.debug(`AudioActivityReporter: Stopping audio activity reporter: ${a(this, fs)}`), a(this, nr) && (a(this, Vs).clearInterval(a(this, nr)), m(this, nr, void 0)), a(this, or) && (a(this, Vs).clearInterval(a(this, or)), m(this, or, void 0));
    } catch (t) {
    }
    a(this, Un).reset(), a(this, lr) instanceof vg && a(this, lr).stop();
  }
};
var Co = No;
nr = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), fs = /* @__PURE__ */ new WeakMap(), Ic = /* @__PURE__ */ new WeakMap(), Qi = /* @__PURE__ */ new WeakMap(), Un = /* @__PURE__ */ new WeakMap(), cr = /* @__PURE__ */ new WeakMap(), Jr = /* @__PURE__ */ new WeakMap(), $n = /* @__PURE__ */ new WeakMap(), dr = /* @__PURE__ */ new WeakMap(), lr = /* @__PURE__ */ new WeakMap(), Vs = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakSet(), fS = /* @__PURE__ */ __name(function() {
  var o;
  const { samples: t } = a(this, lr), { energy: e, isVoice: r } = a(this, Un).processAudioChunk(t), i = L(o = No, Rl, vS).call(o, e);
  return a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(
    `AudioActivityReporter: producer: ${a(this, fs)}, energy: ${a(this, Qi)},
				slogScale: ${i}, isVoice: ${r}, minEnergy: ${a(this, cr)},
				maxEnergy: ${a(this, Jr)}`
  ), i === -1 / 0 || e < 1e-6 ? { energy: 0, isVoice: false } : ((!a(this, cr) || i < a(this, cr)) && m(this, cr, i), (!a(this, Jr) || i > a(this, Jr)) && m(this, Jr, i), { energy: (i - a(this, cr)) / (a(this, Jr) - a(this, cr)) * 10 || 0, isVoice: r });
}, "fS"), Ac = /* @__PURE__ */ new WeakSet(), oh = /* @__PURE__ */ __name(function(t) {
  return t < 5;
}, "oh"), Cl = /* @__PURE__ */ new WeakSet(), SS = /* @__PURE__ */ __name(function(t = a(this, Qi)) {
  var r;
  if (!a(this, fs) || !t) {
    a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(`AudioActivityReporter: No producerId or energy to report: ${a(this, fs)}`);
    return;
  }
  const e = {
    producerId: a(this, fs),
    energy: Math.round(t),
    silent: L(r = No, Ac, oh).call(r, t)
  };
  m(this, $n, e.silent), this.reportRequest(e);
}, "SS"), Rl = /* @__PURE__ */ new WeakSet(), vS = /* @__PURE__ */ __name(function(t) {
  const e = Math.log10(t);
  return Math.round(e);
}, "vS"), g(Co, Ac), g(Co, Rl);
var mD = /* @__PURE__ */ __name((s = false) => {
  if ("MediaStreamTrackGenerator" in window && "AudioData" in window)
    try {
      const e = new window.MediaStreamTrackGenerator({ kind: "audio" }), r = e.writable.getWriter(), i = 48e3, n = 128, o = 1;
      let c = 0, d = null;
      const l = /* @__PURE__ */ __name(() => u(void 0, null, function* () {
        try {
          const S = new Float32Array(n * o), T = new window.AudioData({
            format: "f32",
            sampleRate: i,
            numberOfFrames: n,
            numberOfChannels: o,
            timestamp: c,
            data: S
          });
          c += n / i * 1e6, yield r.ready, yield r.write(T);
        } catch (S) {
          d && clearInterval(d), r.releaseLock(), e.writable.abort();
        }
      }), "l");
      d = window.setInterval(l, 100);
      const f = new MediaStream([e]).getAudioTracks()[0];
      return f.addEventListener("ended", () => {
        d && clearInterval(d), r.releaseLock(), e.writable.abort();
      }), Object.assign(f, { fakeTracks: "fakeTracks:fakeAudioTrack" }), f.enabled = s, f;
    } catch (e) {
    }
  const t = window.AudioContext || window.webkitAudioContext;
  if (t)
    try {
      const e = new t();
      if (!e || e.state !== "running" || !e.destination)
        return;
      const r = e.createOscillator();
      r.frequency.value = 0, r.type = "sine";
      const i = e.createGain();
      i.gain.value = 0, r.connect(i);
      const n = e.createMediaStreamDestination();
      i.connect(n), r.start();
      const o = n.stream.getAudioTracks()[0];
      return o ? (Object.assign(o, { fakeTracks: "fakeTracks:fakeAudioTrack" }), o.enabled = s, o) : void 0;
    } catch (e) {
      return;
    }
}, "mD");
var fD = /* @__PURE__ */ __name((s = false) => {
  var n, o;
  const t = new MediaStream().getVideoTracks()[0], e = document.createElement("canvas");
  e.height = (n = t == null ? void 0 : t.getSettings().height) != null ? n : 720, e.width = (o = t == null ? void 0 : t.getSettings().width) != null ? o : 1280;
  const r = e.getContext("2d");
  r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height), setInterval(() => {
    r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height);
  }, 1e3);
  const i = e.captureStream().getVideoTracks()[0];
  return Object.assign(i, { fakeTracks: "fakeTracks:fakeVideoTrack" }), i.enabled = s, i;
}, "fD");
var SD = Object.defineProperty;
var vD = Object.getOwnPropertyDescriptor;
var le = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? vD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && SD(t, e, i), i;
}, "le");
var Nt = ["video/VP9", "video/VP8"];
var Mc;
var Dc;
var dt;
var G;
var Fn;
var Ls;
var yt;
var Xi;
var Zi;
var ea;
var Oc;
var ss;
var ur;
var Nc;
var ta;
var sa;
var Tt;
var kt;
var Kr;
var ka;
var wl;
var TS;
var bl;
var ES;
var kl;
var _S;
var Vc;
var ch;
var Il;
var Tu;
var PS;
var Al;
var CS;
var Ml;
var RS;
var Dl;
var wS;
var tt;
var gt;
var ra;
var Ro;
var Ol;
var bS;
var Nl;
var kS;
var Vl;
var IS;
var yS = (Tu = class {
  static {
    __name(this, "Tu");
  }
  constructor(s, t, e) {
    g(this, Kr);
    g(this, wl);
    g(this, bl);
    g(this, kl);
    g(this, Vc);
    g(this, Al);
    g(this, Ml);
    g(this, Dl);
    g(this, tt);
    g(this, ra);
    g(this, Ol);
    g(this, Nl);
    g(this, Vl);
    h(this, "context");
    h(this, "authToken");
    h(this, "e2ee");
    g(this, Mc, void 0);
    g(this, Dc, void 0);
    g(this, dt, void 0);
    g(this, G, void 0);
    g(this, Fn, void 0);
    g(this, Ls, void 0);
    g(this, yt, void 0);
    g(this, Xi, void 0);
    g(this, Zi, void 0);
    g(this, ea, void 0);
    g(this, Oc, void 0);
    g(this, ss, null);
    g(this, ur, void 0);
    g(this, Nc, void 0);
    g(this, ta, void 0);
    g(this, sa, void 0);
    g(this, Tt, void 0);
    g(this, kt, void 0);
    var i, n;
    this.context = s;
    const {
      socket: r
    } = e;
    this.mediaJoined = false, m(this, ta, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, sa, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, Ls, t), m(this, dt, r), m(this, Xi, false), m(this, G, new uD(s, r, t)), m(this, yt, a(this, G).events), m(this, ur, /* @__PURE__ */ new Set()), m(this, Tt, /* @__PURE__ */ new Map()), m(this, Zi, false), m(this, ea, new Zu(s.getValue("logger"))), t === we.CF && m(this, kt, new Co(
      this.context,
      a(this, G).socketHandler.audioActivity.bind(a(this, G).socketHandler)
    )), this.e2ee = (n = (i = s.getValue("modules").e2ee) == null ? void 0 : i.enabled) != null ? n : false, this.handleSocketEvents(), this.handleCallstatsEvents(), m(this, Oc, Ih(
      () => u(this, null, function* () {
        if (!a(this, Kr, ka).mediaJoinAttempted)
          return;
        const { roomJoined: o } = yield this.joinRoom(
          a(this, Dc),
          a(this, Mc),
          true,
          true
        );
        o && (this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_RECONNECTED));
      }),
      5e3,
      { leading: true, maxWait: 1e3 }
    ));
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  get mediaJoined() {
    return a(this, Kr, ka).mediaJoined;
  }
  set mediaJoined(s) {
    a(this, Kr, ka).mediaJoined = s;
  }
  reset() {
    a(this, G).closeAllProducers(), a(this, G).closeAllConsumers(), a(this, Tt).clear(), a(this, ur).clear(), m(this, ss, null), a(this, ea).stop(), a(this, G).stopAllTransports(), a(this, G).reset(), m(this, ea, new Zu());
  }
  joinRoom(n, o) {
    return u(this, arguments, function* (s, t, e = false, r = false, i = {}) {
      a(this, Kr, ka).mediaJoinAttempted = true, m(this, Xi, true), e && this.reset();
      try {
        return yield a(this, ea).push(
          () => L(this, wl, TS).call(this, s, t, r, i),
          "joinRoom"
        );
      } catch (c) {
        return this.logger.error("Error in room joining process", { error: c }), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_FAILED), { roomJoined: false };
      }
    });
  }
  initializeConnection(i, n) {
    return u(this, arguments, function* (s, t, e = false, r = {}) {
      return a(this, ss) ? a(this, ss) : (m(this, ss, (() => u(this, null, function* () {
        try {
          yield L(this, Vc, ch).call(this, s, t, e, r);
        } catch (o) {
          throw m(this, ss, null), o;
        }
      }))()), a(this, ss));
    });
  }
  getConsumers() {
    return a(this, G).consumers;
  }
  leaveRoom() {
    return u(this, null, function* () {
      a(this, G).stopAllTransports(), m(this, Zi, false), a(this, Kr, ka).mediaJoinAttempted = false;
      const s = {
        closeRoom: false
      };
      a(this, dt).sendMessagePromise(
        a(this, yt).leaveRoom,
        vR.toBinary(s)
      ).then((e) => {
        var r;
        (r = nw.fromBinary(e.payload)) != null && r.closed && this.logger.warn("Weird state on peer closed and should not happen");
      }).catch((e) => {
        this.logger.error("error on sending leave room request", { error: e });
      }), this.context.getValue("callstats").callEnded(), this.context.getValue("telemetry").destruct();
    });
  }
  activatePeers(s) {
    return u(this, null, function* () {
      return this.createConsumers(s);
    });
  }
  createConsumers(s) {
    return u(this, null, function* () {
      return s.length === 0 ? Promise.resolve() : a(this, G).createConsumers(s);
    });
  }
  closeConsumers(s) {
    return u(this, null, function* () {
      if (!s.length)
        return;
      const t = s.reduce((e, r) => {
        const i = a(this, G).producerIdToConsumerIdMap.get(
          r.producerId
        );
        return i ? (e.push(i), e) : (this.logger.warn(
          `consumer not found in close consumers: ${r.producerId}`
        ), e);
      }, []);
      yield a(this, G).closeConsumers(t);
    });
  }
  _shareWebcam(s, t) {
    return u(this, null, function* () {
      const e = t === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, r = L(this, tt, gt).call(this, e);
      if (r) {
        const p = yield r;
        if (a(this, G).producers.has(p)) {
          const f = a(this, G).producers.get(p);
          if (!f.closed)
            return yield f.replaceTrack({ track: s }), yield this.resumeWebcam(e), s;
          yield this.disableWebcam(t);
        }
        return this._shareWebcam(s, t);
      }
      const i = [t].concat(Nt.filter((p) => p !== t)), n = L(this, Vl, IS).call(this, s, i), o = Gn(this.context, "disableSimulcast"), c = a(this, Ls) === we.CF ? X.ENABLE_CF_SIMULCAST : X.ENABLE_HIVE_SIMULCAST;
      !o && this.context.getValue("flagsmith").hasFeature(c) ? (this.logger.info(`Simulcast enabled for SFU: ${a(this, Ls)}`), n.encodings = r0(this.context, s)) : this.logger.info(`Simulcast disabled for webcam producer, SFU: ${a(this, Ls)}`), this.context.getValue("flagsmith").hasFeature(X.TRACK_HINT) && (n.track.contentHint = this.context.getValue("flagsmith").getValue(
        X.TRACK_HINT
      ));
      const d = /* @__PURE__ */ __name(() => {
        this.logger.info("Disabling video due to the producer closure"), a(this, Tt).delete(e);
      }, "d"), l = a(this, G).createProducer(
        n,
        d
      );
      return L(this, ra, Ro).call(this, e, l.then((p) => p.id)), l.then((p) => p.track);
    });
  }
  shareWebcam(s) {
    return u(this, null, function* () {
      var r;
      if (s === void 0)
        return null;
      const t = (r = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : r.toString();
      if (t)
        return this.logger.debug(`Calling _shareWebcam with forced video codec: ${t}`), this._shareWebcam(s, t);
      const e = Nt.filter((i) => {
        var n, o;
        return ((o = (n = a(this, Fn).sender) == null ? void 0 : n.video) == null ? void 0 : o.codecs.findIndex(
          (c) => c.mimeType === i
        )) >= 0 && a(this, sa).get(i).size > 0;
      });
      return e.length === 0 && e.push(Nt[0]), yield Promise.all(e.map((i) => (this.logger.debug(`Calling _shareWebcam with video codec: ${i}`), this._shareWebcam(s, i)))), s;
    });
  }
  shareScreen(s) {
    return u(this, null, function* () {
      const { video: t, audio: e } = s;
      if (t === void 0)
        return;
      const r = {
        track: t,
        codecOptions: [
          {
            name: "VP8"
          }
        ],
        appData: {
          screenShare: true,
          e2ee: this.e2ee,
          supportsRemoteControl: Te.isElectron()
        },
        stopTracks: false
      }, i = /* @__PURE__ */ __name(() => {
        this.logger.info("Disabling screenShare due to the producer closure"), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
      }, "i"), n = a(this, G).createProducer(
        r,
        i
      );
      L(this, ra, Ro).call(this, pe.SCREENSHARE_VIDEO, n.then((c) => c.id));
      let o;
      if (e) {
        const c = {
          track: e,
          codecOptions: [{ name: "opus" }],
          appData: {
            screenShare: true,
            e2ee: this.e2ee,
            supportsRemoteControl: Te.isElectron()
          },
          stopTracks: false,
          zeroRtpOnPause: a(this, Ls) !== we.CF
        }, d = /* @__PURE__ */ __name(() => {
        }, "d");
        o = a(this, G).createProducer(
          c,
          d
        ), L(this, ra, Ro).call(this, pe.SCREENSHARE_AUDIO, o.then((l) => l.id));
      }
      yield Promise.all([n, o || Promise.resolve()]), this.context.getValue("callstats").screenShareStart();
    });
  }
  shareMic(s) {
    return u(this, null, function* () {
      try {
        if (s === void 0)
          throw new At("track undefined");
        const t = L(this, tt, gt).call(this, pe.MIC);
        if (t) {
          const n = yield t;
          if (a(this, G).producers.has(n)) {
            const o = a(this, G).producers.get(n);
            if (!o.closed) {
              yield o.replaceTrack({ track: s }), yield this.resumeMic(), a(this, kt) && (a(this, kt).audioTrack = s, a(this, kt).producerId = n, a(this, kt).start());
              return;
            }
            yield a(this, G).closeProducer(n, { stopTrack: false });
          }
          yield this.shareMic(s);
          return;
        }
        const e = L(this, Nl, kS).call(this, s), r = /* @__PURE__ */ __name(() => {
          a(this, Tt).delete(pe.MIC);
        }, "r"), i = a(this, G).createProducer(
          e,
          r
        );
        L(this, ra, Ro).call(this, pe.MIC, i.then((n) => n.id)), yield i.then((n) => {
          a(this, kt) && (a(this, kt).audioTrack = n.track, a(this, kt).producerId = n.id, a(this, kt).start());
        });
      } catch (t) {
        throw new R(t);
      }
    });
  }
  pauseMic() {
    return u(this, null, function* () {
      var r;
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("pauseMic::could_not_find_mic_producer");
        return;
      }
      if (t.paused) {
        this.logger.info("pauseMic::mic_producer_already_paused");
        return;
      }
      t.pause(), (r = a(this, kt)) == null || r.stop();
      const e = {
        producerId: t.id,
        pause: true
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  pauseWebcam() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.WEBCAM), t = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP), e = a(this, G).producers.get(s), r = a(this, G).producers.get(t);
      if (!e && !r) {
        this.logger.error("pauseWebcam::could_not_find_webcam_producer");
        return;
      }
      const i = /* @__PURE__ */ __name((n) => {
        const o = {
          producerId: n.id,
          pause: true
        };
        a(this, dt).sendMessage(
          a(this, yt).toggleProducer,
          id.toBinary(o)
        );
      }, "i");
      e && (e.pause(), i(e)), r && (r.pause(), i(r));
    });
  }
  resumeMic() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("resumeMic::could_not_find_mic_producer");
        return;
      }
      if (!t.pause) {
        this.logger.info("resumeMic::mic_producer_already_resumed");
        return;
      }
      t.resume(), t.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, t);
      const e = {
        producerId: t.id,
        pause: false
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  resumeWebcam() {
    return u(this, arguments, function* (s = pe.WEBCAM) {
      const t = yield L(this, tt, gt).call(this, s), e = a(this, G).producers.get(t);
      if (!e) {
        this.logger.error("resumeWebcam::could_not_find_webcam_producer");
        return;
      }
      if (!e.paused) {
        this.logger.info("resumeWebcam::webcam_producer_already_resumed");
        return;
      }
      e.resume(), e.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, e);
      const r = {
        producerId: e.id,
        pause: false
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(r)
      );
    });
  }
  disableWebcam(s) {
    return u(this, null, function* () {
      const t = s === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, e = yield L(this, tt, gt).call(this, t);
      L(this, Ol, bS).call(this, t), e && (yield a(this, G).closeProducer(e));
    });
  }
  disableMic() {
    return u(this, null, function* () {
      var t;
      const s = yield L(this, tt, gt).call(this, pe.MIC);
      s && (yield a(this, G).closeProducer(s)), (t = a(this, kt)) == null || t.stop(), a(this, Tt).delete(pe.MIC);
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.logger.info("screen_sharing_stopped"), this.context.getValue("callstats").screenShareStop();
      const s = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO), t = yield L(this, tt, gt).call(this, pe.SCREENSHARE_AUDIO);
      s && (yield a(this, G).closeProducer(s)), t && (yield a(this, G).closeProducer(t)), a(this, ur).clear(), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
    });
  }
  muteSelf() {
    return u(this, null, function* () {
      this.pauseMic();
    });
  }
  unmuteSelf() {
    return u(this, null, function* () {
    });
  }
  resetVideoProducers(s, t) {
    return u(this, null, function* () {
      if (s) {
        const e = yield L(this, tt, gt).call(this, pe.WEBCAM), r = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP);
        yield a(this, G).closeProducer(e, { stopTrack: false }), yield a(this, G).closeProducer(r, { stopTrack: false }), this.shareWebcam(s);
      }
      if (t) {
        const e = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO);
        yield a(this, G).closeProducer(
          e,
          { stopTrack: false }
        ), this.shareScreen({ video: t });
      }
    });
  }
  changeDisplayName(s, t) {
    return u(this, null, function* () {
      const e = {
        displayName: s,
        participantId: t != null ? t : this.peerId
      };
      if (!(yield a(this, G).socketHandler.changeDisplayName(e)))
        throw new Error("failed to change display name!");
    });
  }
  kick(s) {
    const t = {
      peerIds: [s]
    };
    a(this, G).socketHandler.kickPeer(t);
  }
  kickAll() {
    a(this, G).socketHandler.kickAll();
  }
  muteAll(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("audio")))
        throw new Error("failed to mute all participant");
    });
  }
  muteAllVideo() {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("video")))
        throw new Error("failed to mute all video participant");
    });
  }
  disableAudio(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "audio"
      )))
        throw new Error("failed to mute given participant");
    });
  }
  disableVideo(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "video"
      )))
        throw new Error("failed to mute video of given participant");
    });
  }
  pinPeer(s) {
    return u(this, null, function* () {
      const t = {
        participantId: s != null ? s : ""
      };
      try {
        yield a(this, dt).sendMessagePromise(
          a(this, yt).globalPinPeer,
          DR.toBinary(t)
        );
      } catch (e) {
        this.logger.error("Error in pinning peer:", { error: e });
      }
    });
  }
  validateScreenShare(s) {
    return this.peerId === s.peerId && a(this, G).producers.get(s.producerId) && a(this, ur).add(s.consumerPeerId), a(this, ur).size;
  }
  switchConsumersToLayer(s, t) {
    return u(this, null, function* () {
      const e = s.map((r) => this.getConsumers().get(r));
      a(this, G).switchConsumersToLayer(e, t);
    });
  }
  handleSocketEvents() {
    return u(this, null, function* () {
      a(this, dt).on(
        a(this, yt).peerProducerCreateBroadcast,
        ({ payload: s }) => {
          var t, e;
          if (this.mediaJoined)
            try {
              const { participantId: r, producerState: i } = Lw.fromBinary(s);
              if (r === this.peerId)
                return;
              if (i != null && i.mimeType || (i.mimeType = i.kind === xs.AUDIO ? "audio/opus" : "video/VP8"), i.kind === xs.VIDEO && !i.screenShare && ((e = (t = a(this, Fn).receiver) == null ? void 0 : t.video) == null ? void 0 : e.codecs.findIndex(
                (n) => n.mimeType === Nt[0]
              )) >= 0 && a(this, ta).get(Nt[0]).has(r) && i.mimeType !== Nt[0]) {
                this.logger.warn(`Ignoring producer: ${i.producerId}`);
                return;
              }
              this.logger.info(
                `producer created broadcast: ${r}, producer state: ${i}`
              ), this.context.getValue("peerSessionStore").emit(k.NEW_PRODUCER, {
                peerId: r,
                producer: B(D({}, i), {
                  kind: i.kind === xs.AUDIO ? "audio" : "video",
                  producingPeerId: r
                })
              });
            } catch (r) {
              this.logger.error("error in peer-producer-create-broadcast", {
                error: r
              });
            }
        }
      ), a(this, dt).on(
        a(this, yt).peerProducerToggleBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                initiatorParticipantId: e,
                producerState: { kind: r, pause: i, producerId: n }
              } = Wp.fromBinary(s), o = r === xs.AUDIO ? "audio" : "video";
              if (this.logger.info(
                `producer toggle broadcast: ${t}, producerId: ${n}, kind:${o}, paused:${i} payload: ${JSON.stringify(Wp.fromBinary(s))}`
              ), t === this.peerId && e !== this.peerId && i && this.context.getValue("peerSessionStore").emit(
                o === "audio" ? k.MUTE_SELF : k.MUTE_SELF_VIDEO
              ), t === this.peerId)
                return;
              this.context.getValue("peerSessionStore").emit(k.PRODUCER_TOGGLE, {
                peerId: t,
                producerId: n,
                paused: i,
                kind: o
              }), Array.from(
                this.getConsumers().values()
              ).filter((d) => d.producerId === n).forEach((d) => {
                d.paused !== i && (this.logger.debug(
                  `consumer state mismatched for ${d.id}. updating consumer pause state ${d.paused} to ${i}`
                ), i ? (d.pause(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_PAUSED, {
                  id: d.id
                })) : (d.resume(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_RESUMED, {
                  id: d.id
                })));
              });
            } catch (t) {
              this.logger.error("error in producer toggle broadcast handler", {
                error: t
              });
            }
        }
      ), a(this, dt).on(a(this, yt).peerLeaveBroadcast, ({ payload: s }) => {
        if (this.mediaJoined)
          try {
            const { participantId: t } = Ou.fromBinary(s);
            if (t === this.peerId)
              return;
            this.logger.info(`peer left broadcast:${t}`), a(this, ur).delete(t), a(this, G).consumers.forEach(
              (e) => {
                e.peerId === t && e.close();
              }
            ), this.context.getValue("peerSessionStore").emit(k.PEER_CLOSED, { id: t });
          } catch (t) {
            this.logger.error("error in peer left broadcast", { error: t });
          }
      }), a(this, dt).on(
        a(this, yt).peerProducerCloseBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                producerState: { producerId: e }
              } = $w.fromBinary(s);
              if (t === this.peerId)
                return;
              this.logger.info(`producer closed broadcast:${t}`), this.context.getValue("peerSessionStore").emit(k.PRODUCER_CLOSED, {
                peerId: t,
                producerId: e
              });
              const r = a(this, G).producerIdToConsumerIdMap.get(e);
              if (!r) {
                this.logger.warn(`no consumer found for producer:${e}`);
                return;
              }
              this.logger.info(
                `closing consumer ${r}, producer id: ${e}`
              ), a(this, G).closeConsumer(r).then(() => {
                this.logger.info(`closed consumer: ${r}`), a(this, G).producerIdToConsumerIdMap.delete(e), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, {
                  id: r
                });
              }).catch((i) => {
                this.logger.error("error closing consumer", { error: i });
              });
            } catch (t) {
              this.logger.error("error on producer close broadcast", { error: t });
            }
        }
      ), a(this, dt).on(
        a(this, yt).mediaRoomTerminationBroadcastResponse,
        () => {
          !this.mediaJoined && !a(this, Xi) && !a(this, Zi) || (this.logger.warn(
            "media hub termination broadcast received, rejoining room"
          ), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_DISCONNECTED), a(this, Oc).call(this));
        }
      );
    });
  }
  handleCallstatsEvents() {
    this.context.getValue("callstats").onConsumerScore((s) => {
      s.forEach((t, e) => {
        const r = a(this, G).consumers.get(e);
        r && this.context.getValue("peerSessionStore").emit(k.CONSUMER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          peerId: r.peerId,
          score: t.score,
          scoreStats: t
        });
      });
    }), this.context.getValue("callstats").onProducerScore((s) => {
      s.forEach((t, e) => {
        const r = Array.from(a(this, G).producers.values()).find(
          (i) => i.id === e
        );
        r && this.context.getValue("peerSessionStore").emit(k.PRODUCER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          appData: r.appData,
          score: t.score,
          scoreStats: t
        });
      });
    });
  }
  handlePeerCapabilities(s, t) {
    var e, r, i, n;
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (((r = (e = t == null ? void 0 : t.receiver) == null ? void 0 : e.video) == null ? void 0 : r.codecs.findIndex(
        (d) => d.mimeType === c
      )) >= 0 || o === Nt.length - 1) {
        a(this, sa).get(c).add(s);
        break;
      }
    }
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (((n = (i = t == null ? void 0 : t.sender) == null ? void 0 : i.video) == null ? void 0 : n.codecs.findIndex(
        (d) => d.mimeType === c
      )) >= 0 || o === Nt.length - 1) {
        a(this, ta).get(c).add(s);
        break;
      }
    }
  }
  handlePeerLeaving(s) {
    this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || (a(this, ta).forEach((t) => t.delete(s)), a(this, sa).forEach((t, e) => {
      t.delete(s), !(t.size !== 0 || e === Nt[0]) && this.disableWebcam(e);
    }));
  }
}, Mc = /* @__PURE__ */ new WeakMap(), Dc = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), Ls = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), Xi = /* @__PURE__ */ new WeakMap(), Zi = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), ur = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), Tt = /* @__PURE__ */ new WeakMap(), kt = /* @__PURE__ */ new WeakMap(), Kr = /* @__PURE__ */ new WeakSet(), ka = /* @__PURE__ */ __name(function() {
  return this.context.getValue("connectionHandler");
}, "ka"), wl = /* @__PURE__ */ new WeakSet(), TS = /* @__PURE__ */ __name(function(s, t, e, r) {
  return u(this, null, function* () {
    m(this, Dc, s);
    try {
      return a(this, ss) ? yield a(this, ss) : yield L(this, Vc, ch).call(this, s, t, e, r), L(this, kl, _S).call(this, t), { roomJoined: yield L(this, bl, ES).call(this) };
    } catch (i) {
      return this.logger.error("Failed to complete room join", { error: i }), { roomJoined: false };
    } finally {
      m(this, ss, null);
    }
  });
}, "TS"), bl = /* @__PURE__ */ new WeakSet(), ES = /* @__PURE__ */ __name(function() {
  return u(this, null, function* () {
    try {
      this.mediaJoined = true;
      const { roomState: s } = yield a(this, G).socketHandler.notifySelfJoinComplete();
      return m(this, Mc, s.roomUuid), m(this, Zi, true), m(this, Xi, false), true;
    } catch (s) {
      return this.logger.error("Error completing room join", { error: s }), this.mediaJoined = false, false;
    }
  });
}, "ES"), kl = /* @__PURE__ */ new WeakSet(), _S = /* @__PURE__ */ __name(function(s) {
  navigator.product !== "ReactNative" && setTimeout(() => {
    try {
      const e = {
        userId: this.context.getValue("userId"),
        peerId: this.peerId,
        roomUUID: s,
        roomViewType: "groupCall",
        deviceInfo: B(D({}, Te.getDeviceInfo()), {
          userAgent: "Cloudflare-Workers",
          memory: navigator.deviceMemory,
          cpus: navigator.hardwareConcurrency
        }),
        sdkName: this.context.getValue("sdkName"),
        sdkVersion: this.context.getValue("sdkVersion"),
        metaData: {},
        permissions: {}
      };
      this.context.getValue("callstats").roomJoined(e);
    } catch (t) {
      this.logger.error("Error reporting room joined analytics", { error: t });
    }
  }, 0);
}, "_S"), Vc = /* @__PURE__ */ new WeakSet(), ch = /* @__PURE__ */ __name(function(s, t, e, r) {
  return u(this, null, function* () {
    var i, n;
    try {
      (n = a(this, Nc)) != null || m(this, Nc, L(i = yS, Il, PS).call(i));
      const o = L(this, Al, CS).call(this);
      yield L(this, Ml, RS).call(this, s, t, e, o), yield a(this, G).setupTransports({ send: true, recv: true }), yield L(this, Dl, wS).call(this, r);
    } catch (o) {
      throw this.logger.error("Failed to initialize connection", { error: o }), o;
    }
  });
}, "ch"), Il = /* @__PURE__ */ new WeakSet(), PS = /* @__PURE__ */ __name(function() {
  const { ipInfo: s } = lt();
  if (!(s != null && s.loc))
    return;
  const [t, e] = s.loc.split(",").map(parseFloat);
  return { latitude: t, longitude: e };
}, "PS"), Al = /* @__PURE__ */ new WeakSet(), CS = /* @__PURE__ */ __name(function() {
  var e;
  const s = (e = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : e.toString(), t = Z0(s);
  return m(this, Fn, t), t;
}, "CS"), Ml = /* @__PURE__ */ new WeakSet(), RS = /* @__PURE__ */ __name(function(s, t, e, r) {
  return u(this, null, function* () {
    yield Yf(
      (i, n) => u(this, null, function* () {
        if (!a(this, dt).isConnected) {
          n(new Error("Socket is not connected"));
          return;
        }
        i > 0 && this.logger.warn("Retry: send joinRoom message", {
          debuggingHint: `Retry attempt ${i}`
        });
        try {
          yield a(this, G).socketHandler.joinRoom(
            t,
            s,
            r,
            e,
            a(this, Nc)
          );
        } catch (o) {
          throw this.logger.error("Failed to send joinRoom message after retries", { error: o }), o;
        }
      }),
      {
        delayTime: 1e3,
        strategy: "exponential",
        maxRetryCount: this.context.getValue("flagsmith").hasFeature(X.ENABLE_HIVE_INFINITE_RETRIES) ? 1 / 0 : 3
      }
    );
  });
}, "RS"), Dl = /* @__PURE__ */ new WeakSet(), wS = /* @__PURE__ */ __name(function(s) {
  return u(this, null, function* () {
    if (!(a(this, Ls) === we.HIVE || !this.context.getValue("flagsmith").hasFeature(
      X.PRECREATE_PRODUCERS
    ) || !s))
      try {
        const e = [];
        if (s.canProduceVideo === j.Allowed && e.push(this.shareWebcam(fD(false))), s.canProduceAudio === j.Allowed) {
          const r = mD(false);
          r && e.push(this.shareMic(r));
        }
        e.length > 0 && (yield Promise.all(e));
      } catch (e) {
        this.logger.warn("Failed to precreate producers", { error: e });
      }
  });
}, "wS"), tt = /* @__PURE__ */ new WeakSet(), gt = /* @__PURE__ */ __name(function(s) {
  return a(this, Tt).get(s);
}, "gt"), ra = /* @__PURE__ */ new WeakSet(), Ro = /* @__PURE__ */ __name(function(s, t) {
  return a(this, Tt).set(s, t);
}, "Ro"), Ol = /* @__PURE__ */ new WeakSet(), bS = /* @__PURE__ */ __name(function(s) {
  return a(this, Tt).delete(s);
}, "bS"), Nl = /* @__PURE__ */ new WeakSet(), kS = /* @__PURE__ */ __name(function(s) {
  return {
    track: s,
    encodings: [
      {
        priority: "high"
      }
    ],
    codecOptions: [
      {
        name: "opus"
      }
    ],
    appData: {
      e2ee: this.e2ee
    },
    stopTracks: false,
    zeroRtpOnPause: a(this, Ls) !== we.CF
  };
}, "kS"), Vl = /* @__PURE__ */ new WeakSet(), IS = /* @__PURE__ */ __name(function(s, t) {
  return {
    track: s,
    codecOptions: t ? t.map((e) => ({
      name: e.split("/")[1]
    })) : [{ name: "VP8" }],
    appData: {
      screenShare: false,
      e2ee: this.e2ee
    },
    stopTracks: false
  };
}, "IS"), g(Tu, Il), Tu);
var oe = yS;
le([
  E.trace("MediaNodeClient.reset", { country: E.location.country })
], oe.prototype, "reset", 1);
le([
  E.trace("MediaNodeClient.joinRoom")
], oe.prototype, "joinRoom", 1);
le([
  E.trace("MediaNodeClient.leaveRoom")
], oe.prototype, "leaveRoom", 1);
le([
  E.trace("MediaNodeClient.activatePeers")
], oe.prototype, "activatePeers", 1);
le([
  E.trace("MediaNodeClient.createConsumers")
], oe.prototype, "createConsumers", 1);
le([
  E.trace("MediaNodeClient.closeConsumers")
], oe.prototype, "closeConsumers", 1);
le([
  E.trace("MediaNodeClient._shareWebcam")
], oe.prototype, "_shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareWebcam")
], oe.prototype, "shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareScreen")
], oe.prototype, "shareScreen", 1);
le([
  E.trace("MediaNodeClient.shareMic")
], oe.prototype, "shareMic", 1);
le([
  E.trace("MediaNodeClient.pauseMic")
], oe.prototype, "pauseMic", 1);
le([
  E.trace("MediaNodeClient.pauseWebcam")
], oe.prototype, "pauseWebcam", 1);
le([
  E.trace("MediaNodeClient.resumeMic")
], oe.prototype, "resumeMic", 1);
le([
  E.trace("MediaNodeClient.resumeWebcam")
], oe.prototype, "resumeWebcam", 1);
le([
  E.trace("MediaNodeClient.disableWebcam")
], oe.prototype, "disableWebcam", 1);
le([
  E.trace("HiveClient.disableMic")
], oe.prototype, "disableMic", 1);
le([
  E.trace("HiveClient.disableScreenShare")
], oe.prototype, "disableScreenShare", 1);
le([
  E.trace("MediaNodeClient.muteSelf")
], oe.prototype, "muteSelf", 1);
le([
  E.trace("MediaNodeClient.resetVideoProducers")
], oe.prototype, "resetVideoProducers", 1);
le([
  E.trace("MediaNodeClient.changeDisplayName")
], oe.prototype, "changeDisplayName", 1);
le([
  E.trace("MediaNodeClient.kickPeer")
], oe.prototype, "kick", 1);
le([
  E.trace("MediaNodeClient.kickAllPeers")
], oe.prototype, "kickAll", 1);
le([
  E.trace("MediaNodeClient.muteAll")
], oe.prototype, "muteAll", 1);
le([
  E.trace("MediaNodeClient.muteAllVideo")
], oe.prototype, "muteAllVideo", 1);
le([
  E.trace("MediaNodeClient.disableAudio")
], oe.prototype, "disableAudio", 1);
le([
  E.trace("MediaNodeClient.disableVideo")
], oe.prototype, "disableVideo", 1);
le([
  E.trace("MediaNodeClient.pinPeer")
], oe.prototype, "pinPeer", 1);
le([
  E.trace("MediaNodeClient.validateScreenShare")
], oe.prototype, "validateScreenShare", 1);
function AS(s, t, e) {
  const r = s.getValue("roomNodeClient");
  if (r) {
    if (r)
      return r;
    throw new Error("Room node client already set up.");
  }
  const i = new oe(s, t, e);
  return s.setValue("roomNodeClient", i), i;
}
__name(AS, "AS");
function MS(s) {
  const t = s.getValue("roomNodeClient");
  try {
    t == null || t.leaveRoom();
  } catch (e) {
    s.getValue("logger").error("roomNodeClient::cleanupRoomNodeClient");
  }
  s.setValue("roomNodeClient", void 0);
}
__name(MS, "MS");
var yD = Object.defineProperty;
var TD = Object.getOwnPropertyDescriptor;
var _a = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yD(t, e, i), i;
}, "_a");
var ia;
var Ss;
var te;
var Et;
var Lt;
var qg;
var DS = (qg = class {
  static {
    __name(this, "qg");
  }
  constructor(s, t, e, r) {
    g(this, Et);
    h(this, "self");
    h(this, "authToken");
    g(this, ia, void 0);
    h(this, "viewType");
    g(this, Ss, void 0);
    g(this, te, void 0);
    const { socket: i } = e, n = s.getValue("authToken");
    this.self = t, m(this, te, s), this.viewType = r, this.authToken = n, m(this, ia, i), m(this, Ss, e), t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  get peerId() {
    return a(this, te).getValue("peerId");
  }
  get telemetry() {
    return a(this, te).getValue("telemetry");
  }
  get logger() {
    return a(this, te).getValue("logger");
  }
  get mediaJoined() {
    return a(this, te).getValue("connectionHandler").mediaJoined;
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = lt(), o = s.getValue("peerId"), c = !!s.getValue("cachedUserDetails"), d = yield Xe.__init__(
        s,
        e,
        r,
        i,
        i.name,
        c
      );
      s.setValue("self", d);
      const l = s.getValue("logger");
      if (navigator.product !== "ReactNative") {
        const p = !s.getValue("flagsmith").hasFeature(X.PRECALL_BANDWIDTH_TEST);
        setTimeout(() => u(this, null, function* () {
          const f = yield d.getAllDevices();
          l.info("populated_full_device_list", {
            devices: JSON.stringify(f)
          }), s.getValue("callstats").devices("AUDIO", f == null ? void 0 : f.filter((S) => S.kind === "audioinput")), s.getValue("callstats").devices("VIDEO", f == null ? void 0 : f.filter((S) => S.kind === "videoinput")), s.getValue("callstats").devices("SPEAKER", f == null ? void 0 : f.filter((S) => S.kind === "audiooutput")), l.info("Callstats:: initializing");
          try {
            yield s.getValue("callstats").initialize({
              peerId: o,
              engineName: Te.getDeviceInfo().engineName,
              env: s.getValue("env"),
              iceServers: yield n.getICEServers(),
              apiBase: s.getValue("apiBase"),
              flags: s.getValue("flagsmith").getAllFlags(),
              logger: l,
              apiHostnames: cf(s),
              skipConnectivityChecks: p
            }), l.info("Callstats:: initialized");
          } catch (S) {
            l.error("Callstats:: initialization failed", { error: S });
          }
        }), 0);
      } else
        l.info("Callstats:: Skipped initialization due to navigator product being ReactNative.");
      return new DS(s, d, t, i.viewType);
    });
  }
  shareMediaTracks() {
    return u(this, null, function* () {
      var c;
      const {
        audioTrack: s,
        videoTrack: t,
        permissions: e,
        audioEnabled: r,
        videoEnabled: i,
        screenShareEnabled: n,
        screenShareTracks: o
      } = this.self;
      if (e.canProduceAudio === j.Allowed && r)
        try {
          yield a(this, Et, Lt).shareMic(s), this.self.audioEnabled || a(this, Et, Lt).pauseMic();
        } catch (d) {
          this.self.disableAudio();
        }
      if (e.canProduceVideo === j.Allowed && i)
        try {
          const d = yield a(this, Et, Lt).shareWebcam(t);
          d && d.id !== t.id && a(this, te).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, Et, Lt).shareWebcam(d)), this.self.videoEnabled || a(this, Et, Lt).pauseWebcam();
        } catch (d) {
          this.self.disableVideo();
        }
      if (e.canProduceScreenshare === j.Allowed && n)
        try {
          yield (c = a(this, Et, Lt)) == null ? void 0 : c.shareScreen({
            video: o.video,
            audio: o.audio
          });
        } catch (d) {
          this.self.disableScreenShare();
        }
    });
  }
  kickHandler(s) {
    return u(this, null, function* () {
      let t = "kicked";
      (s == null ? void 0 : s.kickType) === "kickAll" && (t = "ended"), this.leaveRoom(t);
    });
  }
  waitlistedHandler() {
    this.logger.info("SelController.waitlisted"), this.self.waitlistStatus = "waiting", this.self.roomState = "waitlisted", this.self.emit("waitlisted");
  }
  waitlistAcceptHandler() {
    if (this.logger.info("SelController.waitlistAccepted"), this.self.waitlistStatus === "accepted") {
      this.logger.warn("SelfController.WAITLIST_ACCEPTED.UserAlreadyAccepted");
      return;
    }
    this.self.waitlistStatus = "accepted", this.joinRoom();
  }
  waitlistRejectedHandler() {
    if (this.logger.info("SelfController.waitlistRejected"), this.self.waitlistStatus === "rejected") {
      this.logger.warn("SelfController.WAITLIST_REJECTED.UserAlreadyRejected");
      return;
    }
    this.self.waitlistStatus = "rejected", this.leaveRoom("rejected");
  }
  resetSelf(s) {
    return u(this, null, function* () {
      a(this, te).getValue("callstats").callEnded(), a(this, Et, Lt).reset(), s && (yield this.joinRoom(s));
    });
  }
  setupEvents() {
    a(this, te).getValue("peerSessionStore").on(k.RESET_PRODUCER_STATE, () => u(this, null, function* () {
      this.mediaJoined && this.shareMediaTracks();
    })), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_RECONNECTED, () => {
      this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: true });
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_DISCONNECTED, () => {
      this.self.roomState !== "disconnected" && (this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" }));
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_RECONNECTED, ({ wasJoinAttempted: s }) => {
      s === false && (this.self.roomState = "init"), this.resetSelf(s);
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, ({ joinAttempted: s }) => {
      if (this.self.roomState === "disconnected")
        return;
      let { peerId: t } = this;
      s && a(this, te).getValue("flagsmith").hasFeature(X.REFRESH_ID_ON_DISCONNECTION) && (t = v4()), a(this, ia).updateURL(t), a(this, te).getValue("telemetry").resetPeerId(t), lt().setHeader("dyte-tracing-id", t), mr.remapContext(t, a(this, te)), this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, Ss).on(x.waitingRoomRequestAccepted, () => {
      this.waitlistAcceptHandler();
    }), a(this, Ss).on(fd.updateUserPreset, (s) => {
      s.updatePeersPresets.forEach((t) => {
        t.userIds === this.self.userId && a(this, te).getValue("peerSessionStore").emit(k.UPDATE_PERMISSIONS, t.patch);
      });
    }), a(this, Ss).on(x.waitingRoomRequestDenied, () => {
      this.waitlistRejectedHandler();
    }), a(this, Ss).on(x.kick, () => {
      this.kickHandler({ kickType: "kick" });
    }), a(this, Ss).on(x.kickAll, () => {
      this.kickHandler({ kickType: "kickAll" });
    }), a(this, te).getValue("peerSessionStore").onAsync(k.JOIN_MEDIA_ROOM, this.joinMediaRoom.bind(this)), a(this, te).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        scoreStats: r
      }) => {
        var n;
        const i = (n = e == null ? void 0 : e.screenShare) != null ? n : false;
        this.self.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: i,
          score: s,
          participantId: this.self.id,
          scoreStats: r
        });
      }
    ), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF, () => u(this, null, function* () {
      this.self.audioEnabled && (yield this.self.disableAudio(), a(this, te).getValue("callstats").audioOff());
    })), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF_VIDEO, () => u(this, null, function* () {
      this.self.videoEnabled && (yield this.self.disableVideo(), a(this, te).getValue("callstats").videoOff());
    })), a(this, te).getValue("peerSessionStore").onAsync(
      k.LEAVE_MEDIA_ROOM,
      this.leaveMediaRoom.bind(this)
    ), a(this, te).getValue("peerSessionStore").on(
      k.PIP_HANGUP,
      this.leaveRoom.bind(this)
    );
  }
  joinRoom(s = false) {
    return u(this, null, function* () {
      try {
        const { peer: t } = yield a(this, Ss).joinRoom(
          this.self
        );
        a(this, Ss).socket.flush();
        const e = Nh(t.stageType);
        if (a(this, te).setValue("stageStatus", e, false), t.waitlisted) {
          this.waitlistedHandler();
          return;
        }
        yield this.joinMediaRoom(s), a(this, te).notify("stageStatus");
      } catch (t) {
        throw this.logger.error("Error in joinRoom", { error: t }), t;
      }
    });
  }
  leaveRoom(s = "left") {
    return u(this, null, function* () {
      var t, e;
      if (this.logger.info(`Leaving room with state: ${s}`), (t = a(this, te).getValue("roomSocketHandler")) == null || t.cleanup(), s === "rejected") {
        this.self.roomState = s, this.self.emit("roomLeft", { state: s });
        return;
      }
      this.self.setIsPinned(false), a(this, te).setValue("stageStatus", "OFF_STAGE", false), yield this.leaveMediaRoom(s), a(this, te).notify("stageStatus");
      try {
        (e = a(this, ia)) == null || e.disconnect();
      } catch (r) {
        this.logger.error("SelfController::leaveRoom::socketDisconnect");
      }
      MS(a(this, te)), this.self.roomState = s, this.self.emit("roomLeft", { state: s }), this.logger.info(`roomLeft event emitted with state: ${s}`);
    });
  }
  joinMediaRoom(s = false) {
    return u(this, null, function* () {
      var c, d;
      const {
        peerId: t,
        viewType: e,
        meetingId: r,
        stageStatus: i,
        roomNodeOptions: n
      } = a(this, te).getAllValues(), { sfu: o } = n;
      try {
        if (e === Mt.Livestream) {
          if (i !== "ON_STAGE") {
            this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
            return;
          }
          AS(a(this, te), o, {
            socket: a(this, ia),
            peerId: t
          });
        }
        const { canProduceAudio: l, canProduceVideo: p, canProduceScreenshare: f } = this.self.permissions, { roomJoined: S } = (d = yield (c = a(this, Et, Lt)) == null ? void 0 : c.joinRoom(
          this.self.name,
          r,
          s,
          s,
          {
            canProduceAudio: l,
            canProduceVideo: p,
            canProduceScreenshare: f
          }
        )) != null ? d : {};
        if (!S)
          return;
        i === "ON_STAGE" && (yield this.shareMediaTracks()), this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
      } catch (l) {
        throw this.logger.error("Error:SelfController.mediaRoomJoin", { error: l }), new R("Error: could not join media room", "0002");
      }
    });
  }
  leaveMediaRoom(s) {
    return u(this, null, function* () {
      const t = a(this, te).getValue("viewType");
      s !== "connected-meeting" && (yield this.cleanupSelf()), !(s === "stageLeft" && t === Mt.Webinar) && a(this, Et, Lt) && (a(this, Et, Lt).mediaJoined && s !== "disconnected" && (yield a(this, Et, Lt).leaveRoom()), !(s === "stageLeft" && t === Mt.Livestream) && (a(this, Et, Lt).mediaJoined = false));
    });
  }
  cleanupSelf() {
    return u(this, null, function* () {
      yield this.self.disableAudio(), yield this.self.disableVideo(), yield this.self.disableScreenShare(), this.self.cleanUpTracks(), this.self.destructMediaHandler(), navigator.isReactNative || this.self.removeDocumentEventListeners();
    });
  }
}, ia = /* @__PURE__ */ new WeakMap(), Ss = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap(), Et = /* @__PURE__ */ new WeakSet(), Lt = /* @__PURE__ */ __name(function() {
  return a(this, te).getValue("roomNodeClient");
}, "Lt"), qg);
var ai = DS;
_a([
  E.trace("SelfController.resetSelf")
], ai.prototype, "resetSelf", 1);
_a([
  E.trace("SelfController.setupEvents")
], ai.prototype, "setupEvents", 1);
_a([
  E.trace("SelfController.joinRoom")
], ai.prototype, "joinRoom", 1);
_a([
  E.trace("SelfController.leaveRoom")
], ai.prototype, "leaveRoom", 1);
_a([
  E.trace("SelfController.joinMediaRoom")
], ai.prototype, "joinMediaRoom", 1);
_a([
  E.trace("SelfController.leaveMediaRoom")
], ai.prototype, "leaveMediaRoom", 1);
_a([
  E.trace("SelfController.init")
], ai, "init", 1);
var Lc;
var ED = class {
  static {
    __name(this, "ED");
  }
  constructor(t) {
    g(this, Lc, void 0);
    m(this, Lc, t);
  }
  on(t, e) {
    let r;
    t === x.roomPeerCount ? r = zp.fromBinary.bind(zp) : r = ng.fromBinary.bind(ng), a(this, Lc).on(t, ({ payload: i }) => {
      if (t === x.roomPeerCount && !i)
        return;
      const n = r(i);
      e(n);
    });
  }
};
Lc = /* @__PURE__ */ new WeakMap();
var xc;
var Uc;
var _D = class {
  static {
    __name(this, "_D");
  }
  constructor(t, e) {
    g(this, xc, void 0);
    g(this, Uc, void 0);
    m(this, xc, e), m(this, Uc, t);
  }
  get logger() {
    return a(this, Uc).getValue("logger");
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.transcript: {
        r = lu.fromBinary.bind(
          lu
        ), i = lu.create();
        break;
      }
      default: {
        this.logger.debug("AISocketHandler switch case hit default, event not accounted for.");
        break;
      }
    }
    a(this, xc).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
};
xc = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap();
var PD = Object.defineProperty;
var CD = Object.getOwnPropertyDescriptor;
var Wh = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? CD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && PD(t, e, i), i;
}, "Wh");
var hr;
var Hn;
var Ql = class {
  static {
    __name(this, "Ql");
  }
  constructor(t, e) {
    g(this, hr, void 0);
    g(this, Hn, void 0);
    m(this, hr, e), m(this, Hn, t);
  }
  get logger() {
    return a(this, Hn).getValue("logger");
  }
  get telemetry() {
    return a(this, Hn).getValue("telemetry");
  }
  getPolls() {
    return a(this, hr).sendMessagePromise(qs.getPolls);
  }
  createPoll(t, e, r = false, i = false) {
    const n = {
      anonymous: r,
      hideVotes: i,
      question: t,
      options: e
    };
    return a(this, hr).sendMessage(
      qs.createPoll,
      bA.toBinary(n)
    );
  }
  votePoll(t, e) {
    const r = {
      index: e,
      pollId: t
    };
    return a(this, hr).sendMessage(
      qs.votePoll,
      IA.toBinary(r)
    );
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case qs.updatePoll:
      case qs.createPoll:
      case qs.votePoll: {
        r = fu.fromBinary.bind(fu), i = fu.create();
        break;
      }
    }
    a(this, hr).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("pollSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  removeListeners(t) {
    a(this, hr).removeListeners(t);
  }
};
hr = /* @__PURE__ */ new WeakMap(), Hn = /* @__PURE__ */ new WeakMap();
Wh([
  E.trace("PollSocketHandler.getPolls")
], Ql.prototype, "getPolls", 1);
Wh([
  E.trace("PollSocketHandler.createPoll")
], Ql.prototype, "createPoll", 1);
Wh([
  E.trace("PollSocketHandler.votePoll")
], Ql.prototype, "votePoll", 1);
var RD = Object.defineProperty;
var wD = Object.getOwnPropertyDescriptor;
var bD = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? wD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && RD(t, e, i), i;
}, "bD");
var Ht;
var OS = class {
  static {
    __name(this, "OS");
  }
  constructor(t, e) {
    h(this, "socket");
    g(this, Ht, void 0);
    m(this, Ht, t), this.socket = e, this.handleSocketEvents(), a(this, Ht).setValue("roomSocketHandler", this);
  }
  get telemetry() {
    return a(this, Ht).getValue("telemetry");
  }
  get logger() {
    return a(this, Ht).getValue("logger");
  }
  cleanup() {
    var t;
    try {
      (t = this.socket) == null || t.disconnect();
    } catch (e) {
      this.logger.error("roomSocketHandler::cleanup");
    }
  }
  joinRoom(t) {
    return u(this, null, function* () {
      var i;
      this.socket.joinAttempted = true;
      const e = {
        capabilities: [],
        peer: {
          displayName: (i = t.name) != null ? i : "Participant",
          customParticipantId: t.customParticipantId,
          peerId: t.id,
          userId: t.userId,
          displayPictureUrl: t.picture,
          waitlisted: false
        },
        roomUuid: ""
      }, r = this.socket.sendMessagePromise(
        x.joinRoom,
        gb.toBinary(e)
      );
      try {
        const { peer: n } = Ca.fromBinary((yield r).payload);
        a(this, Ht).getValue("connectionHandler").socketJoined = true, a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_ROOM_JOINED, { peer: n });
        const o = this.getRoomState(), c = this.getRoomPeersNonPaginated(), [{ room: d }, { peers: l }] = yield Promise.all([o, c]);
        return a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_STATE, d), a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_PEERS, l), { peer: n };
      } catch (n) {
        throw this.logger.error("RoomSocketHandler.joinRoom.failed", {
          error: n
        }), new R(
          "Error: RoomSocketHandler.joinRoom failed.",
          "0002",
          this.logger,
          n
        );
      }
    });
  }
  getAllAddedParticipants() {
    return u(this, null, function* () {
      try {
        return Xb.fromBinary(
          (yield this.socket.sendMessagePromise(x.getAllAddedParticipants)).payload
        ).participants.map(
          (i) => {
            var n = i, { id: e } = n, r = ho(n, ["id"]);
            return B(D({}, r), { userId: e });
          }
        );
      } catch (t) {
        return [];
      }
    });
  }
  getRoomPeers(t, e, r) {
    return u(this, null, function* () {
      let i;
      try {
        const n = {
          seachQuery: t,
          limit: e,
          offset: r
        }, o = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo,
          ib.toBinary(n)
        );
        i = uu.fromBinary(o.payload);
      } catch (n) {
        this.logger.error("getRoomPeers::binary_decode_error", { error: n });
      }
      return i;
    });
  }
  getRoomPeersNonPaginated() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getStagePeers() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      let e;
      try {
        const r = yield this.socket.sendMessagePromise(
          x.getPeerInfo,
          Sf.toBinary({ peerId: t })
        );
        e = Ca.fromBinary(r.payload);
      } catch (r) {
        this.logger.error("getPeerInfo::binary_decode_error", { error: r });
      }
      return e;
    });
  }
  getRoomState() {
    return u(this, null, function* () {
      let t = Yp.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomInfo);
        t = Yp.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getRoomStageState() {
    return u(this, null, function* () {
      let t = eg.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomStageState);
        t = eg.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomStageState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  broadcastMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(e)),
        timestamp: Date.now(),
        ids: []
      };
      return this.socket.sendMessagePromise(
        x.broadcastMessage,
        fo.toBinary(r)
      );
    });
  }
  broadcastToMeetings(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        broadcastType: 1
      };
      return this.socket.sendMessagePromise(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  broadcastToPeers(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        broadcastType: 0
      };
      return this.socket.sendMessage(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  leaveRoom() {
    return u(this, null, function* () {
      this.socket.joinAttempted = false, this.socket.sendMessagePromise(
        x.leaveRoom,
        fb.toBinary({})
      );
    });
  }
  kick(t) {
    return u(this, null, function* () {
      const e = {
        peerIds: [t]
      };
      this.socket.sendMessage(
        x.kick,
        yf.toBinary(e)
      );
    });
  }
  kickAll(t = false) {
    return u(this, null, function* () {
      const e = {
        propagateKickAcrossRooms: t
      };
      this.socket.sendMessage(
        x.kickAll,
        gf.toBinary(e)
      );
    });
  }
  getWaitingRoomRequests() {
    this.socket.sendMessage(x.getWaitingRoomRequests);
  }
  acceptWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.acceptWaitingRoomRequests,
      ik.toBinary(e)
    );
  }
  rejectWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.denyWaitingRoomRequests,
      nk.toBinary(e)
    );
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = {
        updatePeersPresets: []
      };
      return t.forEach((i) => {
        r.updatePeersPresets.push({
          userIds: i,
          patch: e
        });
      }), this.socket.sendMessagePromise(
        fd.updateUserPreset,
        Vk.toBinary(r)
      );
    });
  }
  handleSocketEvents() {
    this.socket.on(x.broadcastMessage, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode broadcast message:", e);
      }
    }), this.socket.on(x.broadcastToEntity, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode peer broadcast message:", e);
      }
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.joinRoom:
      case x.leaveRoom:
      case x.kick:
      case x.kickAll: {
        r = Ca.fromBinary.bind(Ca), i = Ca.create();
        break;
      }
      case x.getWaitingRoomRequests: {
        r = /* @__PURE__ */ __name((n, o) => n ? Zp.fromBinary(n, o) : { requests: [] }, "r"), i = Zp.create();
        break;
      }
      case x.recordingPaused:
      case x.recordingStarted:
      case x.recordingStopped: {
        r = dg.fromBinary.bind(dg);
        break;
      }
      case fd.updateUserPreset: {
        r = tg.fromBinary.bind(tg);
        break;
      }
      case Ts.peerJoinedBroadcast:
      case is.peerJoinedBroadcast: {
        r = jp.fromBinary.bind(jp);
        break;
      }
      case Ts.selfJoinComplete:
      case is.selfJoinComplete: {
        r = Du.fromBinary.bind(Du);
        break;
      }
      case Ts.globalPeerPinBroadcast:
      case is.globalPeerPinBroadcast: {
        r = Jp.fromBinary.bind(Jp);
        break;
      }
      case Ts.selectedPeer:
      case is.selectedPeer: {
        r = Mu.fromBinary.bind(Mu);
        break;
      }
      case Ts.selectedPeerDiff:
      case is.selectedPeerDiff: {
        r = qp.fromBinary.bind(qp);
        break;
      }
      case Ts.leaveRoom:
      case is.leaveRoom: {
        r = Ou.fromBinary.bind(Ou);
        break;
      }
    }
    this.socket.on(t, ({ payload: n }) => {
      let o = i;
      if (!r)
        return e(void 0);
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("roomSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  getUserPermissions(t) {
    return u(this, null, function* () {
      const e = {
        userIds: [t]
      };
      try {
        const r = yield this.socket.sendMessagePromise(
          fd.getUserPresets,
          kk.toBinary(e)
        ), i = Dk.fromBinary(r.payload).peerPresets[0], n = new TextDecoder().decode(i.preset), o = JSON.parse(n).permissions;
        return { chat: o.chat, polls: o.polls, plugins: o.plugins };
      } catch (r) {
        throw this.logger.error("Error in getting user preset", { error: r }), r;
      }
    });
  }
};
Ht = /* @__PURE__ */ new WeakMap();
bD([
  E.trace("RoomSocketHandler.joinRoom")
], OS.prototype, "joinRoom", 1);
var It;
var kD = class {
  static {
    __name(this, "kD");
  }
  constructor(t) {
    g(this, It, void 0);
    m(this, It, t);
  }
  getStageRequests() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, It).sendMessagePromise(
        x.getStageRequests
      );
      return t ? mu.fromBinary(t) : { stageRequests: [] };
    });
  }
  requestAccess() {
    a(this, It).sendMessage(x.requestStageAccess);
  }
  cancelRequestAccess() {
    a(this, It).sendMessage(x.cancelStageRequest);
  }
  grantAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.grantStageAccess,
        SA.toBinary(e)
      );
    });
  }
  denyAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.denyStageAccess,
        yA.toBinary(e)
      );
    });
  }
  joinStage() {
    return a(this, It).sendMessagePromise(
      x.joinStage,
      void 0,
      void 0,
      x.peerStageStatusUpdate
    );
  }
  leaveStage(t) {
    const e = {
      userIds: [t]
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e),
      void 0,
      x.peerStageStatusUpdate
    );
  }
  kick(t) {
    const e = {
      userIds: t
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case x.grantStageAccess:
      case x.denyStageAccess: {
        r = void 0;
        break;
      }
      case x.getStagePeers: {
        r = og.fromBinary.bind(
          og
        );
        break;
      }
      case x.getStageRequests:
      case x.requestStageAccess:
      case x.cancelStageRequest: {
        r = mu.fromBinary.bind(
          mu
        );
        break;
      }
      case x.peerStageStatusUpdate: {
        r = Kp.fromBinary.bind(Kp);
        break;
      }
    }
    a(this, It).on(t, ({ payload: i, id: n }) => {
      if (!i || !r)
        return e(void 0, n);
      const o = r(i);
      return e(o, n);
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      const e = yield a(this, It).sendMessagePromise(
        x.getPeerInfo,
        Sf.toBinary({ peerId: t })
      );
      return Ca.fromBinary(e.payload);
    });
  }
};
It = /* @__PURE__ */ new WeakMap();
var Ge;
var $c;
var ID = class {
  static {
    __name(this, "ID");
  }
  constructor(t, e) {
    g(this, Ge, void 0);
    g(this, $c, void 0);
    m(this, Ge, e), m(this, $c, t);
  }
  get logger() {
    return a(this, $c).getValue("logger");
  }
  addPlugin(t, e) {
    a(this, Ge).sendMessage(
      W.addPlugin,
      NI.toBinary({ pluginId: t, staggered: e })
    );
  }
  removePlugin(t) {
    a(this, Ge).sendMessage(
      W.removePlugin,
      LI.toBinary({ pluginId: t, staggered: false })
    );
  }
  getActivePlugins() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, Ge).sendMessagePromise(
        W.getPlugins
      );
      return t ? aA.fromBinary(t) : { plugins: [] };
    });
  }
  customPluginEventToRoom(t, e, r) {
    const i = {
      pluginId: t,
      pluginData: new TextEncoder().encode(JSON.stringify(e))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToRoom,
      WI.toBinary(i),
      r
    );
  }
  customPluginEventToPeers(t, e, r, i) {
    const n = {
      pluginId: t,
      peerIds: e,
      pluginData: new TextEncoder().encode(JSON.stringify(r))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToPeers,
      KI.toBinary(n),
      i
    );
  }
  enablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.enablePluginForRoom,
      UI.toBinary({ pluginId: t }),
      e
    );
  }
  enablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.enablePluginForPeers,
      BI.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  disablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.disablePluginForRoom,
      FI.toBinary({ pluginId: t }),
      e
    );
  }
  disablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.disablePluginForPeers,
      jI.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  storeInsertKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      insertKeys: r.map((o) => ({
        storeKey: o.key,
        payload: new TextEncoder().encode(JSON.stringify(o.payload))
      }))
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(n),
      i
    );
  }
  storeGetKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      getKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeGetKeys,
      XI.toBinary(n),
      i
    );
  }
  storeDeleteKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      deleteKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeDeleteKeys,
      eA.toBinary(n),
      i
    );
  }
  storeDelete(t, e, r) {
    a(this, Ge).sendMessage(
      W.storeDelete,
      sA.toBinary({ pluginId: t, storeName: e }),
      r
    );
  }
  getPluginDataOld(t, e) {
    this.logger.info("getPluginDataOld", {
      plugin: { id: t, storeName: e }
    });
  }
  storePluginDataOld(t, e, r) {
    const i = {
      pluginId: t,
      storeName: e,
      insertKeys: [
        {
          storeKey: r.key,
          payload: new TextEncoder().encode(JSON.stringify(r))
        }
      ]
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(i)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case W.addPlugin:
      case W.enablePluginForPeers:
      case W.enablePluginForRoom: {
        r = xu.fromBinary.bind(xu);
        break;
      }
      case W.removePlugin:
      case W.disablePluginForPeers:
      case W.disablePluginForRoom: {
        r = rg.fromBinary.bind(
          rg
        );
        break;
      }
      case W.customPluginEventToPeers:
      case W.customPluginEventToRoom: {
        r = ag.fromBinary.bind(ag);
        break;
      }
      case W.storeInsertKeys:
      case W.storeGetKeys:
      case W.storeDeleteKeys:
      case W.storeDelete: {
        r = ig.fromBinary.bind(ig);
        break;
      }
    }
    a(this, Ge).on(t, ({ payload: i, id: n }) => {
      const o = r(i);
      return e(o, n);
    });
  }
};
Ge = /* @__PURE__ */ new WeakMap(), $c = /* @__PURE__ */ new WeakMap();
var AD = Object.defineProperty;
var MD = /* @__PURE__ */ __name((s, t, e) => t in s ? AD(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e, "MD");
var DD = /* @__PURE__ */ __name((s, t, e) => (MD(s, typeof t != "symbol" ? t + "" : t, e), e), "DD");
var Jh = /* @__PURE__ */ __name((s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
}, "Jh");
var M = /* @__PURE__ */ __name((s, t, e) => (Jh(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "M");
var Se = /* @__PURE__ */ __name((s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, "Se");
var ne = /* @__PURE__ */ __name((s, t, e, r) => (Jh(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e), "ne");
var _e = /* @__PURE__ */ __name((s, t, e) => (Jh(s, t, "access private method"), e), "_e");
var $d = {};
var OD = {
  get exports() {
    return $d;
  },
  set exports(s) {
    $d = s;
  }
};
var Ua = typeof Reflect == "object" ? Reflect : null;
var Tg = Ua && typeof Ua.apply == "function" ? Ua.apply : function(s, t, e) {
  return Function.prototype.apply.call(s, t, e);
};
var Pd;
Ua && typeof Ua.ownKeys == "function" ? Pd = Ua.ownKeys : Object.getOwnPropertySymbols ? Pd = /* @__PURE__ */ __name(function(s) {
  return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s));
}, "Pd") : Pd = /* @__PURE__ */ __name(function(s) {
  return Object.getOwnPropertyNames(s);
}, "Pd");
function ND(s) {
  console && console.warn && console.warn(s);
}
__name(ND, "ND");
var NS = Number.isNaN || function(s) {
  return s !== s;
};
function de() {
  de.init.call(this);
}
__name(de, "de");
OD.exports = de;
$d.once = UD;
de.EventEmitter = de;
de.prototype._events = void 0;
de.prototype._eventsCount = 0;
de.prototype._maxListeners = void 0;
var Eg = 10;
function Xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
__name(Xl, "Xl");
Object.defineProperty(de, "defaultMaxListeners", {
  enumerable: true,
  get: /* @__PURE__ */ __name(function() {
    return Eg;
  }, "get"),
  set: /* @__PURE__ */ __name(function(s) {
    if (typeof s != "number" || s < 0 || NS(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    Eg = s;
  }, "set")
});
de.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
de.prototype.setMaxListeners = function(s) {
  if (typeof s != "number" || s < 0 || NS(s))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + s + ".");
  return this._maxListeners = s, this;
};
function VS(s) {
  return s._maxListeners === void 0 ? de.defaultMaxListeners : s._maxListeners;
}
__name(VS, "VS");
de.prototype.getMaxListeners = function() {
  return VS(this);
};
de.prototype.emit = function(s) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t.push(arguments[e]);
  var r = s === "error", i = this._events;
  if (i !== void 0)
    r = r && i.error === void 0;
  else if (!r)
    return false;
  if (r) {
    var n;
    if (t.length > 0 && (n = t[0]), n instanceof Error)
      throw n;
    var o = new Error("Unhandled error." + (n ? " (" + n.message + ")" : ""));
    throw o.context = n, o;
  }
  var c = i[s];
  if (c === void 0)
    return false;
  if (typeof c == "function")
    Tg(c, this, t);
  else
    for (var d = c.length, l = FS(c, d), e = 0; e < d; ++e)
      Tg(l[e], this, t);
  return true;
};
function LS(s, t, e, r) {
  var i, n, o;
  if (Xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = VS(s), i > 0 && o.length > i && !o.warned) {
    o.warned = true;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, ND(c);
  }
  return s;
}
__name(LS, "LS");
de.prototype.addListener = function(s, t) {
  return LS(this, s, t, false);
};
de.prototype.on = de.prototype.addListener;
de.prototype.prependListener = function(s, t) {
  return LS(this, s, t, true);
};
function VD() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
__name(VD, "VD");
function xS(s, t, e) {
  var r = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i = VD.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
__name(xS, "xS");
de.prototype.once = function(s, t) {
  return Xl(t), this.on(s, xS(this, s, t)), this;
};
de.prototype.prependOnceListener = function(s, t) {
  return Xl(t), this.prependListener(s, xS(this, s, t)), this;
};
de.prototype.removeListener = function(s, t) {
  var e, r, i, n, o;
  if (Xl(t), r = this._events, r === void 0)
    return this;
  if (e = r[s], e === void 0)
    return this;
  if (e === t || e.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[s], r.removeListener && this.emit("removeListener", s, e.listener || t));
  else if (typeof e != "function") {
    for (i = -1, n = e.length - 1; n >= 0; n--)
      if (e[n] === t || e[n].listener === t) {
        o = e[n].listener, i = n;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? e.shift() : LD(e, i), e.length === 1 && (r[s] = e[0]), r.removeListener !== void 0 && this.emit("removeListener", s, o || t);
  }
  return this;
};
de.prototype.off = de.prototype.removeListener;
de.prototype.removeAllListeners = function(s) {
  var t, e, r;
  if (e = this._events, e === void 0)
    return this;
  if (e.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : e[s] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete e[s]), this;
  if (arguments.length === 0) {
    var i = Object.keys(e), n;
    for (r = 0; r < i.length; ++r)
      n = i[r], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = e[s], typeof t == "function")
    this.removeListener(s, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(s, t[r]);
  return this;
};
function US(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? xD(i) : FS(i, i.length);
}
__name(US, "US");
de.prototype.listeners = function(s) {
  return US(this, s, true);
};
de.prototype.rawListeners = function(s) {
  return US(this, s, false);
};
de.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : $S.call(s, t);
};
de.prototype.listenerCount = $S;
function $S(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
__name($S, "$S");
de.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Pd(this._events) : [];
};
function FS(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
__name(FS, "FS");
function LD(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
__name(LD, "LD");
function xD(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
__name(xD, "xD");
function UD(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    __name(i, "i");
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    __name(n, "n");
    HS(s, t, n, { once: true }), t !== "error" && $D(s, i, { once: true });
  });
}
__name(UD, "UD");
function $D(s, t, e) {
  typeof s.on == "function" && HS(s, "error", t, e);
}
__name($D, "$D");
function HS(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, /* @__PURE__ */ __name(function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    }, "i"));
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
__name(HS, "HS");
var FD = class extends MessageType {
  static {
    __name(this, "FD");
  }
  constructor() {
    super("message.v1.SocketMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 13
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 4,
        name: "metadata",
        kind: "scalar",
        opt: true,
        T: 12
      }
    ]);
  }
};
var _g = new FD();
var BS = class {
  static {
    __name(this, "BS");
  }
  static encode(t) {
    return _g.toBinary(t);
  }
  static decode(t) {
    return _g.fromBinary(new Uint8Array(t));
  }
};
function HD(s, t) {
  return Math.floor(Math.random() * (t - s + 1) + s);
}
__name(HD, "HD");
var Ir;
var BD = class {
  static {
    __name(this, "BD");
  }
  constructor(t = {}) {
    DD(this, "opts"), Se(this, Ir, void 0), this.opts = {
      initialTimeout: t.initialTimeout || 1e3,
      maxTimeout: t.maxTimeout || 1e4,
      factor: t.factor || 2
    }, ne(this, Ir, 0);
  }
  wait() {
    return u(this, null, function* () {
      ne(this, Ir, M(this, Ir) + 1);
      const t = HD(0, Math.min(this.opts.maxTimeout, this.opts.initialTimeout * ep(2, M(this, Ir))));
      yield new Promise((e) => {
        setTimeout(e, t);
      });
    });
  }
  getAttempts() {
    return M(this, Ir);
  }
  reset() {
    ne(this, Ir, 0);
  }
};
Ir = /* @__PURE__ */ new WeakMap();
var wr = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
var ui;
var hi;
var qD = class {
  static {
    __name(this, "qD");
  }
  constructor(t) {
    Se(this, ui, void 0), Se(this, hi, void 0), ne(this, ui, console), ne(this, hi, t);
  }
  debug(...t) {
    wr[M(this, hi)] > wr.debug || M(this, ui).debug("[Sockrates]:", ...t);
  }
  info(...t) {
    wr[M(this, hi)] > wr.info || M(this, ui).info("[Sockrates]:", ...t);
  }
  warn(...t) {
    wr[M(this, hi)] > wr.warn || M(this, ui).warn("[Sockrates]:", ...t);
  }
  error(...t) {
    wr[M(this, hi)] > wr.error || M(this, ui).error("[Sockrates]:", ...t);
  }
};
ui = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap();
var qS = /* @__PURE__ */ ((s) => (s[s.CONNECTING = 0] = "CONNECTING", s[s.OPEN = 1] = "OPEN", s[s.CLOSING = 2] = "CLOSING", s[s.CLOSED = 3] = "CLOSED", s))(qS || {});
var jD = "2";
var GD = "3";
var Ae;
var Ia;
var Ee;
var Ue;
var Ar;
var Ye;
var gr;
var Xr;
var ys;
var Aa;
var Bs;
var dh;
var jS;
var wo;
var Cd;
var lh;
var GS;
var uh;
var Pg;
var Fd;
var hh;
var ph;
var WS;
var Ao;
var Rd;
var Mo;
var Hd;
var Bd;
var gh;
var $a;
var Do;
var Oo;
var qd;
var WD = class {
  static {
    __name(this, "WD");
  }
  constructor(t, e) {
    var F;
    Se(this, dh), Se(this, wo), Se(this, lh), Se(this, uh), Se(this, Fd), Se(this, ph), Se(this, Ao), Se(this, Mo), Se(this, Bd), Se(this, $a), Se(this, Oo), Se(this, Ae, void 0), Se(this, Ia, void 0), Se(this, Ee, void 0), Se(this, Ue, void 0), Se(this, Ar, void 0), Se(this, Ye, void 0), Se(this, gr, void 0), Se(this, Xr, void 0), Se(this, ys, void 0), Se(this, Aa, void 0), Se(this, Bs, void 0);
    var r, i, n, o, c, d, l, p, f;
    ne(this, Ia, t), ne(this, Ar, []), ne(this, Ye, new $d()), ne(this, gr, true), ne(this, ys, false), ne(this, Ee, e != null ? e : {}), (r = M(this, Ee)).autoReconnect != null || (r.autoReconnect = true), (i = M(this, Ee)).retryConnectionInterval != null || (i.retryConnectionInterval = 1e3), (n = M(this, Ee)).pingTimeout != null || (n.pingTimeout = 3e4), (o = M(this, Ee)).connectionTimeout != null || (o.connectionTimeout = 5e3), (c = M(this, Ee)).debug != null || (c.debug = true), (d = M(this, Ee)).maxReconnectionAttempts != null || (d.maxReconnectionAttempts = 10), (l = M(this, Ee)).disconnectOnPingTimeout != null || (l.disconnectOnPingTimeout = true), (p = M(this, Ee)).queueOnDisconnect != null || (p.queueOnDisconnect = false), (f = M(this, Ee)).flushOnReconnect != null || (f.flushOnReconnect = false), ne(this, Xr, {
      code: void 0,
      reason: void 0
    }), ne(this, Ue, (F = M(this, Ee).logger) != null ? F : new qD(M(this, Ee).debug ? "debug" : "info")), ne(this, Bs, new BD());
  }
  get readyState() {
    var t;
    return (t = M(this, Ae)) == null ? void 0 : t.readyState;
  }
  get url() {
    return M(this, Ia);
  }
  updateURL(t) {
    ne(this, Ia, t), _e(this, ph, WS).call(this);
  }
  get config() {
    return M(this, Ee);
  }
  get sendQueue() {
    return M(this, Ar);
  }
  flush() {
    if (!M(this, Ee).queueOnDisconnect)
      return false;
    const t = [];
    return M(this, Ar).forEach((e) => {
      this.send(e.event, e.id, e.payload, e.metadata) || t.push(e);
    }), ne(this, Ar, t), M(this, Ar);
  }
  connect(t = false) {
    return u(this, null, function* () {
      if (!t && [
        0,
        1
      ].includes(this.readyState)) {
        M(this, Ue).debug("Websocket was already connecting or connected.");
        return;
      }
      if (M(this, gr) !== false)
        return new Promise((e, r) => {
          _e(this, $a, Do).call(this), _e(this, Oo, qd).call(this);
          try {
            ne(this, Ae, new WebSocket(_e(this, dh, jS).call(this, M(this, Ia)))), M(this, Ae).binaryType = "arraybuffer", M(this, Ue).debug("Connecting");
            const i = setTimeout(() => {
              M(this, Ue).debug("Connection timeout. Closing socket"), ne(this, gr, true), _e(this, Oo, qd).call(this), M(this, Ae).close(3001, "Connection Timeout"), M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ye).emit(
                "reconnecting"
              ), _e(this, Ao, Rd).call(this)), r(new Error("Connection timed out!"));
            }, M(this, Ee).connectionTimeout);
            M(this, Ae).onopen = () => {
              M(this, Ue).debug(`Ready State: ${qS[M(this, Ae).readyState]}`), i && clearTimeout(i), _e(this, Bd, gh).call(this), ne(this, Xr, {
                code: void 0,
                reason: void 0
              }), M(this, Ye).emit(
                "connected"
              ), M(this, Ee).flushOnReconnect && this.flush(), e();
            }, M(this, Ae).onclose = (n) => {
              try {
                i && clearTimeout(i);
                const { code: o, reason: c } = n;
                r(c), M(this, Ue).debug("Socket closed. Close event:", { event: n }), M(this, Ue).debug(`Connection closed code: ${o}`), M(this, Ue).debug(`Connection closed reason: ${c}`), M(this, ys) || _e(this, Fd, hh).call(this, o, c);
              } catch (o) {
                _e(this, wo, Cd).call(this, o);
              }
            }, M(this, Ae).onerror = (n) => {
              _e(this, wo, Cd).call(this, n);
            }, M(this, Ae).onmessage = (n) => _e(this, lh, GS).call(this, n);
          } catch (i) {
            _e(this, wo, Cd).call(this, i, r);
          }
        });
    });
  }
  send(t, e, r, i) {
    const n = { event: t, id: e, payload: r, metadata: i };
    if (M(this, Ee).queueOnDisconnect && (!M(this, Ae) || M(this, Ae).readyState !== 1))
      return M(this, Ue).debug("Queuing message since socket is not connected!", n), M(this, Ar).push(n), false;
    const o = BS.encode(n);
    return _e(this, Mo, Hd).call(this, o);
  }
  emit(t, e, r, i) {
    return this.send(t, e, r, i);
  }
  sendRaw(t) {
    return _e(this, Mo, Hd).call(this, t);
  }
  receive(t, e) {
    return M(this, Ye).on(t.toString(), e);
  }
  on(t, e) {
    if (typeof t == "string" && (t === "connected" || t === "disconnected" || t === "errored" || t === "reconnected" || t === "reconnecting" || t === "reconnectAttempt" || t === "reconnectFailure" || t === "failed")) {
      M(this, Ye).on(t, e);
      return;
    }
    this.receive(t, e);
  }
  removeAllListeners() {
    M(this, Ye).removeAllListeners();
  }
  removeReceiver(t, e) {
    this.removeListener(t, e);
  }
  removeListener(t, e) {
    M(this, Ye).removeListener(t.toString(), e);
  }
  removeReceivers(t) {
    this.removeListeners(t);
  }
  removeListeners(t) {
    M(this, Ye).listeners(t.toString()).map(
      (e) => this.removeListener(t, e)
    );
  }
  disconnect() {
    ne(this, gr, false), _e(this, $a, Do).call(this), this.removeAllListeners(), ne(this, Xr, {
      code: 1e3,
      reason: "Sockrates disconnect method called"
    }), M(this, Ae).close(1e3, "Sockrates disconnect method called.");
  }
};
Ae = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), Ee = /* @__PURE__ */ new WeakMap(), Ue = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), gr = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Bs = /* @__PURE__ */ new WeakMap(), dh = /* @__PURE__ */ new WeakSet(), jS = /* @__PURE__ */ __name(function(s) {
  if (s.startsWith("ws://") || s.startsWith("wss://"))
    return s;
  if (s.startsWith("https://"))
    return `wss://${s.substring(8)}`;
  if (s.startsWith("http://"))
    return `ws://${s.substring(7)}`;
  throw new Error("Invalid URL. URL must start with http(s):// or ws(s)://.");
}, "jS"), wo = /* @__PURE__ */ new WeakSet(), Cd = /* @__PURE__ */ __name(function(s, t) {
  M(this, Ue).error("Error:", { error: s }), M(this, Ye).emit("errored", { error: s }), t == null || t(s);
}, "Cd"), lh = /* @__PURE__ */ new WeakSet(), GS = /* @__PURE__ */ __name(function(s) {
  if (_e(this, Bd, gh).call(this), s.data === jD) {
    M(this, Ue).debug("Received ping from server"), _e(this, Mo, Hd).call(this, GD);
    return;
  }
  const t = BS.decode(s.data), { id: e, payload: r } = t;
  M(this, Ue).debug("Received message", { event: t.event, messageID: e }), M(this, Ye).emit(t.event.toString(), { id: e, payload: r });
}, "GS"), uh = /* @__PURE__ */ new WeakSet(), Pg = /* @__PURE__ */ __name(function() {
  return M(this, Ae).readyState === 1;
}, "Pg"), Fd = /* @__PURE__ */ new WeakSet(), hh = /* @__PURE__ */ __name(function(s, t) {
  ne(this, Xr, { reason: t, code: s }), M(this, Ye).emit("disconnected", { code: s, reason: t });
}, "hh"), ph = /* @__PURE__ */ new WeakSet(), WS = /* @__PURE__ */ __name(function() {
  const { reason: s, code: t } = M(this, Xr);
  t && t !== 1e3 && M(this, gr) && M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ue).debug(`Triggering reconnection due to ${s}.`), M(this, Ye).emit(
    "reconnecting"
  ), _e(this, Ao, Rd).call(this));
}, "WS"), Ao = /* @__PURE__ */ new WeakSet(), Rd = /* @__PURE__ */ __name(function(s = true) {
  return u(this, null, function* () {
    if (s && M(this, ys)) {
      M(this, Ue).debug("Reconnect called when already in a reconnect loop. Ignoring.");
      return;
    }
    if (M(this, ys) || M(this, Bs).reset(), M(this, Ee).maxReconnectionAttempts !== null && M(this, Bs).getAttempts() >= M(this, Ee).maxReconnectionAttempts) {
      M(this, Ye).emit(
        "failed"
      ), ne(this, ys, false);
      return;
    }
    ne(this, ys, true), _e(this, Oo, qd).call(this), _e(this, $a, Do).call(this);
    try {
      if (yield M(this, Bs).wait(), M(this, gr) === false)
        return;
      if (M(this, Ue).debug(`Reconnection attempt ${M(this, Bs).getAttempts()}`), M(this, Ye).emit("reconnectAttempt", { attempt: M(this, Bs).getAttempts() }), yield this.connect(), !_e(this, uh, Pg).call(this))
        throw Error("Reconnect Failed");
      ne(this, ys, false), ne(this, Xr, {
        code: void 0,
        reason: void 0
      }), M(this, Ye).emit(
        "reconnected"
      );
    } catch (t) {
      M(this, Ue).debug("Failed to reconnect."), M(this, Ye).emit("reconnectFailure", { attempt: M(this, Bs).getAttempts() }), _e(this, Ao, Rd).call(this, false);
    }
  });
}, "Rd"), Mo = /* @__PURE__ */ new WeakSet(), Hd = /* @__PURE__ */ __name(function(s) {
  try {
    return M(this, Ae).send(s), true;
  } catch (t) {
    return M(this, Ue).error(t.message), false;
  }
}, "Hd"), Bd = /* @__PURE__ */ new WeakSet(), gh = /* @__PURE__ */ __name(function() {
  this.config.disconnectOnPingTimeout && (M(this, Ue).debug("Resetting ping timeout"), _e(this, $a, Do).call(this), ne(this, Aa, setTimeout(() => {
    var s;
    M(this, Ue).debug("Disconnecting the socket due to ping timeout"), ne(this, gr, true);
    const t = 3002, e = "Ping timeout";
    (s = M(this, Ae)) == null || s.close(t, e), _e(this, Fd, hh).call(this, t, e);
  }, M(this, Ee).pingTimeout)));
}, "gh"), $a = /* @__PURE__ */ new WeakSet(), Do = /* @__PURE__ */ __name(function() {
  M(this, Aa) && (clearTimeout(M(this, Aa)), ne(this, Aa, void 0));
}, "Do"), Oo = /* @__PURE__ */ new WeakSet(), qd = /* @__PURE__ */ __name(function() {
  M(this, Ae) && (M(this, Ae).onopen = void 0, M(this, Ae).onerror = void 0, M(this, Ae).onmessage = void 0, M(this, Ae).onclose = void 0);
}, "qd");
var JD = Object.defineProperty;
var KD = Object.getOwnPropertyDescriptor;
var Zl = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JD(t, e, i), i;
}, "Zl");
var Cg = 65535;
var zD = 3e3;
var zr;
var Pe;
var Ce;
var De;
var rs;
var st;
var Fc;
var mh;
var Hc;
var fh;
var jg;
var JS = (jg = class {
  static {
    __name(this, "jg");
  }
  constructor(s, {
    peerId: t,
    meetingId: e,
    authToken: r,
    capabilities: i
  }) {
    g(this, Ce);
    g(this, Fc);
    g(this, Hc);
    g(this, zr, void 0);
    g(this, Pe, void 0);
    h(this, "roomName");
    h(this, "authToken");
    h(this, "capabilities");
    g(this, rs, void 0);
    g(this, st, void 0);
    var n;
    if (!t || !e || !r)
      throw new R("peerId, meetingId, or authToken can not be empty", "0404");
    m(this, rs, void 0), m(this, st, s), this.capabilities = i, this.roomName = e, this.authToken = r, m(this, zr, L(this, Fc, mh).call(this, t)), m(this, Pe, new WD(a(this, zr), {
      autoReconnect: true,
      disconnectOnPingTimeout: (n = i.includes("PING")) != null ? n : false,
      queueOnDisconnect: true,
      flushOnReconnect: false,
      logger: this.logger
    })), this.handleSocketConnectionEvents();
  }
  get joinAttempted() {
    return a(this, Ce, De).socketJoinAttempted;
  }
  set joinAttempted(s) {
    a(this, Ce, De).socketJoinAttempted = s;
  }
  get telemetry() {
    return a(this, st).getValue("telemetry");
  }
  get logger() {
    return a(this, st).getValue("logger");
  }
  get peerId() {
    return a(this, st).getValue("peerId");
  }
  updateURL(s) {
    s !== this.peerId && (m(this, zr, L(this, Fc, mh).call(this, s)), this.logger.debug("SocketService:: Connection URL updated.")), a(this, Pe).updateURL(a(this, zr));
  }
  static getSocketEdgeDomain(s) {
    return da({ servicePrefix: "socket-edge", baseURI: s });
  }
  get url() {
    return a(this, zr);
  }
  connect() {
    return u(this, null, function* () {
      a(this, Ce, De).socketJoinAttempted = true, yield a(this, Pe).connect(), a(this, Ce, De).socketJoinAttempted = true, a(this, Ce, De).socketState = {
        state: "connected",
        reconnected: false,
        reconnectionAttempt: void 0
      };
    });
  }
  disconnect() {
    a(this, Ce, De).socketJoinAttempted = false, a(this, Pe).disconnect(), a(this, Ce, De).socketJoinAttempted = true, a(this, Ce, De).socketState = {
      state: "disconnected",
      reconnected: false,
      reconnectionAttempt: void 0
    };
  }
  get isConnected() {
    try {
      return a(this, Pe).readyState === 1;
    } catch (s) {
      return false;
    }
  }
  sendMessage(s, t, e) {
    const r = {};
    return a(this, st).getValue("telemetry").injectContext(r), a(this, Pe).send(
      s,
      e != null ? e : L(this, Hc, fh).call(this),
      t,
      new TextEncoder().encode(JSON.stringify(r))
    );
  }
  sendMessagePromise(s, t, e, r) {
    const i = parseInt({}.SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT, 10) || 2e4;
    return this.sendMessagePromiseWithTimeout({
      event: s,
      timeout: i,
      protobuf: t,
      messageId: e,
      resp: r
    });
  }
  sendMessagePromiseWithTimeout({
    event: s,
    timeout: t,
    protobuf: e,
    messageId: r,
    resp: i
  }) {
    const n = i != null ? i : s;
    return new Promise(
      (o, c) => {
        const d = /* @__PURE__ */ __name((_, P) => {
          a(this, Pe).removeListener(n, _), a(this, Pe).removeListener(Cg, P), a(this, Pe).removeListener(
            is.errorResponse,
            P
          ), a(this, Pe).removeListener(
            Ts.errorResponse,
            P
          );
        }, "d"), l = r != null ? r : L(this, Hc, fh).call(this), p = {};
        a(this, st).getValue("telemetry").injectContext(p);
        const S = /* @__PURE__ */ __name(({
          id: _,
          payload: P
        }) => {
          if (l === _) {
            let w;
            try {
              const A = YR.fromBinary(P);
              w = new Error(A.errorMessage);
            } catch (A) {
              w = new Error("failed to parse error message", { cause: A });
              try {
                const N = Qw.fromBinary(P);
                w = new Error(N.message);
              } catch (N) {
                w = new Error("failed to parse error message", { cause: N });
              }
            }
            c(w), d(T, S);
          }
        }, "S"), T = /* @__PURE__ */ __name(({
          id: _,
          payload: P
        }) => {
          l === _ && (o({ id: _, payload: P }), d(T, S));
        }, "T");
        a(this, Pe).on(n, T), a(this, Pe).on(Cg, S), a(this, Pe).on(is.errorResponse, S), a(this, Pe).on(Ts.errorResponse, S), setTimeout(() => {
          d(T, S), c(new Error(`request timeout for callback eventId:${s}`));
        }, t), a(this, Pe).send(
          s,
          l,
          e,
          new TextEncoder().encode(JSON.stringify(p))
        );
      }
    );
  }
  on(s, t) {
    a(this, Pe).on(s, t);
  }
  onStateEvent(s, t) {
    a(this, Pe).on(s, t);
  }
  removeListener(s, t) {
    a(this, Pe).removeListener(s, t);
  }
  removeListeners(s) {
    a(this, Pe).removeListeners(s);
  }
  flush() {
    return a(this, Pe).flush();
  }
  handleSocketConnectionEvents() {
    this.onStateEvent("connected", () => u(this, null, function* () {
      this.logger.info("SocketService::Connected to socket-edge"), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, Ce, De).updateSocketConnectionState("connected");
    })), this.onStateEvent("disconnected", ({ code: s, reason: t }) => {
      var i;
      this.logger.info("SocketService::Disconnected from socket-edge", { error: { code: s, reason: t }, country: E.location.country });
      const { recv: e, send: r } = (i = a(this, Ce, De).mediaState) != null ? i : {};
      e != null && e.state && (e == null ? void 0 : e.state) !== xa.CONNECTED || r != null && r.state && (r == null ? void 0 : r.state) !== xa.CONNECTED ? a(this, st).getValue("peerSessionStore").emit(
        k.SOCKET_SERVICE_DISCONNECTED,
        {
          joinAttempted: a(this, Ce, De).joinAttempted
        }
      ) : m(this, rs, setTimeout(() => {
        a(this, st).getValue("peerSessionStore").emit(
          k.SOCKET_SERVICE_DISCONNECTED,
          { joinAttempted: a(this, Ce, De).joinAttempted }
        ), m(this, rs, void 0);
      }, zD)), a(this, Ce, De).updateSocketConnectionState("disconnected");
    }), this.onStateEvent("reconnecting", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnecting to socket-edge", { country: E.location.country }), a(this, Ce, De).updateSocketConnectionState("reconnecting");
    })), this.onStateEvent("reconnectAttempt", (t) => u(this, [t], function* ({ attempt: s }) {
      this.logger.info("SocketService::Attempting to reconnect to socket-edge", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectAttempt", s);
    })), this.onStateEvent("reconnectFailure", ({ attempt: s }) => {
      this.logger.info("SocketService::Reconnect attempt to socket-edge failed", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectFailure", s);
    }), this.onStateEvent("reconnected", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnected to socket-edge", { connectionState: { joinAttempted: a(this, Ce, De).mediaJoinAttempted } }), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_RECONNECTED, {
        wasJoinAttempted: a(this, Ce, De).mediaJoinAttempted
      }), a(this, Ce, De).updateSocketConnectionState("reconnected");
    })), this.onStateEvent("failed", () => u(this, null, function* () {
      this.logger.info("SocketService::Failed to connect to socket-edge", { country: E.location.country }), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_FAILED), a(this, Ce, De).updateSocketConnectionState("failed");
    }));
  }
}, zr = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), Ce = /* @__PURE__ */ new WeakSet(), De = /* @__PURE__ */ __name(function() {
  return a(this, st).getValue("connectionHandler");
}, "De"), rs = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakSet(), mh = /* @__PURE__ */ __name(function(s) {
  let t = JS.getSocketEdgeDomain(a(this, st).getValue("baseURI"));
  typeof Gn(a(this, st), "socket_server_base") == "string" && (t = Gn(a(this, st), "socket_server_base"));
  const e = `wss://${t}`, r = new URL(`${e}/ws`), i = this.peerId, n = B(D({
    roomID: this.roomName,
    peerID: s,
    authToken: this.authToken,
    useMediaV2: true
  }, i !== s && { oldPeerID: i }), {
    ping: this.capabilities.includes("PING"),
    capabilities: this.capabilities.map((o) => Nd[o]).join(" "),
    joinWithDetails: true,
    useCfWorker: true,
    useStartSession: true
  });
  return Object.entries(n).forEach(([o, c]) => {
    r.searchParams.append(o, c.toString());
  }), r.href;
}, "mh"), Hc = /* @__PURE__ */ new WeakSet(), fh = /* @__PURE__ */ __name(function() {
  return `${this.peerId}-${(Math.random() + 1).toString(36).substring(7)}`;
}, "fh"), jg);
var Xc = JS;
Zl([
  E.trace("SocketService.connect")
], Xc.prototype, "connect", 1);
Zl([
  E.trace("SocketService.disconnect")
], Xc.prototype, "disconnect", 1);
Zl([
  E.trace("SocketService.sendMessagePromise")
], Xc.prototype, "sendMessagePromise", 1);
Zl([
  E.trace("SocketService.sendMessagePromiseWithTimeout")
], Xc.prototype, "sendMessagePromiseWithTimeout", 1);
var YD = class {
  static {
    __name(this, "YD");
  }
  constructor(t) {
    h(this, "socketService");
    this.socketService = t;
  }
  handleConnectedRoomsDumpRaw({ payload: t }) {
    var n;
    const e = Cb.fromBinary(t), r = e.meetings.map((o) => {
      var c;
      return {
        id: o.id,
        title: o.title,
        participants: (c = o.participants) != null ? c : []
      };
    });
    return {
      parentMeeting: {
        id: e.parentMeeting.id,
        title: e.parentMeeting.title,
        participants: (n = e.parentMeeting.participants) != null ? n : []
      },
      meetings: r
    };
  }
  handleTransferPeerRaw({ payload: t }) {
    const e = Yb.fromBinary(t);
    return { authToken: e.authToken, meetingId: e.meetingId };
  }
  handleMovedPeerRaw({ payload: t }) {
    const e = vf.fromBinary(t);
    return {
      meetingId: e.meetingId,
      customParticipantId: e.customParticipantId
    };
  }
  handleConnectedRoomsUpdatedRaw({ payload: t }) {
    return Xp.fromBinary(t).payloads.map((r) => ({
      id: r.id,
      title: r.title
    }));
  }
  handleConnectedRoomsDeletedRaw({ payload: t }) {
    return Fb.fromBinary(t).payloads;
  }
  getConnectedRoomsDump() {
    return u(this, null, function* () {
      const t = yield this.socketService.sendMessagePromise(
        x.getConnectedRoomsDump
      );
      return this.handleConnectedRoomsDumpRaw(t);
    });
  }
  createConnectedRooms(t) {
    return u(this, null, function* () {
      const { payload: e } = yield this.socketService.sendMessagePromise(
        x.createConnectedRooms,
        kb.toBinary({ payloads: t })
      );
      return Xp.fromBinary(e).payloads.map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  updateConnectedRooms(t) {
    return u(this, null, function* () {
    });
  }
  disableConnectedRooms(t) {
    return u(this, null, function* () {
      const e = t.map((i) => ({ id: i })), r = yield this.socketService.sendMessagePromise(
        x.deleteConnectedRooms,
        Ub.toBinary({ payloads: e })
      );
      return this.handleConnectedRoomsDeletedRaw(
        r
      );
    });
  }
  movePeersBetweenRooms(t) {
    return u(this, null, function* () {
      try {
        const e = yield this.socketService.sendMessagePromise(
          x.movePeers,
          Wb.toBinary({
            sourceMeetingId: t.sourceMeetingId,
            destinationMeetingId: t.destinationMeetingId,
            participants: t.participants
          })
        );
        return new TextDecoder().decode(e.payload).includes("error") ? { success: false, error: "failed to move participants" } : { success: true };
      } catch (e) {
        return { success: false, error: e };
      }
    });
  }
};
var QD = Object.defineProperty;
var XD = Object.getOwnPropertyDescriptor;
var ZD = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QD(t, e, i), i;
}, "ZD");
var vs;
var KS = class extends qt {
  static {
    __name(this, "KS");
  }
  constructor(e) {
    const r = e.getValue("logger");
    super(r);
    h(this, "meetings", []);
    h(this, "parentMeeting", null);
    g(this, vs, void 0);
    m(this, vs, e);
  }
  get supportsConnectedMeetings() {
    return a(this, vs).getValue("self").id !== "";
  }
  get isActive() {
    return this.meetings.length !== 0;
  }
  validateConnectedMeetingsAction() {
    if (!this.supportsConnectedMeetings)
      throw new Error(`You are not allowed to perform this action.
						Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
  }
  getConnectedMeetings() {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").getConnectedRoomsDump();
    });
  }
  createMeetings(e) {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), (yield a(this, vs).getValue("connectedMeetingsSocketHandler").createConnectedRooms(
        e
      )).map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  updateMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").updateConnectedRooms(
        e.map((r) => ({ meetingId: r.id, title: r.title }))
      );
    });
  }
  deleteMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const r = this.meetings.map((n) => e.includes(n.id) && n.participants.length !== 0 ? this.moveParticipants(
        n.id,
        this.parentMeeting.id,
        n.participants.map((o) => o.id)
      ) : Promise.resolve());
      return yield Promise.all(r), yield a(this, vs).getValue("connectedMeetingsSocketHandler").disableConnectedRooms(
        e
      );
    });
  }
  moveParticipants(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i.map((o) => ({
            id: o
          }))
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i), n;
    });
  }
  moveParticipantsWithCustomPreset(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i.map((o) => o.id)), n;
    });
  }
  moveSuccessHandler(e, r, i) {
    const n = /* @__PURE__ */ new Map();
    [
      ...this.parentMeeting.participants,
      ...this.meetings.flatMap((o) => o.participants)
    ].forEach((o) => n.set(o.id, o)), r === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.concat(
      i.map((o) => n.get(o))
    )), e === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.filter(
      (o) => !i.includes(o.id)
    )), this.meetings = this.meetings.map((o) => {
      if (r === o.id) {
        const c = o.participants.concat(
          i.map((d) => n.get(d))
        );
        return B(D({}, o), {
          participants: c
        });
      }
      if (e === o.id) {
        const c = o.participants.filter(
          (d) => !i.includes(d.id)
        );
        return B(D({}, o), {
          participants: c
        });
      }
      return o;
    });
  }
};
vs = /* @__PURE__ */ new WeakMap();
ZD([
  Dt({ maxInvocations: 60, period: 60 })
], KS.prototype, "getConnectedMeetings", 1);
var eO = Object.defineProperty;
var tO = Object.getOwnPropertyDescriptor;
var Kh = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? tO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && eO(t, e, i), i;
}, "Kh");
var me;
var Gg;
var zS = (Gg = class {
  static {
    __name(this, "Gg");
  }
  constructor(s) {
    h(this, "connectedMeetings");
    g(this, me, void 0);
    m(this, me, s), this.connectedMeetings = new KS(s);
  }
  get telemetry() {
    return a(this, me).getValue("telemetry");
  }
  get logger() {
    return a(this, me).getValue("logger");
  }
  static init(s) {
    const t = new zS(
      s
    );
    return t.connectedMeetings.supportsConnectedMeetings && (t.setupEvents(), s.getValue("self").once(
      "roomJoined",
      () => t.getConnectedMeetings()
    )), t;
  }
  getConnectedMeetings() {
    this.connectedMeetings.getConnectedMeetings();
  }
  setupEvents() {
    a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.getConnectedRoomsDump,
      this.handleConnectedRoomsDump.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.transferPeer,
      this.handleTransferPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.movedPeer,
      this.handleMovedPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsUpdated,
      this.handleConnectedRoomsUpdated.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsDeleted,
      this.handleConnectedRoomsDeleted.bind(this)
    );
  }
  handleTransferPeer(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleTransferPeerRaw(s);
    return this.switchMeeting(t);
  }
  switchMeeting(e) {
    return u(this, arguments, function* ({
      authToken: s,
      meetingId: t
    }) {
      var n, o, c, d;
      if (!this.connectedMeetings.supportsConnectedMeetings)
        throw new Error(`You are not allowed to perform this action.
								Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
      this.logger.info("ConnectedMeetingsController::switchMeeting:: asking ui-kit to show switching breakout UI"), this.connectedMeetings.emit("changingMeeting", t);
      const r = {
        video: a(this, me).getValue("self").videoEnabled,
        audio: a(this, me).getValue("self").audioEnabled
      };
      try {
        a(this, me).getValue("self").cleanupEvents(), yield a(this, me).getValue("meeting").leave("connected-meeting");
      } catch (l) {
        this.logger.error(`ConnectedMeetingsController:: switchMeeting:: issues in leaving previous meeting. Meeting Id: ${(o = (n = a(this, me).getValue("meeting")) == null ? void 0 : n.meta) == null ? void 0 : o.meetingId}`, { error: l });
      }
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initializing new meeting. Meeting Id: ${t}`);
      const i = yield lO.init(B(D({}, a(this, me).getValue("options")), {
        cachedUserDetails: null,
        defaults: B(D(D({}, a(this, me).getValue("options").defaults), r), {
          mediaHandler: a(this, me).getValue("self")
        }),
        authToken: s
      }));
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initialized new meeting. Meeting Id: ${(c = i == null ? void 0 : i.meta) == null ? void 0 : c.meetingId}`);
      try {
        const { hidden: l } = a(this, me).getValue("self");
        i.self.setName(a(this, me).getValue("self").name), yield i.join(), l && i.self.hide();
      } catch (l) {
        this.logger.error("ConnectedMeetingsController.joinRoom", { error: l });
      }
      return this.logger.info(`ConnectedMeetingsController::switchMeeting:: asking ui-kit to show in-meeting ui of newly joined meeting id: ${(d = i == null ? void 0 : i.meta) == null ? void 0 : d.meetingId}`), this.connectedMeetings.emit("meetingChanged", i), i;
    });
  }
  handleConnectedRoomsDump(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDumpRaw(s);
    this.connectedMeetings.meetings = t.meetings.map((e) => ({
      id: e.id,
      title: e.title,
      participants: e.participants || []
    })), this.connectedMeetings.parentMeeting = {
      id: t.parentMeeting.id,
      title: t.parentMeeting.title,
      participants: t.parentMeeting.participants
    }, this.emitStateUpdate();
  }
  handleMovedPeer(s) {
    return a(this, me).getValue("connectedMeetingsSocketHandler").handleMovedPeerRaw(s);
  }
  handleConnectedRoomsUpdated(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsUpdatedRaw(s), e = /* @__PURE__ */ new Map();
    this.connectedMeetings.meetings.forEach((r) => {
      e.set(r.id, r);
    }), t.forEach((r) => {
      e.has(r.id) ? e.get(r.id).title = r.title : e.set(r.id, B(D({}, r), { participants: [] }));
    }), this.connectedMeetings.meetings = Array.from(e.values()), this.emitStateUpdate();
  }
  handleConnectedRoomsDeleted(s) {
    const e = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDeletedRaw(s).map((r) => r.id);
    this.connectedMeetings.meetings = this.connectedMeetings.meetings.filter(
      (r) => !e.includes(r.id)
    ), this.emitStateUpdate();
  }
  emitStateUpdate() {
    this.connectedMeetings.emit("stateUpdate", {
      meetings: this.connectedMeetings.meetings,
      parentMeeting: this.connectedMeetings.parentMeeting
    });
  }
}, me = /* @__PURE__ */ new WeakMap(), Gg);
var eu = zS;
Kh([
  E.trace("ConnectedMeetingsController.getConnectedMeetings")
], eu.prototype, "getConnectedMeetings", 1);
Kh([
  E.trace("ConnectedMeetingsController.setupEvents")
], eu.prototype, "setupEvents", 1);
Kh([
  E.trace("ConnectedMeetingsController.switchMeeting")
], eu.prototype, "switchMeeting", 1);
var sO = Object.defineProperty;
var rO = Object.getOwnPropertyDescriptor;
var tu = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? rO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && sO(t, e, i), i;
}, "tu");
var Ma = class {
  static {
    __name(this, "Ma");
  }
  constructor(s, t, e) {
    h(this, "apiBase");
    h(this, "selfController");
    h(this, "pollController");
    h(this, "chatController");
    h(this, "metaController");
    h(this, "storesManager");
    h(this, "stageController");
    h(this, "pluginController");
    h(this, "internalsController");
    h(this, "recordingController");
    h(this, "livestreamController");
    h(this, "participantController");
    h(this, "connectedMeetingsController");
    h(this, "telemetry");
    h(this, "logger");
    this.apiBase = s, this.storesManager = t.storesManager, this.metaController = t.metaController, this.selfController = t.selfController, this.chatController = t.chatController, this.pollController = t.pollController, this.stageController = t.stageController, this.pluginController = t.pluginController, this.recordingController = t.recordingController, this.internalsController = t.internalsController, this.participantController = t.participantController, this.livestreamController = t.livestreamController, this.connectedMeetingsController = t.connectedMeetingsController, this.telemetry = e.getValue("telemetry"), this.logger = e.getValue("logger");
  }
  static init(s) {
    return u(this, null, function* () {
      var F, K;
      const {
        peerId: t,
        apiBase: e,
        authToken: r,
        meetingId: i,
        organizationId: n,
        cachedUserDetails: o,
        logger: c
      } = s.getAllValues();
      if (MS(s), Te.isSupported() === false)
        throw new R("Browser not supported", "0010", c, true);
      const d = cM(
        s,
        {
          authToken: r,
          baseURL: e,
          cachedUserDetails: o
        }
      );
      d.setRoomName(i), d.setRoomUUID(i), d.setOrganizationId(n), d.setHeader("dyte-tracing-id", t), s.setValue("apiClient", d);
      const l = new jM(s);
      s.setValue("connectionHandler", l);
      const p = Ma.createSocketService(s), f = p.connect(), S = d.getUserDetails(), T = d.getPlugins();
      let _ = we.HIVE, P, w = "";
      try {
        yield Ma.setupFlagsmith(s);
      } catch (re) {
        c.error("Failed to setup flagsmith", { error: re });
      }
      try {
        yield f;
      } catch (re) {
        c.error(
          "[Controller]: Failed to connect to socket server:",
          { error: re }
        );
      }
      try {
        ({ sfu: _, meetingTitle: w } = yield d.getRoomNodeData()), P = yield S, c.info(`SFU ${_} is being used.`), s.setValue("presetName", P.preset.name), s.setValue("roomNodeOptions", { sfu: _ });
      } catch (re) {
        c.error("Failed to get room metadata", { error: re });
      }
      const A = Ku.init(P.preset, !s.getValue("modules").theme), N = Qu.init(
        s,
        A.viewType,
        P.preset.permissions
      ), H = Ma.setupControllers(
        p,
        s,
        P,
        T,
        w,
        A,
        N
      );
      OM(A) && ((F = Ma.createRoomNodeClient(s, p).initializeConnection(
        P.participant.name,
        i,
        false,
        N
      )) == null || F.catch((Je) => {
        c.error(
          "[Controller]: Failed to queue partial media room promise:",
          { error: Je }
        );
      })), E.location.country = (K = d.ipInfo) == null ? void 0 : K.country;
      const { controllers: $ } = yield H;
      return MC(), new Ma(e, $, s);
    });
  }
  static setupFlagsmith(s) {
    return u(this, null, function* () {
      var l;
      const {
        peerId: t,
        baseURI: e,
        overrides: r,
        meetingId: i,
        organizationId: n,
        logger: o
      } = s.getAllValues(), c = AC(i), d = B(D({
        entity: Iu.PEER,
        clientId: n,
        isAnonUser: !n,
        sdkVersion: s.getValue("sdkVersion"),
        presetName: s.getValue("presetName"),
        meetingHash: c,
        roomName: i
      }, Te.getDeviceInfo()), {
        isReactNative: navigator.isReactNative
      });
      try {
        const p = (l = r == null ? void 0 : r.whitelabelled_flags_endpoint) == null || l ? da({ servicePrefix: "flags", baseURI: e }) : "edge.api.flagsmith.com";
        yield s.getValue("flagsmith").identify(
          `${Iu.PEER}_${t}`,
          JSON.parse(JSON.stringify(d)),
          false,
          5e3,
          p,
          o
        ), o.info(
          "flagsmith::allFlags",
          { flags: JSON.stringify(s.getValue("flagsmith").getAllFlags()) },
          true
        );
      } catch (p) {
        o.error("Failed to fetch flagsmith flags");
      }
    });
  }
  static setupControllers(s, t, e, r, i, n, o) {
    return u(this, null, function* () {
      var $e, Cr, Rr;
      const c = t.getValue("modules"), { participant: d } = e, l = t.getValue("defaults"), p = t.getValue("logger"), { sfu: f } = t.getValue("roomNodeOptions"), { viewType: S, mediaConstraints: { audio: T } } = n;
      t.setValue("viewType", S), t.setValue("defaults", D({
        mediaConfiguration: {
          audio: {
            enableHighBitrate: ($e = T.enableHighBitrate) != null ? $e : false,
            enableStereo: (Cr = T.enableStereo) != null ? Cr : false
          }
        }
      }, l)), t.setValue("maxPreferredStreams", Te.isMobile() ? n.maxVideoStreams.mobile : n.maxVideoStreams.desktop);
      let _, P, w, A, N, H, $, F, K;
      const re = new _D(t, s), Je = new YD(
        s
      );
      t.setValue("connectedMeetingsSocketHandler", Je);
      const ks = new Ql(t, s), Pr = new as(t, s), ni = new kD(s), I = new OS(t, s), y = new ID(t, s), C = new ED(s), U = new pa(t, s), ie = yield ai.init(
        t,
        I,
        d,
        o,
        n
      );
      t.setValue("selfController", ie);
      const Me = yield Of.init(
        t,
        ie.self,
        I,
        re,
        i
      );
      if (c.participant && (F = new _r(
        t,
        ie.self,
        I,
        f
      )), (Rr = c.e2ee) != null && Rr.enabled && c.e2ee.manager.init(p, t.getValue("peerSessionStore")), c.chat && (P = yield Es.init(
        t,
        Pr,
        U,
        ie.self,
        F.participants
      )), c.internals && (N = yield Lh.init(t)), c.livestream && n.viewType === Mt.Livestream && t.getValue("flagsmith").hasFeature(X.LIVESTREAM) && ($ = new Bf(
        t,
        ie.self,
        C
      )), n.viewType !== Mt.Chat) {
        if (c.poll && (_ = yield If.init(
          t,
          ie.self,
          ks
        )), c.recording && (H = new xf(
          t,
          ie.self,
          I
        )), c.stage && (w = new Nf(
          t,
          ni,
          I,
          ie.self,
          F.participants
        )), c.plugin) {
          if (!F)
            throw new R(
              "The plugin module cannot be initialized without the `participant` module",
              "0102"
            );
          const Fs = yield r;
          A = yield Kc.init(
            t,
            Fs,
            y,
            Pr,
            P == null ? void 0 : P.chat,
            ie.self,
            F.participants,
            i
          );
        }
        if (c.connectedMeetings && (K = yield eu.init(
          t
        )), c.pip) {
          const Fs = yield Au._init(t, ie.self);
          t.setValue("pip", Fs);
        }
      }
      const b = {
        storesManager: new V0(t, y),
        pollController: _,
        selfController: ie,
        metaController: Me,
        chatController: P,
        stageController: w,
        pluginController: A,
        recordingController: H,
        internalsController: N,
        livestreamController: $,
        participantController: F,
        connectedMeetingsController: K
      };
      return {
        theme: n,
        permissions: o,
        controllers: b
      };
    });
  }
  static createRoomNodeClient(s, t) {
    const {
      peerId: e,
      roomNodeOptions: r
    } = s.getAllValues(), { sfu: i } = r;
    return AS(s, i, {
      socket: t,
      peerId: e
    });
  }
  static createSocketService(s) {
    const {
      peerId: t,
      meetingId: e,
      authToken: r
    } = s.getAllValues(), i = ["PING"];
    return new Xc(s, {
      peerId: t,
      meetingId: e,
      authToken: r,
      capabilities: i
    });
  }
};
var Zc = Ma;
tu([
  E.trace("Controller.init")
], Zc, "init", 1);
tu([
  E.trace("setupFlagsmith")
], Zc, "setupFlagsmith", 1);
tu([
  E.trace("Controller.createRoomNodeClient")
], Zc, "createRoomNodeClient", 1);
tu([
  E.trace("Controller.createSocketService")
], Zc, "createSocketService", 1);
var iO = class {
  static {
    __name(this, "iO");
  }
  constructor() {
    h(this, "battery");
    h(this, "logger");
    h(this, "init", (t) => u(this, null, function* () {
      this.logger = t;
      try {
        "getBattery" in navigator && (this.battery = yield navigator.getBattery(), this.battery.addEventListener("chargingchange", this.updateChargeInfo), this.battery.addEventListener("levelchange", this.updateLevelInfo), this.updateLevelInfo(), this.updateChargeInfo());
      } catch (e) {
        t.error("Error getting battery", e);
      }
    }));
    h(this, "updateChargeInfo", () => {
      var t;
      this.logger.log(
        `Battery charging? ${(t = this.battery) != null && t.charging ? "Yes" : "No"}`
      );
    });
    h(this, "updateLevelInfo", () => {
      if (!this.battery) {
        this.logger.log("Battery level: Not known");
        return;
      }
      this.logger.log(`Battery level: ${this.battery.level * 100}%`);
    });
    h(this, "cleanup", () => {
      var t, e;
      "getBattery" in navigator && ((t = this.battery) == null || t.removeEventListener(
        "chargingchange",
        this.updateChargeInfo
      ), (e = this.battery) == null || e.removeEventListener("levelchange", this.updateLevelInfo));
    });
  }
};
var Rg = new iO();
function aO(s, t) {
  s.startsWith("eyJ") || console.error("Invalid auth token provided. Ensure you are passing a %cparticipant `authToken`%c \u2014 not an Org API Key or an incorrectly formatted token.\nYou get the participant token from the Add Participant API: https://docs.dyte.io/api#/operations/add_participant", "font-weight: bold", "font-weight: normal");
  try {
    const { meetingId: e, orgId: r, participantId: i } = JSON.parse(atob(s.split(".")[1]));
    if (!e)
      throw Error(`Received V1 auth token ${s}`);
    let n = "dyte.io";
    t && (n = t);
    const o = `https://${da({ servicePrefix: "api", baseURI: n })}`;
    return {
      meetingId: e,
      orgId: r,
      participantId: i,
      baseURI: n,
      apiBase: o
    };
  } catch (e) {
    throw new R("Invalid auth token", "0004");
  }
}
__name(aO, "aO");
var Yr;
var aa;
var na;
var Bc;
var Ll;
var YS;
var nO = class {
  static {
    __name(this, "nO");
  }
  constructor() {
    g(this, Ll);
    g(this, Yr, new Audio());
    g(this, aa, new MediaStream());
    g(this, na, /* @__PURE__ */ new Map());
    g(this, Bc, void 0);
    a(this, Yr).srcObject = a(this, aa), a(this, Yr).autoplay = true;
  }
  playTracks(t) {
    return u(this, null, function* () {
      return t.forEach((e) => {
        a(this, na).has(e.id) || (a(this, aa).addTrack(e), a(this, na).set(e.id, e));
      }), this.play();
    });
  }
  setSpeakerDevice(t) {
    typeof HTMLAudioElement.prototype.setSinkId == "function" && a(this, Yr).setSinkId(t);
  }
  removeTrack(t) {
    const e = a(this, na).get(t);
    e && (a(this, aa).removeTrack(e), a(this, na).delete(t));
  }
  play() {
    return u(this, null, function* () {
      return a(this, Yr).srcObject = a(this, aa), a(this, Yr).play().catch((t) => {
        L(this, Ll, YS).call(this, t);
      });
    });
  }
  onError(t) {
    m(this, Bc, t);
  }
};
Yr = /* @__PURE__ */ new WeakMap(), aa = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), Bc = /* @__PURE__ */ new WeakMap(), Ll = /* @__PURE__ */ new WeakSet(), YS = /* @__PURE__ */ __name(function(t) {
  var e;
  (e = a(this, Bc)) == null || e.call(this, t);
}, "YS");
var oa;
var oO = class extends nO {
  static {
    __name(this, "oO");
  }
  constructor() {
    super();
    g(this, oa, void 0);
    m(this, oa, /* @__PURE__ */ new Map());
  }
  addParticipantTrack(e, r) {
    a(this, oa).set(e, r.id), this.playTracks([r]);
  }
  removeParticipantTrack(e) {
    const r = a(this, oa).get(e);
    r && this.removeTrack(r), a(this, oa).delete(e);
  }
};
oa = /* @__PURE__ */ new WeakMap();
var cO = Object.defineProperty;
var dO = Object.getOwnPropertyDescriptor;
var su = /* @__PURE__ */ __name((s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? dO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && cO(t, e, i), i;
}, "su");
var We;
var ca;
var Wg;
var ri = (Wg = class {
  static {
    __name(this, "Wg");
  }
  constructor(t, e) {
    g(this, We, void 0);
    g(this, ca, void 0);
    m(this, ca, t), m(this, We, e);
  }
  get peerId() {
    return a(this, ca).getValue("peerId");
  }
  static initMedia(t = {}, e = false, r = void 0) {
    var d;
    const i = (d = r == null ? void 0 : r.peerId) != null ? d : v4(), n = mr.createContext(i, {
      peerId: i
    }), o = n.getValue("logger");
    o.init(n);
    const c = new zf(o);
    return c.init(t, e, n), n.setValue("defaults", { mediaHandler: c }), c;
  }
  static init(t) {
    return u(this, null, function* () {
      var T, _, P, A, N, H, $;
      Te.init();
      const { mediaHandler: e } = (T = t.defaults) != null ? T : {}, r = (e == null ? void 0 : e.peerId) || ((P = (_ = t == null ? void 0 : t.cachedUserDetails) == null ? void 0 : _.peerId) != null ? P : v4()), { authToken: i, baseURI: n } = t, w = aO(i, n), { meetingId: o } = w, c = ho(w, ["meetingId"]);
      window.__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;
      const d = ri.setupContext(
        r,
        t,
        o,
        c
      ), l = d.getValue("telemetry"), p = d.getValue("logger");
      av(p), Rg.init(p), l.init(d, {
        roomName: o,
        userId: c.participantId,
        organizationId: c.orgId,
        peerId: r
      }, (N = (A = t.modules) == null ? void 0 : A.tracing) != null ? N : true), p.init(d), p.info("DyteClient::init::options", {
        dyteClientInitOptions: B(D({}, t), {
          authToken: `${(H = t.authToken) == null ? void 0 : H.slice(0, 10)}...
				${($ = t.authToken) == null ? void 0 : $.slice(-10)}`
        })
      });
      const f = yield Zc.init(d), S = new ri(d, f);
      return d.setValue("meeting", S), S;
    });
  }
  static setupContext(t, e, r, i) {
    var d, l;
    const n = mr.createContext(t, e), o = D(D({}, _C), e == null ? void 0 : e.modules), c = e.defaults || {
      audio: true,
      video: true
    };
    return n.setValue("options", e), n.setValue("peerId", t), n.setValue("modules", o), n.setValue("sdkName", "web-core"), n.setValue("meetingId", r), n.setValue("apiBase", i.apiBase), n.setValue("baseURI", i.baseURI), n.setValue("userId", i.participantId), n.setValue("organizationId", i.orgId), n.setValue("authToken", e.authToken), n.setValue("overrides", (d = e.overrides) != null ? d : {}), n.setValue("env", PC({ baseURI: i.baseURI })), n.setValue("defaults", c), n.setValue("onError", e.onError || (() => {
    })), n.setValue("cachedUserDetails", _s(e.cachedUserDetails)), n.setValue("sdkVersion", "3.1.7"), (l = e.modules) != null && l.experimentalAudioPlayback && n.setValue("audioPlayback", new oO()), n;
  }
  join() {
    return u(this, null, function* () {
      const { selfController: t } = a(this, We);
      return t.self.roomJoined ? null : t.joinRoom();
    });
  }
  leave(t) {
    return u(this, null, function* () {
      Rg.cleanup(), a(this, ca).getValue("peerSessionStore").reset();
      const { selfController: e } = a(this, We);
      return e.leaveRoom(t);
    });
  }
  get participants() {
    var t;
    return (t = a(this, We).participantController) == null ? void 0 : t.participants;
  }
  get self() {
    var t;
    return (t = a(this, We).selfController) == null ? void 0 : t.self;
  }
  get meta() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.meta;
  }
  get ai() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.ai;
  }
  get plugins() {
    var t;
    return (t = a(this, We).pluginController) == null ? void 0 : t.plugins;
  }
  get chat() {
    var t;
    return (t = a(this, We).chatController) == null ? void 0 : t.chat;
  }
  get polls() {
    var t;
    return (t = a(this, We).pollController) == null ? void 0 : t.polls;
  }
  get connectedMeetings() {
    var t;
    return (t = a(this, We).connectedMeetingsController) == null ? void 0 : t.connectedMeetings;
  }
  get recording() {
    var t;
    return (t = a(this, We).recordingController) == null ? void 0 : t.recording;
  }
  get livestream() {
    var t;
    return (t = a(this, We).livestreamController) == null ? void 0 : t.livestream;
  }
  get stage() {
    var t;
    return (t = a(this, We).stageController) == null ? void 0 : t.stage;
  }
  get stores() {
    return a(this, We).storesManager;
  }
  get audio() {
    return a(this, ca).getValue("audioPlayback");
  }
  get __internals__() {
    var t;
    return (t = a(this, We).internalsController) == null ? void 0 : t.internals;
  }
  joinRoom() {
    return u(this, null, function* () {
      return this.join();
    });
  }
  leaveRoom(t) {
    return u(this, null, function* () {
      return this.leave(t);
    });
  }
}, We = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), Wg);
su([
  ht("0002"),
  Er.executeWithLock({
    methodName: "meeting.join",
    lockName: "DyteClient.join",
    timeout: 3e3
  })
], ri.prototype, "join", 1);
su([
  ht("0003")
], ri.prototype, "leave", 1);
su([
  ht("0001"),
  Er.executeWithLock({
    methodName: "DyteClient.init",
    lockName: "DyteClient.init",
    timeout: 3e3
  })
], ri, "init", 1);
ri = su([
  ht("0000")
], ri);
var lO = ri;

// src/index.js
var app = new Hono2();
var LoginSchema = external_exports.object({
  username: external_exports.string(),
  password: external_exports.string()
});
var CollectSchema = external_exports.object({
  template: external_exports.string(),
  data: external_exports.any()
});
var MeetingSchema = external_exports.object({
  title: external_exports.string().optional()
});
app.get("/ping", (c) => {
  return c.json({
    status: "ok",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    service: "storm-worker"
  });
});
app.post("/api/login", async (c) => {
  const { username, password } = await c.req.json();
  const USERS = {
    admin: "admin"
  };
  if (USERS[username] === password) {
    return c.json({ success: true, token: "dummy-token" });
  }
  return c.json({ success: false }, 401);
});
app.get("/api/results", async (c) => {
  try {
    const { results } = await c.env.DB.prepare("SELECT * FROM logs ORDER BY timestamp DESC").all();
    return c.json(results);
  } catch (e) {
    console.error(e);
    return c.json({ success: false, error: "Failed to read from database." }, 500);
  }
});
app.post("/api/clear", async (c) => {
  try {
    await c.env.DB.prepare("DELETE FROM logs").run();
    return c.json({ success: true });
  } catch (e) {
    console.error(e);
    return c.json({ success: false, error: "Failed to clear database." }, 500);
  }
});
app.post("/api/collect", async (c) => {
  const { template, data } = await c.req.json();
  try {
    let fileUrl = null;
    let logData = data;
    if (template === "camera_temp" && data.image) {
      const key = `image-${Date.now()}.png`;
      const body = Buffer.from(data.image, "base64");
      await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: "image/png" } });
      fileUrl = `/r2/${key}`;
      logData = { ...data, imageUrl: fileUrl, image: void 0 };
    } else if (template === "microphone" && data.audio) {
      const key = `audio-${Date.now()}.wav`;
      const audioBase64 = data.audio.split(",")[1];
      const body = Buffer.from(audioBase64, "base64");
      await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: "audio/wav" } });
      fileUrl = `/r2/${key}`;
      logData = { ...data, audioUrl: fileUrl, audio: void 0 };
    }
    const stmt = c.env.DB.prepare(
      "INSERT INTO logs (template, data) VALUES (?, ?)"
    ).bind(template, JSON.stringify(logData));
    await stmt.run();
    return c.text("Data collected successfully.");
  } catch (e) {
    console.error(e);
    return c.json({ success: false, error: "Failed to write to database/bucket. Make sure you have run migrations and configured bindings." }, 500);
  }
});
app.get("/api/templates", (c) => {
  const templates = [
    "camera_temp",
    "microphone",
    "nearyou",
    "normal_data",
    "weather"
  ];
  return c.json(templates);
});
app.post("/api/meetings", async (c) => {
  const { title } = await c.req.json();
  const ACTIVE_MEETING_KEY = "active_meeting_id";
  const realtime = new lO(c.env.REALTIMEKIT_API_KEY, {
    realtimeKitOrgId: c.env.REALTIMEKIT_ORG_ID
  });
  try {
    let meetingId = await c.env.KV.get(ACTIVE_MEETING_KEY);
    if (!meetingId) {
      console.log("No active meeting found, creating a new one.");
      const meeting = await realtime.createMeeting({
        title: title || "Live Stream",
        recordOnStart: true
      });
      meetingId = meeting.id;
      await c.env.KV.put(ACTIVE_MEETING_KEY, meetingId);
    } else {
      console.log(`Found active meeting: ${meetingId}`);
    }
    const participant = await realtime.addParticipant(meetingId, {
      name: "Viewer",
      presetName: "group_call_participant",
      customParticipantId: "viewer-" + Math.random().toString(36).substring(7)
    });
    return c.json({
      meetingId,
      authToken: participant.token
    });
  } catch (error) {
    console.error(error);
    return c.json({ success: false, error: "Failed to create or join meeting" }, 500);
  }
});
app.post("/api/meetings/end", async (c) => {
  const ACTIVE_MEETING_KEY = "active_meeting_id";
  await c.env.KV.delete(ACTIVE_MEETING_KEY);
  return c.json({ success: true, message: "Active meeting ended." });
});
app.get("/r2/:key", async (c) => {
  const key = c.req.param("key");
  const object = await c.env.BUCKET.get(key);
  if (object === null) {
    return c.notFound();
  }
  const headers = new Headers();
  object.writeHttpMetadata(headers);
  headers.set("etag", object.httpEtag);
  return new Response(object.body, {
    headers
  });
});
app.get("/", (c) => c.json({ message: "Storm Worker is running!" }));
app.get("*", (c) => {
  return c.env.ASSETS.fetch(c.req.raw);
});
var src_default = app;

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-gfKrxp/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-gfKrxp/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker2) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker2;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker2.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker2.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker2,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker2.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker2.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

@cloudflare/realtimekit/dist/index.es.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=index.js.map
